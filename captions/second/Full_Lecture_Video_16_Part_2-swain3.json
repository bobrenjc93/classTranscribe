[{"text":"when i'm acctually implementing the function, i've got to have a name. yes.","width":512},{"text":"right, the goal here is to have this second parameter be some object that overrides operator parentheses.","width":640},{"text":"but i don't know what type that object is ahed of time, and I dont want to say it has to be a derived class of tree functor of something. I just want this to be any ","width":640},{"text":"old class somebody could come up with later and so what's gonna happen here is that, im gonna have this function itslef be a template and then whaterver the user gives e as second argument","width":576},{"text":"is filled in for type fu, so if they give me a mult x as the second argument here, im going to get a template function stamped out","width":832},{"text":"traverse, const node star. so im allowed to pass here any funtor with no restriction to what is subclass is","width":896},{"text":"just something that happens to override operator paranthesis. the way of making this generic without having to make a pointer to some base classically","width":640},{"text":"that everybody has to draw. This i slike static polymorphism of C++, where this traverse funtion is gonna do different things depending on what I pass it","width":640},{"text":"but it has nothing to do with, dynamic dispatch or virtual funtions, because a separate function is being created","width":448},{"text":"for any type of functor that I give.","width":512},{"text":"","width":256},{"text":"so thats what it looked like in the header","width":64},{"text":"why is it const, why is the member function const","width":384},{"text":"that is why is this const there, should change the tree, right. so im just looking at the","width":640},{"text":"elements, im calling some function on the elements on the tree but i'm not modifying the tree here","width":256},{"text":"just looking, so this should be declared const, because i dont want to ever modify the tree.","width":448},{"text":"furhermore if im given a const reference to a binary tree, i have to be able to traverse it.","width":320},{"text":"if this is not declared const then i've got a const reference to a tree, i cant call a non const function on a const reference, it doesnt work that way.","width":576},{"text":"const reference, i cant change it. so this has to be declare const if i wanna call through a const reference","width":640},{"text":"furthermore its const because it cant modify the tree.","width":192},{"text":"2 reasons fo the const","width":256},{"text":"so could write a separate, so in this case no","width":768},{"text":"I wont be modifying the elements, but i couldwrite a separate one that did so.","width":320},{"text":"in which case i could not declare const","width":192},{"text":"if i wanted one of these traverse functions, be a transform function that changes the data elements, i could have a","width":512},{"text":"one of those as well","width":64},{"text":"i would have to change wether there is const after this or not.","width":256},{"text":"If i wanna modify the tree then it cant be const. here Im just gonna look, all its gonna do is run on the data elements","width":320},{"text":"not gonna modify them, its just gonna call the functor on them","width":192},{"text":"so here im not modifying the tree.","width":128},{"text":"the functor is gonna print, or something, or save to file or do something else","width":512},{"text":"but its not modifying the tree itselfokay","width":320},{"text":"why do i have a const star on the node star that im passing into the function","width":256},{"text":"","width":320},{"text":"what is that const mean","width":128},{"text":"soo, const node star p whats conat","width":640},{"text":"the pointer or the node, the node","width":320},{"text":"so im saying that through this pointer im not gonna change the node, which is what im saying is that","width":192},{"text":"i got a pointer to a node that im not gonna modify that node","width":256},{"text":"i might change the pointer to lok sokmwhrere else","width":448},{"text":"but i dont wanna change the node themselves","width":64},{"text":"so im passing in a const node star","width":128},{"text":"or equivalently a node const star","width":192},{"text":"thenode is the const","width":192},{"text":"has to be const","width":64},{"text":"because im looking at internals of the","width":128},{"text":"tree and i said im not gonna modify the tree","width":128},{"text":"better be const","width":64},{"text":"otherwise im allowed to modify the tree, and i've brokent the whole const ","width":320},{"text":"has to be const","width":192},{"text":"becuse im going over elements of tree","width":320},{"text":"logivaaly i wont modify the tree, because i wont modify the tree, but i do still need the const at the end","width":576},{"text":"in order to be able to call const references","width":256},{"text":"if the trailing const is not there , i can modify the tree, compiler doesnt know that","width":512},{"text":"you might change root","width":320},{"text":"this first template is for the binary tree class","width":768},{"text":"the first t here is for the binary tree t","width":192},{"text":"i need a second one","width":64},{"text":"","width":640},{"text":"the signify the function is a template","width":384},{"text":"well this is gonna be","width":576},{"text":"a recussive funciton","width":192},{"text":"everything weve done with this tree has been involving recursion","width":64},{"text":"definitions","width":192},{"text":"and thinking about things using induction, a recursive funtions","width":448},{"text":"recursive print that we did on the list class because its kind of","width":128},{"text":"similar, we have 2 directions, whta is base case for this recursive function","width":512},{"text":"whats the smallest thing empty","width":192},{"text":"how would i say wether the subroot is pointing at an empty tree, its null ,so i could say if not subroot","width":896},{"text":"remember a pointer is true if its points to somethin not null and is false if it pointes to something that is null","width":640},{"text":"so not subroot would negate that so its saying if its nul not subroot will be true and false otherwise","width":448},{"text":"this is the exact same thing as saying subroot equals equals null pointer","width":384},{"text":"just shorter","width":320},{"text":"","width":576},{"text":"the difference is what ur treating as bas case","width":512},{"text":"if im checking the left and right for null ,im treating the","width":192},{"text":"tree with one node as base case, ither is fine, but be careful if u treate the single node as base case you still have to print that nide","width":640},{"text":"node","width":64}]