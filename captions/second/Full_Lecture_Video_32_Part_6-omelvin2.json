[{"text":"great okay so we've got time for a final little demo","width":433.18181824684143},{"text":"and what we're going to do is instead of the system stealing one of our threads","width":573.1818182468414},{"text":"to handle a signal","width":227.18181824684143},{"text":"we are going to explicitly create a thread","width":180.18181824684143},{"text":"that pulls signals one at a time and handles them","width":222.18181824684143},{"text":"so its more code to write","width":181.18181824684143},{"text":"but it's less likely to.. it own't suffer from asynchronous signal problems if we're careful about how we...","width":609.1818182468414},{"text":"process our signals","width":82.18181824684143},{"text":"so let's.. I'll show you what I mean","width":216.18181824684143},{"text":"so what we're looking at today is... using SIGWAIT","width":566.1818182468414},{"text":"and I'm going to put that inside a thread","width":250.18181824684143},{"text":"who's only job is to say okay tell me the next signal that's delivered","width":825.1818182468414},{"text":"we can tell it in this case the mask is which signals do I care about","width":283.18181824684143},{"text":"[silence]","width":1467.1818182468414},{"text":"so if I get a SIGINT, do some code, if I get SIGTERM do some code","width":335.18181824684143},{"text":"so for example, Java, if you sent it a SIGHUP will print out a whole load of debugging information about the garbage collector and other internals of the...","width":833.1818182468414},{"text":"stack traces and other internals of the JVM","width":143.18181824684143},{"text":"the apache webserver if you send it a SIGHUP signal will reread its configuration files","width":410.18181824684143},{"text":"so that you can make updates to the webserver without having to restart the process and deny people that are currently connected to it","width":549.1818182468414},{"text":"so this might be a way to do this, you could say oh look if I've got um...","width":348.18181824684143},{"text":"SIGHUP","width":107.18181824684143},{"text":"if I get this signal... then print something out or","width":307.18181824684143},{"text":"reread my configuration data","width":238.18181824684143},{"text":"today I'm just going to show you a demo with just a couple of these","width":264.18181824684143},{"text":"and we've got a little default case for our own purposes that calls fprintf","width":254.18181824684143},{"text":"which we wouldn't call normally inside the signal handler","width":233.18181824684143},{"text":"because it could be that the thread that we've stolen it from is already inside fprintf or inside malloc etc","width":454.18181824684143},{"text":"but by using our own explicit thread, we can do this, we can do it in a safe way","width":432.18181824684143},{"text":"right so let's have a look at a demo...","width":451.18181824684143},{"text":"yay okay great","width":528.1818182468414},{"text":"right so here's our plan","width":112.18181824684143},{"text":"we will set because we're a multithreaded process","width":415.18181824684143},{"text":"we will set our sigmask before creating other threads","width":300.18181824684143},{"text":"so that when we create a new thread, it inherits the same mask","width":291.18181824684143},{"text":"and our default mask today rather than just saying okay ignore everything","width":303.18181824684143},{"text":"what I'm going to do is addset and just put in two bits","width":245.18181824684143},{"text":"the bit for SIGINT and the bit for SIGTERM","width":190.18181824684143},{"text":"that means that if someone sends me a SIGINT of course there's no thread that is prepared to catch it","width":489.18181824684143},{"text":"both threads are blocking these signals","width":546.1818182468414},{"text":"and here's my application code","width":160.18181824684143},{"text":"sleep one, print dot and because I want to see the dots immediately I'm turning to my C library to immediately flush anything inside the C buffers","width":496.18181824684143},{"text":"so we can see the dots appear one a second","width":423.18181824684143},{"text":"and inside my thread, here we go, today I've got my...","width":400.18181824684143},{"text":"my important code that's going to present some debugging information","width":166.18181824684143},{"text":"what is that? oh it's just the name of the signal that was delivered","width":287.18181824684143},{"text":"okay so let's compile this","width":271.18181824684143},{"text":"right if I was going to compile it...","width":261.18181824684143},{"text":"like this, what will we see?","width":290.18181824684143},{"text":"it will complain right? undefined reference no one defined pthread_sigmask","width":299.18181824684143},{"text":"what we forgot to do is to tell gcc that we're trying to compile a multithreaded program so...","width":406.18181824684143},{"text":"here we go let's give it a pthread option good and now we've got ourselves a little demo","width":478.18181824684143},{"text":"and every second it's printing out dot and then flushing the buffer","width":240.18181824684143},{"text":"so if we now send it a signal...","width":342.18181824684143},{"text":"our single thread wakes up, returns from SIGWAIT and runs the code inside that case statement which just prints out SIGINT","width":437.18181824684143},{"text":"where did the control C come from? oh that's just the shell telling us that it sent a control C","width":353.18181824684143},{"text":"and so I can say ok stop stop stop stop stop and of course it never stops","width":486.18181824684143},{"text":"alright and but I can still call SIGQUIT and that will terminate the program","width":383.18181824684143},{"text":"and with that have a wonderful weekend and I'll publish a online version of these questions in subversion. thank you very much!","width":703.1818182468414},{"text":"thank you very much!","width":64.18181824684143}]