[{"text":"....","width":128},{"text":"....","width":128},{"text":"....","width":223},{"text":"And the destructors be used in template class, yes.","width":193},{"text":"How?","width":64},{"text":"The same way as it would be otherwise.","width":86},{"text":"This is not really any different.","width":160},{"text":"I've got a template class right?","width":217},{"text":"And I instantiate that template class with a particular type. I am just gonna fill in T for all Ts I written in any member functions including my destructors if I have T in that position","width":767},{"text":"And I have a class that is well defined for that particular type.","width":227},{"text":"So the destructor works exactly the same as it did before.","width":128},{"text":"It's just that you can imagine that a template class is just being more that allows the compiler to write a class, that have that name but also that type in it.","width":645},{"text":"So I'm gonna say scope pointers int the compiler's gonna make a scoped ptr int class.","width":263},{"text":"If I say scoped ptr double it's going to make a scoped ptr double class.","width":267},{"text":"If you can think if it is when I am filling in type, the compiler is actually making a whole new class for me.","width":282},{"text":"By using this template to fill in what the implementation of that is.","width":197},{"text":"This works exactly same as it worked before. There is no difference.","width":346},{"text":"So we can at least...","width":533},{"text":"...","width":116},{"text":"OK.","width":62},{"text":"So I want to quickly review the last thing I was talking about, because there is some thing here that I want to make sure that everybody kind of ...","width":947},{"text":"The question here is why do we not need to rewrite a move assignment operator for our class if we are using the copy and swap idiom.","width":600},{"text":"So remember, the copying and swap idiom for the assignment operator is the way you should probably always write your assignment operator in this class for several different reasons.","width":616},{"text":"Just swap it with the argument.","width":320},{"text":"So it was a copy because it took the argument by value, which whenever you pass by value, the system will invoke the copy constructor for you.","width":523},{"text":"So it took the argument by value, made a copy and we swapped our values with that temporary and the temporary goes out of scope, getting rid of our old resources, and we became the value that the temporary which was an independent copy of the argument.","width":930},{"text":"So the question here is why do we not have to also provide a move assignment operator.","width":491},{"text":"We provided a copy constructor which took a const reference.","width":251},{"text":"Provided a move constructor, which took a r value reference.","width":178},{"text":"So why are we not then, forced to like, have a copy assignment operator that takes a const reference?","width":438},{"text":"And a move assignment operator that takes a r value reference. Right?","width":220},{"text":"That seems reasonable right?","width":95},{"text":"If I have to do for the constructors, I may want to do that for the assignment operator. ","width":317},{"text":"Well I still want to have that move behavior happens, when I am assigning from something, that is a r value.","width":358},{"text":"So then I will just try to overload for it.","width":256},{"text":"And my argument here is that you don't have to, if, you are using copy and swap for your assignment operator.","width":471},{"text":"That's the key.","width":132},{"text":"If you are doing the old way, you are taking a const reference, then if you want to move behavior going, you are assigning from an r value or assigning from a temporary, you wouldn't need to overload.","width":860},{"text":"We have one that takes by value, so now the question is what happens.","width":435},{"text":"When I give that and assign from something that is an r value.","width":312},{"text":"What does it do.","width":100},{"text":"It would be bad, if we actually made a copy. I am doing move assignment, I want to say, take the stuff, move into the current object and throw away the stuff that the current object has.","width":648},{"text":"That's sort of the move assignment.","width":279},{"text":"Just like a move construction.","width":91},{"text":"It's the same kind of thing except for that it happens when the object already existed.","width":274},{"text":"You have this extra step of getting rid of the memory that that object already had.","width":245},{"text":"But, fundamentally it's sort of the same idea when we have a move constructor.","width":262},{"text":"We want to do something more efficient than a copy.","width":273},{"text":"So then, if we are doing, our assignment operator with copy and swap, we are taking our argument by value.","width":487},{"text":"Why is it?","width":143},{"text":"That we don't have to have a overload for r values.","width":186},{"text":"So why is the one we already wrote going to work.","width":303},{"text":"As you have to think about what the compiler is going to do if you take that argument by value.","width":651},{"text":"Up until yesterday, everytime we took something by value, I always said that the compiler will invoke the copy constructor for that argument for you.","width":682},{"text":"But go and look at up you will figure it out what it means to do copying if your class, if you define one that runs, it runs yours.","width":334},{"text":"It you didn't define one, it runs some default one. But the compiler will always be making a copy for us.","width":406},{"text":"I was lying.","width":143},{"text":"The compiler is actually looking for a constructor that happens to take an argument that is the thing you have given it.","width":507},{"text":"In 95% of the cases, that thing is another book reference, so it just the copy constructor.","width":454},{"text":"But","width":128},{"text":"now that we have a overload that takes a r value reference, we have that move constructor. ","width":256},{"text":"Remember, we wrote that at the very end of the class, and all it did is to move the stuff into our current object to left the argument empty.","width":462},{"text":"Now that we have that, the compiler can now choose, whether to make a copy, or to do a move, when you are taking an argument by value.","width":715},{"text":"Because the system is going to look for a constructor that takes a, whatever you have given it, to convert it into a value for book.","width":717},{"text":"So, most of the time, if you are just saying like, b = a, the same stuff we say last time is absolutely still true.","width":376},{"text":"A is gonna be the l value, b = a, so a is an l value, so makes it a copy and does copy and swap.","width":444},{"text":"The difference, is when what if a was an r value.","width":201},{"text":"What if a is a temporary value, what if a is something I said std::move on to make it an r value.","width":317},{"text":"To pretend this is temporary.","width":128},{"text":"I want you to actually move from this thing.","width":64},{"text":"What happens then, the argument to the constructor for the book class is an r value.","width":362},{"text":"So the system actually invokes the move constructor. ","width":142},{"text":"Then it moves the object into the temporary parameter for the copying and swap.","width":340},{"text":"And it swaps that.","width":128},{"text":"Leaving the argument empty.","width":128},{"text":"Or leaving the argument, the temporary having my values that goes away.","width":324},{"text":"That gets deleted.","width":128},{"text":"I have the thing that were in the original argument, and since that argument is move constructed, it will be empty at the end of it.","width":384},{"text":"I didn't have to write the single line of code.","width":239},{"text":"Beyond I have already done for the copy and swap.","width":148},{"text":"For that reason, this pattern is often called the unifying assignment operator.","width":391},{"text":"Because it works for the case for your argument is an l value works for the argument is an r value.","width":378},{"text":"It just works.","width":95},{"text":"By letting the system figure out which constructor to invoke, if it's an  lvalue, it does a copy. If it's an rvalue, it does a move.","width":582},{"text":" So in some senses, this copy and swap thing is...","width":224},{"text":"Well","width":64},{"text":"Copy and swap if it is an lvalue, or move and swap if it is a rvalue.","width":256},{"text":"That's another way of thinking.","width":64},{"text":"...","width":192},{"text":"So what's happening here, we got...","width":192},{"text":"...","width":128},{"text":"Let's say that I've got a class...","width":320},{"text":"I don't know...","width":64},{"text":"I am not gonna use this, because for space","width":192},{"text":"But let's say I've got a class A that's got some pointers in it, that is like it is a dynamic array","width":512},{"text":"That auto class B","width":192},{"text":"That's also one of those things that's also got a dynamic array.","width":448},{"text":"Maybe it's like bigger or something","width":192},{"text":"I'll say A is...","width":223},{"text":"Or let's say actually","width":64},{"text":"when I say ","width":192},{"text":"B is std::move(a)","width":667},{"text":"The question is what's gonna happen if we assume that the type that were talking about here did a copy and swap style of assignment operator.","width":514},{"text":"And has valid, well-defined copy constructors and move constructors.","width":384}]