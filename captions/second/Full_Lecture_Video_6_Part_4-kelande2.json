[{"text":"except, now i'm going to take my arguments by value","width":768},{"text":"instead of by reference","width":128},{"text":"this is the trick","width":192},{"text":"so i'm going to take a book rhs","width":256},{"text":"what in the world am I doing?","width":576},{"text":"let's think for a bit about what that does","width":448},{"text":"so, what will happen if I am saying a = b?","width":384},{"text":"invoke the assignment operator","width":320},{"text":"the argument is going to be b","width":192},{"text":"which is going to be taken by value","width":192},{"text":"what is going to happen? the copy constructor","width":128},{"text":"so, that is where my copy has been made","width":320},{"text":"is when i'm passing the argument to the function","width":256},{"text":"so the system is going to do my copying for me by using my copy constructor that I already wrote","width":384},{"text":"so if I take my argument by value, its going to use copy or move","width":704},{"text":"to make that value that i passed in","width":192},{"text":"and now if I reach the body of my function, I know it was able to allocate the memory","width":448},{"text":"I can continue to do whatever the assignment should do because I already have the memory allocated for it","width":384},{"text":"this is a trick to ensure that before you even get into your assignment operator the copy has been successfully made","width":640},{"text":"if it was not, your function is not even going to be called","width":320},{"text":"the exception will be thrown, the assignment isn't made, your code isn't even run","width":320},{"text":"because it couldn't even make arguments to start running your function","width":128},{"text":"and then we have the strong exception safety guarantee ","width":448},{"text":"you are allowed to overload operator= like this because the standard lets you","width":448},{"text":"because remember this isn't like the case of the copy constructor","width":448},{"text":"where I was redefining what copying meant","width":64},{"text":"this is fine because I have already defined what copying means","width":128},{"text":"it's fine that I'm not using a const reference","width":640},{"text":"copy constructor does require const reference","width":320},{"text":"this is going to make a copy of the rhs every time this is envoked","width":1024},{"text":"doesn't this make things slower?","width":64},{"text":"does this make an unnecessary copy?","width":64},{"text":"ideally, not","width":576},{"text":"we'd love for this to not make an extra copy","width":256},{"text":"so we need to be careful about how we are doing it","width":384},{"text":"our goal is to have after the assignment, the lhs being an independent copy of the rhs","width":384},{"text":"when we call this function since we took it by value our argument rhs is an independent copy of what the rhs was","width":576},{"text":"so we want the current object to be the argument","width":512},{"text":"if we can do that, we don't need to make any new memory","width":448},{"text":"we are just going to use the memory that was created for this temporary rhs","width":64},{"text":"use swap","width":320},{"text":"copy, then swap","width":192},{"text":"what happens if we do that?","width":192},{"text":"write operator=","width":960},{"text":"book& book::operator=(book rhs)","width":1152},{"text":"inside of here, i have made a copy of my argument, so I am going to say swap","width":256},{"text":"swap with rhs","width":896},{"text":"and return the current object","width":704},{"text":"of course i need to write what this does","width":384},{"text":"if you just imagine that we have a swap function that swaps whatever the current object is with its argument","width":768},{"text":"let's think about what this does","width":256},{"text":"operator= we make a copy of the rhs","width":512},{"text":"now rhs is not a reference to the rhs, it is an independent copy of the rhs","width":192},{"text":"it's a temporary. it's going to go away when this function returns. it's on the stack frame","width":384},{"text":"so it's not like we become rhs because rhs is going away","width":576},{"text":"we swap with rhs","width":128},{"text":"switch the pointers around so that now I am looking at the stuff that rhs had allocated and rhs is looking at the stuff that I had allocated","width":512},{"text":"I return *this","width":256},{"text":"so I return my current object which is now looking at stuff that I allocated for rhs","width":256},{"text":"which means that the stack frame for operator= is going away, so what will happen?","width":320},{"text":"am i going to leak memory?","width":448},{"text":"book, the rhs object that i have swapped my stuff with, i've put all of my memory that I had already allocated into a temporary","width":832},{"text":"whose lifetime is bound to the lifetime of this function","width":256},{"text":"so it's destructor will be invoked and it is pointing at my old stuff","width":320},{"text":"so my old stuff gets deleted for me because i wrote a destructor","width":384},{"text":"let's draw a picture","width":256},{"text":"let's simplify book to one array","width":256},{"text":"if I've got main, which has A, which is book object, which has a pointer inside of it to some array","width":1344},{"text":"of stuff","width":128},{"text":"now we've got B, which is some object, which has inside of it a pointer to another array of stuff","width":576},{"text":"and i'm saying A = B","width":320},{"text":"where A and B already exist, so I know this is an assignment call","width":384}]