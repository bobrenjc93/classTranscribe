[{"text":"(question is asked) Subroot is pointing at 9. But subroot is a reference to a pointer that points at 9. And the reference is actually to the left pointer inside of the 12.","width":1024},{"text":"So when I say subroot, I'm saying the same thing as 12's left.","width":320},{"text":"(question is asked)","width":768},{"text":"I don't mean the release function, I mean it calls delete on the pointer. So it frees the memory.","width":543},{"text":"Like the assignment operator is probably something like delete ptr. ptr equals other.ptr or something. The very first thing it does is delete the internal pointer and then take ownership of the other thing.","width":1024},{"text":"(question is asked)","width":265},{"text":"Is it possible to make a reference to a unique pointer in the function? What do you mean?","width":436},{"text":"I could make another reference variable to the same thing. ","width":448},{"text":"I'm not sure I understand the question.","width":448},{"text":"(inaudible)","width":192},{"text":"Maybe think on it for a bit, and then bring it to my DYB.","width":448},{"text":"It may be a long discussion.","width":182},{"text":"Which is fine, but I need to proceed with lecture. (question is asked) (inaudible)","width":1152},{"text":"I'll get there after we write what that does.","width":358},{"text":"That's a good question.","width":256},{"text":"We're only doing the no child remove right now.","width":256},{"text":"Any questions on no child remove?","width":256},{"text":"Now, let's write the code for that function then come back to his question.","width":448},{"text":"Let's do a one child remove now. So this would be like the case where if we're removing the 23, this is a node that's got one child. So, subroot is going to be a reference to the right pointer inside of the 17.","width":1664},{"text":"So it still points at the 23, but it's a reference at the right pointer inside of the node 17.","width":320},{"text":"I've been asked to remove this specific node.","width":256},{"text":"Remove node looked at it and said \"oh actually, this isn't a no child node. This isn't a two child node. So it must be a one child node. So now we're in our one child remove function.","width":832},{"text":"So let's write that.","width":256},{"text":"One child remove kind of has to figure out where the child is. We haven't given any information on whether the child exists to the left or to the right.","width":704},{"text":"So this if statement is determining that. So if subroot left, I know that my one child had to have been to the left.","width":616},{"text":"Else, I know that my one child had to have been to the right.","width":384},{"text":"It's one of the two cases. It can't be both because it wouldn't be a one child remove. It's either on the left or on the right. So if it's on the left, that is, I have a node that looks like this.","width":896},{"text":"There's some node here. This is subroot. This is the node I want to remove. This is on the left.","width":832},{"text":"What do I want to do here?","width":320},{"text":"(inaudible)","width":365},{"text":"What I want to do is change this thing. So what is that thing, what's the name for that? Subroot. So I want to say subroot equals - and now I want to assign it so that it points at this thing.","width":1375},{"text":"Where's the pointer that points to the node at the bottom? Subroot's left, right? So I'm gonna say...","width":640},{"text":"(inaudible)","width":256},{"text":"Subroot should be subroot's left. And I need a std::move because I've got a unique pointer here. This is gonna try and do a copy assignment, which doesn't exist.","width":704},{"text":"So I'm saying steal the pointer from here and move it up into that pointer over there.","width":640},{"text":"So that's gonna set that to look there and that pointer to be null.","width":320},{"text":"(inaudible)","width":832},{"text":"Alright, so the good question that was asked was \"when I'm doing this and saying subroot is std::move subroot's left, if we just said the first thing that happens inside the unique pointer's assignment statement is that it calls delete on the pointer that it owns, it just deleted subroot.","width":1408},{"text":"And we were using subroot's left as our pointer, so do we have a problem?","width":512},{"text":"This is a good question. The answer is no in this case.","width":567},{"text":"If you think about it, the reasoning is this. We're starting with this picture. Where subroot is the right pointer of the topmost node.","width":896},{"text":"When we say subroot is std::move subroot's left, we're invoking the assingment operator of a unique pointer.","width":704},{"text":"If we think of that as being implemeneted with copy and swap, it turns out it's not but it has the same semantics. So pretend for a moment that this is implemented with copy and swap. So it's like your scoped pointer.","width":768}]