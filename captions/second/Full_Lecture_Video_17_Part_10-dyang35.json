[{"text":"Alright","width":128},{"text":"So now we, we still wanna be able to say, ok, the running time, like","width":256},{"text":"Somebody, people are getting mad at this when we say","width":64},{"text":"oh yeah, how long does it take me to build a heap?","width":192},{"text":"2 to  the h plus 1 minus h minus 2","width":192},{"text":"They again, they don't know what h is, right?","width":192},{"text":"So it's our job to make sure that this is a formula in terms of n instead of h","width":256},{"text":"But we know what h is , h has to be logN","width":256},{"text":"Alright","width":64},{"text":"So this is the same thing as, you know,","width":128},{"text":"Hmm...","width":128},{"text":"So this is the same thing as 2 to the, ah...","width":256},{"text":"h+1, so this is 2 to the logN plus one","width":576},{"text":"minus logN minus 2","width":448},{"text":"Okay, so I could just say this is 2 times 2 to the logN minus logN minus 2","width":640},{"text":"which is just","width":128},{"text":"2N - LogN - 2","width":192},{"text":"which is O(N) now","width":320},{"text":"Right. The N is gonna dominate the log, so that the minus log is just not gonna matter","width":256},{"text":"when N is really really big","width":128},{"text":"because, like, the log is really tiny and N is gonna be really big","width":192},{"text":"so this huge thing minus something way down here","width":192},{"text":"is not gonna matter, right?","width":128},{"text":"So if we look at the amor-, if we look at the","width":256},{"text":"trend, the growth rate of these functions, it's linear","width":256},{"text":"looks like a straight line, okay","width":192},{"text":"This is better than NlogN, clearly, okay.","width":256},{"text":"So, that's why our build heap running time is linear","width":960},{"text":"Okay, I wanna do 10 and then I'm gonna leave 11","width":256},{"text":"for you to think about. And we probably won't conver it on tomorrow","width":384},{"text":"So, just think of that, think of that as your practice for the exam","width":320},{"text":"because I could ask questions like that","width":192},{"text":"Okay so let's look at this one real quick","width":128},{"text":"So, let's design an algorithm that sorts an array in-place by using a heap algorithm that we talked about","width":256},{"text":"and how does it compare to other sorting algorithms that we know","width":192},{"text":"So","width":128},{"text":"How do we sort using a heap?","width":192},{"text":"And we're gonna do it in-place, so that means we're not gonna create a new array and move things over to the new array","width":320},{"text":"We're gonna do it with the same array that is being used for our heap, okay.","width":384},{"text":"So, in order to even do anything with the heap, we have to first build a heap","width":320},{"text":"So we're gonna pre-process this to make a heap which is gonna take linear time","width":320},{"text":"Okay, so","width":64},{"text":"once we've got a heap, how can I sort it, in-place?","width":320},{"text":"so that is, to use the same storage the heap is currently using to sort that array","width":256},{"text":"What could I do?","width":192},{"text":"Yeah, in the back","width":192},{"text":"Sort each row","width":192},{"text":"Okay so, hmm...","width":320},{"text":"Yeah that's not gonna... I mean I could do that","width":192},{"text":"but it's not gonna be as fast as what I like","width":256},{"text":"Okay any other ideas?","width":1152},{"text":"Okay","width":64},{"text":"Hmm, I think you could do... the problem is swapping the subtree is not sufficient here","width":320},{"text":"'cos if you want to swap the left subtree with the right subtree you gonna move the whole","width":256},{"text":"all of the elements around in the array","width":192},{"text":"Yeah","width":448},{"text":"Okay we don't need to build a search tree here, okay","width":256},{"text":"So","width":192},{"text":"Let's say, for, like, look at this picture","width":64},{"text":"Let's say I wanna build","width":128},{"text":"I wanna sort this array in-place, so that the largest thing","width":256},{"text":"is at the front","width":384},{"text":"That is, I want the smallest thing to be at the back of the array","width":448},{"text":"I can remove the element","width":192},{"text":"but not actually delete it from the array","width":192},{"text":"Right, if I have this heap and I pop","width":192},{"text":"the 4 is gonna end up at the back of the array","width":128},{"text":"I'm gonna move up the 5 as the root and bubble stuff down or whatever, right?","width":320},{"text":"But the 4 is gonna end up at the back of the array, right?","width":192},{"text":"If I keep it there, and I just","width":192},{"text":"make my heap oblivious to the fact that there's an element there","width":256},{"text":"I can do another pop, which will move the 2nd to smallest element and put it at 2nd to last","width":320},{"text":"position of the array, move that index back and make my heap oblivous to the fact that there's two elements there","width":320},{"text":"Do it again, I move the 3rd to smallest thing to the back","width":128},{"text":"see how this will be working? Okay.","width":192},{"text":"If I have a max heap","width":128},{"text":"then I'll be moving the largest thing to the back and get it sorted in ascending order","width":256},{"text":"If I use a min heap, I'll be moving the smallest thing to the back and get it sorted in descending order","width":384},{"text":"Okay. So the idea here is to build","width":256},{"text":"a max heap","width":320},{"text":"and  repeatedly ","width":448},{"text":"call pop() without removing","width":1344},{"text":"without removing it from the array","width":64},{"text":"So remove it from what you are treating as part of your heap","width":192},{"text":"but don't actually get rid of the element","width":192},{"text":"So then when you're done, the part of the array that you're treating as your heap is nothing","width":256},{"text":"and then all the elements are gonna be in reverse order of their removal","width":320},{"text":"Okay, yeah","width":384},{"text":"Hmm, right, you wouldn't do a pop back, you would maintain your own size pointer and move it back","width":512},{"text":"Right, okay so the pre-processing time is building the max heap","width":256},{"text":"we know we can do that in linear time","width":128},{"text":"and then, how long is that soring process gonna take?","width":192},{"text":"which is, to repeatedly calling pop()","width":384},{"text":"How long will one of them take, where i is the current size of the heap?","width":320},{"text":"logi","width":128}]