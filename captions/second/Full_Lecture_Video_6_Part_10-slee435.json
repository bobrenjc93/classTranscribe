[{"text":"Yeah, make an empty guy.","width":177},{"text":"Right? So I'm gonna make myself be the empty object, and then swap myself with the argument","width":444},{"text":"And so then the argument is the empty guy, and I'm not the empty guy. I'm just taking all of his values","width":235},{"text":"And now the argument is the empty guy, and I'm the one that has all values in it.","width":256},{"text":"Right? So this is just gonna be something like, you know, lines should be null...","width":640},{"text":"lengths should be null.","width":768},{"text":"So set myself up to be empty, and then just use my helper function swap with my argument.","width":350},{"text":"So now the argument is empty, I'm the one that has the values. I've just taken everything from him, or her.","width":640},{"text":"Okay? And then the argument is empty, I'm the one that has the values, so I've just taken the arrays without doing a copy here. Okay?","width":704},{"text":"Without this, if my argument was a temporary, I'm going to do a deep copy which entails allocating all the memory and deep copying all the values over, right?","width":549},{"text":"For all the lines, for all the lengths, right? So bunch of memory allocations for that, when I could've just used the temporary's values directly rather than making a copy, right?","width":577},{"text":"So this is gonna be way faster than the copy constructor, but it can invoked if the argument is an R-value.","width":411},{"text":"Right? Cause otherwise I don't wanna do that. My copy constructor shouldn't just steal the values of the other guy, right?","width":349},{"text":"That doesn't make any sense, right?","width":96},{"text":"So we still need a copy constructor, but this is an overload for the case where we know that the argument is an R-value.","width":399},{"text":"Okay? I wanna quickly do this last one, just so we can actually finish the work sheet.","width":308},{"text":"This is subtle point, and a good point to end on, because we've talked about the copy-and-swap assignment operators today.","width":384},{"text":"So why do we not need to also provide a move assignment operator, if we're using copy-and-swap.","width":466},{"text":"And my sort of hint is to think about what constructors are invoked for this expression right here.","width":867},{"text":"What's happening here? Book. I'm making a book b. It's got a hundred chapters. I'm doing whatever to set the lines in that book.","width":384},{"text":"I've got book a. It's got 10 chapters. Then I say a is going to be std::move of b. okay?","width":448},{"text":"So b is going to be treated as an R-value, and then I'm going to invoke operator =.","width":512},{"text":"Yes. yes. So I can actually, so what this is saying is that I'm going to treat b as an R-value and then I'm gonna invoke the assignment operator.","width":704},{"text":"If we wrote it with copy-and-swap, the system is going to invoke a constructor for the value argument,","width":512},{"text":"taking whatever is on the right hand side.","width":192},{"text":"The right hand side has now been flagged as an R-value, so the system will invoke the move constructor instead of the copy constructor.","width":491},{"text":"Okay? Then my value just steals everything from b inside of that function. I swap with it, and I return myself.","width":544},{"text":"Right? I didn't make any redundant copies cause the copy now in the copy-and-swap was move.","width":384},{"text":"Right? So that copy-and-swap operator = is often called the unifying assignment operator for C++ 11 and up,","width":498},{"text":"because if you write that thing once, it works as you would expect for copying and for moving.","width":374},{"text":"Right? So if you have that there, it will do your copy assignment like you would expect; make a deep copy in right.","width":384},{"text":"Do that properly. Strongly exception safe.","width":211},{"text":"If you're calling it with a right hand side that's an R-value, it invoked the move constructor and then swapped, and that's also strongly exception safe. Right?","width":529},{"text":"And I didn't have to write a separate assignment operator for overloading the case where it was an R-value,","width":256},{"text":"because the system will automatically invoke the appropriate constructor for that value argument","width":320},{"text":"Okay, does that make sense? Right?","width":158},{"text":"Wherever the system is going to make a value, like if you're passing something in by value, or returning something by value, right?","width":531},{"text":"The system is gonna look for a constructor that just takes whatever that argument is.","width":244},{"text":"And if that argument happens to be an L-value it makes a copy, because that's the right behavior for that.","width":327},{"text":"If that argument happens to be an R-value, like a temporary or whatever, it will do the move constructor.","width":315},{"text":"So now it avoids making copies where they're not needed.","width":226},{"text":"Right? So it turns out that if you do the assignment operator the way I've taught you,","width":346},{"text":"you only have to write it once. You don't have to write it twice.","width":197},{"text":"If you do it any other way, you have to write it twice. So don't. Okay?","width":313},{"text":"Lots of advantages. Okay. Let's end here.","width":5504}]