[{"text":"What about 77?","width":320},{"text":"the 77 right is going to be. So it can't be in the left subtree of the 50 now.","width":576},{"text":"right cuz its bigger.","width":64},{"text":"So it has to be somewhere in this subtree. ","width":256},{"text":"well its still bigger than the 72, so it better be in this subtree","width":384},{"text":"Right, then its still bigger than 76, so it better be over here. ","width":448},{"text":"that sort of feel familiar. ","width":512},{"text":"ok, this is working. This is basically a find, right?","width":315},{"text":"Now we are doing the samething as we would do in a find except that we have no intent of actually finding the element, we want to stick it somewhere instead. ","width":448},{"text":"so what if I want to insert a 51. ","width":281},{"text":"Again I sort of start at the root, 51 ... ok well it can't be in the left subtree of 50 so I am gonna go to this side. ","width":702},{"text":"It has to be in this subtree. 51 is smaller than 72, so it better be in this subtree. ","width":384},{"text":"and the 51 is smaller than 54, so it better be in this subtree so I am gonna put it there.","width":576},{"text":"Ok. This will make sense. ","width":211},{"text":"Right, so you kinda doing what you would do to locate that element if it existed.","width":384},{"text":"and then when you find that it doesn't, instead of throw the exception say Oh I couldn't find it, you put it there. ","width":320},{"text":"Yea","width":566},{"text":"This is the same problem as the height is bad. Right, you could imagine ... so the point was it doesn't look that the root will ever change. So if I pick a really bad number for the root. ","width":1094},{"text":"like 1 and then I insert everything bigger than 1, its all gonna be in the right subtree of 1","width":409},{"text":"and I have sort of increased my height for no real gain. I would rather pick something in the middle of the range and make that the root. we will get to that.","width":448},{"text":"So we will get to that in a bit and this is gonna be called height balancing. ","width":256},{"text":"For now we just gonna think about, how would you do these things if we ignore the height balancing stuff.","width":404},{"text":"So that you know how that works. And then I can throw the height balancing rench into the mix. ","width":256},{"text":"Because you have to understand what's happening first and then make it more complicated. I don't wanna start with a super complicated one, but we are definitely there.","width":391},{"text":"So, we are definitely going there. That is absolutely the way you should be thinking when you look at a new data structure like how can I break it? ","width":448},{"text":"So this is trivially breakable, but we will fix it in a bit. ","width":265},{"text":"Ok, so let actually write the code that does an insert. ","width":256},{"text":"Ok again we gonna have this sort of public-private duality going on. So we have a public function that then calls a recursive private function.","width":896},{"text":"This is kinda gonna be true, if pretty much all the operations we do on the trees have a public function that people call and then some private helper function that's actually doing the work. ","width":704},{"text":"So before I fill in the public part, lets about what that argument should be","width":640},{"text":"So before we had that being a const node* subroot and we didn't have to really care about unique ptrs or anything because we were just looking at the stuff. ","width":832},{"text":"Where we are doing the insert, that's now different. Right, we wanna change one of those pointers in the tree somehow.","width":512},{"text":"Right, when we get to that base case, we found an empty tree, we wanna change that pointer itself to point at a new node instead of just being an empty tree. right.","width":640},{"text":"If you think about what we did, when we inserted the 51 here.","width":512},{"text":"Right, we were really doing this recursing down parts of this subtree. ","width":384},{"text":"and when we get to this point when the left pointer of the 54 is null, we wanna change the left pointer of 54 to now point at a new node that we have allocated in the heap.","width":960},{"text":"Since you wanna change that pointer, I am gonna probably pass something here by reference. ","width":503},{"text":"Right, just like we did it in the reverse function, passed things by reference so that we can modify them. ","width":267},{"text":"So here I am gonna pass something by reference. What is the type of the thing that I am going to pass in by reference. So ignore the reference part. So what is the type that I am gonna pass down. ","width":640},{"text":"Is it going to be node*","width":246},{"text":"What is the type of the left and the right in our node struct? unique pointer. So if I wanna change one of those, what should the type be?","width":580},{"text":"Unique pointer so its gonna be unique pointer node reference ","width":424},{"text":"Non const, cuz we wanna modify it.","width":979},{"text":"Its unique pointer cuz that's the type of thing we wanna change and its by reference cuz we wanna change it. ","width":384},{"text":"Notice that since we are passing by reference here, we are not changing any ownership at all, we just have a reference to a unique pointer. ","width":512},{"text":"Its not like when we are passing it down, we are giving ownership to the recursive function. We are just passing by reference. No ownership changes here at all. ","width":576},{"text":"All I am doing is giving a different name to an already existing pointer. I am say ok, that pointer right there, call that subroot. ","width":384},{"text":"For the purposes of this stack frame call that pointer a subroot, and then in the next recursive call, call that pointer subroot. ","width":448},{"text":"But I am not actually moving ownership at all. I am not creating any new unique pointers, I am just looking at an existing one through a reference. ","width":512},{"text":"If I had passed down this by value, that would be a different story. If you are getting a unique pointer by value, there must be unique pointer being created. ","width":704},{"text":"As a local variable for your function for that parameter. So then you know that somebody is giving you ownership to something.","width":448},{"text":"so if you look at a function and its taking in a unique pointer, you can sort of look at the qualifiers of that type to understand that what the semantics mean.","width":512},{"text":"If its a unique pointer by value, somebody has given you ownership of something","width":256},{"text":"If I had a function here and it took unique pointer node by value, somebody gave me owner of  a subroot and probably want a new root of the subroot. ","width":576},{"text":"If however I pass by reference, no ownership changes have happened at all, they have just given me a way to change the pointer that they have just given me.","width":512},{"text":"Here is a handle on it, go ahead and modify it however you want. ","width":256},{"text":"But it has not changed ownership yet. Now we will change ownership, if we modify that pointer to point at something else for sure.","width":448},{"text":"But just the act of passing, it doesn't do any ownership changes. ","width":384}]