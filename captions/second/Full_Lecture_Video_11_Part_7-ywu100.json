[{"text":"What's different?","width":356},{"text":"And then what is the function returning? auto? what?","width":365},{"text":"This is a succinct way of hovering the type that I want to return.","width":322},{"text":"My alternative, I've left some space here so I can say what the alternative is.","width":284},{"text":"So if I didn't use this, this is a feature of C++11 called trailing return types.","width":369},{"text":"And this just says that, the list T iterator :: operator++ function returns an iterator reference.","width":576},{"text":"Okay?","width":50},{"text":"Now why would I do that? Well the problem is, if I want to actually say that the old way, this is what I have to write.","width":404},{"text":"Ignoring the template class T, assume it's already there.","width":2112},{"text":"That is what I'd have to write.","width":302},{"text":"Because of the rules of the language, I need a typename whenever I'm referring to a nested type of a template class.","width":519},{"text":"When the template argument is a template parameter. So here I'm going to say template class T, then this crap, and so T is a template parameter, so I need to say typename to say that list T iterator is actually a type.","width":832},{"text":"And furthermore, this is just, oh my gosh, this is obnoxious.","width":314},{"text":"That is a huge, long type.","width":240},{"text":"If I use a trailing return type, I can just say this, this arrow iterator reference, and the reason I can do that is that the scoping of these type sides is different. The scoping if I'm doing the forward return type, the normal return type, is the global scope, or the namespace scope that I'm currently in.","width":1280},{"text":"So if I want to say iterator, I need to say, okay, where does it live inside of the list T class, oh wait, but list T is a template class, and I need to say typename, this, okay, and then I have my fully qualified type.","width":813},{"text":"When it's trailing, it's as if you're inside the function. And once you're inside the function...","width":290},{"text":"This is a function defined on what? What class is this function defined on?","width":419},{"text":"List T iterator.","width":203},{"text":"And so when I'm inside of a class, I can just say that class's name, and that means the class.","width":301},{"text":"So that's why I can just say iterator ref here.","width":144},{"text":"I don't have to resay what the whole name of the class was, because I'm already scoped to the class.","width":489},{"text":"So there's a subtle difference. When I'm on the trailing part, I'm already scoped, when I'm on the normal part, I'm not, so if I do it this way, I can save myself some typing.","width":493},{"text":"You'll see this in the MP. This is just a different way of specifying your return type, so that I don't have to type that whole, huge horrible terrible-looking type.","width":640},{"text":"[Student asks question]","width":280},{"text":"No. Iterator is a nested class within list. Just like node is.","width":683},{"text":"No inheritance going on here at all.","width":384},{"text":"Okay.","width":111},{"text":"So, now I want to write some code to do these increment operators. ","width":320},{"text":"Given that we know that our state for this node is just this variable right there, this node* curr_.","width":593},{"text":"The first one returns a reference to an iterator, and I've told you that it returns the current iterator, so what should this, what should I write for the return statement for this one?","width":719},{"text":"return... close. Deference this.","width":794},{"text":"Okay? And then what's the other line of code? How do I move this iterator forward? Remember, this iterator conceptually represents a pointer to something inside of our list.","width":615},{"text":"Right? So when I deference and iterator to some node in my list, I'm going to get something of type T.","width":376},{"text":"So how I get this to go to the next element?","width":224},{"text":"This is what this ++ is going, it's saying move to the next element in the list. How do I do that?","width":404},{"text":"curr_... I need to move curr_. So what is curr_ being set to?","width":613},{"text":"Curr_->next.get().","width":700},{"text":"Curr_->next.get().","width":77},{"text":"Just our standard move to the next node in the list, right, when we were writing our print(), this is what we did to move to the next node, right, so in the iterator, it's just a class that represents the state of our iteration.","width":768},{"text":"So to move to the next thing, we're implementing what it means to move forward, which is to move to curr->next, right, if you look at this iterative print that I gave you, oops too far.","width":695},{"text":"This is our increment step of the for loop, so that's what the increment body of our function is going to look like for the iterator.","width":467},{"text":"So that's why we have this code.","width":384},{"text":"Okay.","width":128},{"text":"Finally, let's do operator ++ int. What is that one again?","width":618},{"text":"it++, so this is postfix increment. And so I need to return a copy of the current one, and then move myself forward.","width":675},{"text":"so the easiest way I know of doing this is to directly make a copy...","width":384},{"text":"so let's make, let's directly make a copy, so...","width":341},{"text":"Iterator ret, for return, is what? How am I going to initialize that?","width":654},{"text":"I'm going to make a copy of the current iterator. How would I do that?","width":220},{"text":"How would I invoke the copy constructor? What is my argument?","width":157},{"text":"*this.","width":304},{"text":"So I've invoked the copy constructor, ret is now an independent copy of the current iterator. How do I move forward?","width":667},{"text":"Right, I can move curr_, how could I call the function that I just wrote?","width":495},{"text":"Not on ret, but on...","width":279},{"text":"I could do it that way, that's perfectly valid, that's not incorrect. I could write this same line of code, right here.","width":427},{"text":"Instead, I'm going to pretend that I don't want to do that, and I want to invoke this function instead. How could I do that?","width":640},{"text":"++ *this.","width":448}]