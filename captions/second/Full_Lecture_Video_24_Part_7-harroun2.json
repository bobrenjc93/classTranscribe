[{"text":"Tricky thing about averages. You can have outliers and have your average still be nice. So I'm not really making any claims about the worst case. Someone could break things. On average what is the running time. GO take algorithms.","width":2047.6666666269302},{"text":"What about remove. Remove is same story. Hard part is locating element. Worst case is traversing list. Made argument about average length of list. Removal constant time. I lied. This is amortized as well. Might have to resize array.","width":1983.6666666269302},{"text":"We've not got hash table which has given us amortized constant time for all dictionary functions.","width":895.6666666269302},{"text":"Significantly faster. Problem is it's average. No guarantees. Worst case is crap. If you can't do anything about making find or remove any faster there's not really any need to resize table. If you are resizing would have to be amortized. Really need good hash function. ","width":3135.6666666269302},{"text":"There are other resizing strategies you could investigate. Need to be able to find the things before you did resize. If you tried to preserve table, it was starting to get bad. Lengths of the lists will go down with resize. Want that. THere are tricks you can do to avoid doing it. Still going to be constant anyway.","width":4159.66666662693},{"text":"THere's an implicit time space trade off. Typically we set load factor something smaller than one which means empty cells. Lot of blank lists in table. More space faster run times. Gets a little bit fuzzy. Think a little bit about what's the overhead that you store to implement the data structure. YOu have to store every key value pair, you have to have. How much more space are you using? For trees you've got pointers and height. For this you have linked list nodes. Think about overhead.","width":4671.66666662693},{"text":"I really want to cover next strategy for lab.","width":447.66666662693024},{"text":"This falls into the category of open addressing or close hashing. Now we're saying no buckets not allowed. Only every be one thing in slot of array.","width":1279.6666666269302},{"text":"Now what do we do.","width":191.66666662693024},{"text":"We've going to have an array. Not going to say what this part is for yet. This is where were going to put stuff. We just have the array now. We're going to do the same sort of inserts as before so 16 mod 7 put that. 0 1 2 3 4 5 6. 16 mod 7 goes where? The 2. 8 mod 7 goes 1. 4 mod 7 goes in 4.","width":4543.66666662693},{"text":"13 mod 7 goes in 6. 29 mod 7 put here. Oh wait. How do we put it there? THere's something there. Boot it? overwrite it? no we've lost data. So are we going to do?","width":1791.6666666269302},{"text":"What were gonna do here is were going to notice that we've got we still have space in our array. Our array isn't full. There's still somewhere we can put this. Place it somewhere where we know how to get back to it later. The simplest strategy here is called probing. You're going to look in the table for some other spot so probe forward in the table. Linear probing look at the next spot and insert it there. ","width":2800.6666666269302},{"text":"When we're inserting 29 that hashed here which is currently occupied.","width":255.66666662693024}]