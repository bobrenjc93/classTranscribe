[{"text":"Yeah if you've got like a big class, normally what you want here is to return it by reference to avoid the copy","width":512},{"text":"Like, you'll see for like width or something I just return an integer rather that a const reference to the integer","width":384},{"text":"Question?  Yeah.","width":704},{"text":"Okay, this is a good point.  So he's saying, \"I remember when you first brought up references, that you said that once you have a reference to something, you can't change what it is referring to\"  Okay?","width":1216},{"text":"So then isn't the const redundant for a reference?  Right?  If I can't change what it's referring to... then...","width":384},{"text":"The difference here is the same difference that we had for a const pointer or a pointer to const.  Okay?  So when I say a reference, and I say I can't change what the reference is referring to, I mean that that reference will always be referring to a particular piece of memory.","width":1088},{"text":"However, I can change the value at that memory location.  Okay?  So I can't say okay, if I make a reference and I make a reference to you, I can't then say the reference is going to look over here.","width":768},{"text":"Right?  I can however, ya know, change, I can assign a grade though the reference or something.  I can modify the thing that's at the end of the reference, but I can't change what the reference is looking at.","width":832},{"text":"Right?","width":64},{"text":"So in some sense, it's kind of like a const pointer.  Right?  Where if it's pointing at something, I can't make it point at something else, because the pointer itself is const.  In that sense, that's kind of how references are.","width":832},{"text":"However if I don't put the const on a reference that means that through that reference, I can modify the thing that's at the end, the thing that it's referring to.  That memory location I can modify.  The value there. ","width":704},{"text":"I just can't make it look at a different memory location.  Okay?  So const reference, then means that, okay not only is when the reference created, it's always going to look at this same piece of memory, but I'm treating the piece of memory that it's looking at as if it were immutable.","width":896},{"text":"So now I can't make the reference look somewhere else, cause that's just not how references work, and I also can't change the thing at the end of the reference, because the thing at the end of the reference has been declared const","width":704},{"text":"Okay?  So that's the difference, it's kind of the same difference that we had between a const pointer and a pointer to const","width":384},{"text":"","width":448},{"text":"Good question.  So we've got two different operators here, right?  They kind of take the same arguments, they've got the same name.  How in the world does the compiler figure out which one to call?","width":512},{"text":"It's gonna depend on the constness of the class in this particular case.  So in general, if you've got like a function that's got the same name, right?","width":576},{"text":"And you're just calling that function with some arguments, the first thing it'll do is trying to make sure that all the arguments match up","width":384},{"text":"Okay?  So if you've got a function like, ya know I don't know.  Obviously, plus exists, but let's use that for a working example.","width":576},{"text":"So let's say I've got a plus, and I've got one that takes an integer and an integer, and I've got one that takes a double and a double.  Right?","width":448},{"text":"So the first thing it's gonna try and do is find the one that matches the arguments.  So if I call it with an integer and an integer, it'll call the first one because those parameters match better.  If I call it with a double and a double, it'll call the second one because those parameters match better.","width":832},{"text":"If I call it with a integer and a double, then things get a little confusing because one of those doesn't quite match perfectly, right?","width":704},{"text":"I'd have to have a compiler on me to know exactly what happens in that case, I think...  it may call the double double, it may call the int int, I don't actually remember.","width":704},{"text":"For this case, when we are talking about a (I need to plug this in so it stops doing that).  So in this case when we're talking about calling a member function that's const, versus calling a member function that's not const, which one does it pick?","width":960},{"text":"It depends on what the object on which it's being called is.  If I just have a book B, and it's a nonconst book, it's just a book sitting on the stack frame for something.  And I say B parenthesis, it's gonna call the nonconst version","width":896},{"text":"Because the argument that it has been called on is nonconst, so the nonconst version works just fine so it'll call that one/","width":384},{"text":"If however, the book that I've got is const, so that it's a const reference to a book inside of a function somewhere.","width":576},{"text":"In that case, it's going to call the const version, because now the nonconst version doesn't apply.  It would make this pointer a pointer to nonconst, but I've got a const object so it just doesn't work.  So it has to invoke the const version in that case.","width":1088},{"text":"So it's gonna depend on kind of what the type of the left hand side of the call is.","width":384},{"text":"","width":576},{"text":"","width":192},{"text":"We'll touch on that.  We'll write one today, and then we'll kind of see how it's implemented, and we can talk about why do we even have these, because there's a very good reason for them.","width":768},{"text":"Alright.  So member functions, we're done with that.  So, alright.  So let's wrap up operator equals.","width":448},{"text":"So we ended up last time, writing an operator equals that was similar to the one we wrote in prelecture.  Right?  And it looks like this.  Right?  Why do I have this not equal to right hand side?  First of all, what does that do and why?  ","width":1024},{"text":"Right.  So it's checking for self assignment.  Right?  And the why is if I do have the case where A equals A, like a self assignment.  And I clear myself, I can't copy myself, cause I just cleared myself.","width":1280},{"text":"So it would make A equal A, no longer well formed C++.  Right?  It would do something bizarre.  It would be a runtime error, right?","width":512},{"text":"Where the standard defines, that that should be valid.  You should be able to say A equals A, and it should just not do anything.  Right?","width":320},{"text":"So that check is checking for self assignment.  I check for self assignment by looking at the memory location.  So I'm making sure that these are not the same object, by saying do they live in different places.  If they live in different places, they are not the same.  If they live in the same place, then they are the same.  And I don't need to do anything thing, cause they are the same.","width":1152},{"text":"This is NOT a value comparison.  So I'm not going to go through and look, and see like, do these books have the same lines and everything else.  I'm just looking at their memory locations, which is sufficient for a self assignment check.  It's also way faster.  ","width":768},{"text":"Yes","width":448}]