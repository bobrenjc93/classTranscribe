[{"text":"Then OK, the next node I should be at is the M, which is right here conveniently at the front of the queue.","width":576},{"text":"So I do whatever I need to do on the M, and I push the left and push the right, which are either NULL or I don't push left and right if they're NULL or whatever.","width":640},{"text":"I'm going to end up pushing left and right because reasons.","width":128},{"text":"And then I know the next node I need to go to is C, so now I'm kinda jumping around this tree all over the place, because I'm using this ordering structure to keep track of the order in which things should go next.","width":896},{"text":"So let's actually write the code for this","width":320},{"text":"So, we know we're going to be using the queue.","width":320},{"text":"And, what I need to put on there isn't actually like when I was drawing that picture of being a little bit fuzzy.","width":1024},{"text":"I was putting the elements on the queue, but really I need access to the nodes, cause I need to be able to add their left and right children to this ordering structure.","width":320},{"text":"So my orderings structure is actually going to contain pointers to the nodes.","width":256},{"text":"So I can dereference the pointer to get its left and right so I know where it is.","width":320},{"text":"So this orderings structure is going to contain node stars.","width":128},{"text":"Should they be const node stars?","width":192},{"text":"Or just node stars?","width":128},{"text":"Const node stars.","width":320},{"text":"Function is const, so I should promise I'm not modifying the nodes, so this is going to be a const node star.","width":704},{"text":"So my ordering structure is going to be a queue of const node stars.","width":448},{"text":"What's the very first thing I should add?","width":192},{"text":"The root.","width":64},{"text":"So, os.push(root.get())","width":448},{"text":"So now I'm going to start at the root, so the root is the first thing on my queue.","width":128},{"text":"When do I stop?","width":320},{"text":"So in other words, what should be in this while condition?","width":192},{"text":"How long do I continue printing?","width":128},{"text":"Or, invoking the function?","width":128},{"text":"So, if the left of the current node and the right of the current node are both null?","width":576},{"text":"So, that'll happen here.","width":384},{"text":"But I'm not done printing, right?","width":256},{"text":"So when I'm out of nodes on the queue, when I've exhausted the queue, when theres nothing left on the queue, I can be done.","width":320},{"text":"So, this works out if my tree was an empty tree, I'd just push a nullptr, and then we'll find out we do nothing on nullptrs.","width":512},{"text":"If it's a tree with one node, I put on just a pointer to the root, and it adds a couple nullptrs, pops off the nullptrs, and we're done.","width":448},{"text":"So, We're actually going to continue until the queue is empty.","width":192},{"text":"So I'm going to say while not os.empty.","width":512},{"text":"So, while there is something in the queue, I'm going to get a pointer to the current node, so auto curr should be what?","width":640},{"text":"I'm going to call os.peak().","width":832},{"text":"I'm going to use the standard queue we were using in the lab","width":64},{"text":"So I have to peak to get the thing that's at the front of the queue, and then I also need to remove it, so I'm also going to have os.pop().","width":640},{"text":"Curr is now going to point at the curr at node that used to be at the front of the queue and I've now removed that node from the front of the queue.","width":576},{"text":"So, now what I need to do, what's this doing?","width":448},{"text":"Yea, so this is my nullptr check, so this is going to be you know, if not curr, that is if curr is null, continue.","width":1088},{"text":"What does continue do?","width":64},{"text":"That's a new keyword we haven't seen yet.","width":192},{"text":"Yea, it skips this iteration of the loop.","width":192},{"text":"So it says its not a return cause a return would pull me out of the whole function.","width":384},{"text":"It's just skip to the next iteration of the loop.","width":192},{"text":"So that means that everything below this will not happen for this iteration, I just go back to the top.","width":448},{"text":"I could've put the rest of the loop inside an if statement and it would be the same kind of thing.","width":384},{"text":"I just like to think of this way cause it's kind of like a base case.","width":192},{"text":"It looks the same as our base cases did, so its simpler for me think about.","width":256},{"text":"You could do it any way you want.","width":128},{"text":"So then, we run the function on the current node's data, and then we do what?","width":512},{"text":"Push left and push right.","width":192},{"text":"So, we're going to push.","width":448},{"text":"Add the left child, and we're going to add the right child.","width":768},{"text":"Eventually when we're hitting this very last level of this tree, our queue is going to contain a whole bunch of nullptrs.","width":1088},{"text":"And so we're going to pop off the null, pop off then null, pop off the null, and we eventually empty the queue and we're going to stop.","width":576},{"text":"What's the running time of this traversal? In terms of n the number of nodes in the tree?","width":704},{"text":"So, I hear O(n).","width":320},{"text":"I agree, you have to be a little careful that you're correct here.","width":448},{"text":"So, what does this rely on?","width":192},{"text":"Saying this is O(N).","width":128},{"text":"It depends sort of on two things.","width":512},{"text":"It depends on one, the number of things that ever end up in the queue, cause we know this loop runs once for everything that we ever put in.","width":512},{"text":"So there's this question of how many pointers do we ever place into the queue?","width":256},{"text":"Well, we know that ever node ends up on the node for sure.","width":256},{"text":"But then we have all those nullptrs.","width":64},{"text":"How many nullptrs are there in a binary tree?","width":256},{"text":"N+1, we proved that before.","width":192},{"text":"So we still have a linear number of things that are being put on this queue.","width":128},{"text":"Thats OK.","width":64},{"text":"So we know that the number of iterations of the loop body is something like O(N).","width":448},{"text":"Then, what do we need to guarantee?","width":64},{"text":"If we know our loop is running O(N) times, what better be true of the body of that loop?","width":384},{"text":"It has to be constant time.","width":64},{"text":"If it's not, then I'd have something like N squared.","width":128},{"text":"Cause its going to multiply in.","width":64},{"text":"So have to be able to guarantee that the body of this loop is constant time.","width":384},{"text":"So, ignoring the function call, let's say the function call is constant time.","width":448}]