[{"text":"Okay, any thoughts on this?","width":1636},{"text":"So how might you do this? ","width":128},{"text":"So I've given you an array of size n and a constant k significantly smaller than n, and I want you to find me the top ten elements in time faster than nlog(n).","width":768},{"text":"Yeah.","width":64},{"text":"No. ","width":264},{"text":"The smallest things could be at the back, the largest things could be at the back if you only sort the first k.","width":326},{"text":"You don't find it. ","width":128},{"text":"Yeah. ","width":128},{"text":"Okay, yes.","width":420},{"text":"So he was like, okay well we just saw heap-sort, we know we could build the array, build the heap in linear time.","width":590},{"text":"And then when we were removing things, we were getting kind of the first elements....","width":405},{"text":"Right, in order at the back.","width":118},{"text":"So if you did something like that, but you just stop before you're completely done.","width":280},{"text":"Right, you stop after you've popped ten times.","width":258},{"text":"So, I like this idea.","width":169},{"text":"Â ","width":2},{"text":"So let's see what the running time of this would be.","width":133},{"text":"So, choice one is like heapsort but stopping early.","width":1208},{"text":"So, how long does our preprocessing take?","width":192},{"text":"Well we've got an array of size n, we need to build a heap of the appropriate kind.","width":277},{"text":"What kind of heap would we build?","width":225},{"text":"What is our definition of priority in this case?","width":336},{"text":"Yeah it would have to be a max-heap because we want the top k things.","width":283},{"text":"So we know that if we're stopping early we're only going to get the ten highest priority elements at the back of our array for doing a partial heapsort.","width":810},{"text":"And if we want the largest k we definitely have to build a max-heap.","width":223},{"text":"So we're going to build a max-heap, that's going to take us linear time. ","width":371},{"text":"Then how long does it take us to get the next element off this thing?","width":448},{"text":"In terms of k?","width":187},{"text":"And then?","width":150},{"text":"Well the heap has size n, so pop on that heap should take log(n). ","width":674},{"text":"And yes, technically it's log(n) and then log(n) minus one, log(n) minus two. ","width":308},{"text":"But if k is significantly smaller than n, that's not going to matter. ","width":228},{"text":"If k is a constant n minus k is just a constant so it's still log(n).","width":376},{"text":"So now we can actually use the argument that I've been telling not to be using for this particular case.","width":347},{"text":"Because k is a constant, it's not doing the whole array, it's doing up a fixed constant amount, so it's basically log(n) for every one of them. ","width":604},{"text":"So what is the running time of this? ","width":330},{"text":"Well it's O of n plus n. ","width":318},{"text":"So how many times were we removing an element?","width":235},{"text":"K times. ","width":76},{"text":"So, here's our building the heap step.","width":320},{"text":"We're removing k elements.","width":115},{"text":"How long does it take to remove one of those k elements?","width":180},{"text":"Log(n). ","width":279},{"text":"Is that better than nlog(n)?","width":192},{"text":"Yeah, if k is significantly smaller than n, klog(n) is certainly smaller than nlog(n).","width":407},{"text":"And then n is smaller than nlog(n).","width":222},{"text":"Linear is significantly better than nlog(n).","width":201},{"text":"So, this is faster than nlog(n).","width":94},{"text":"Yes?","width":765},{"text":"Doesn't really matter.","width":69},{"text":"I just want you to be able to tell me what the top ten elements are.","width":169},{"text":"So do something with this array.","width":119},{"text":"You can mess it up, that's fine. ","width":115},{"text":"And just return to me the top ten elements. ","width":113},{"text":"So maybe you can make a new vector and you push the top k onto it in order and then give that back to me or something.","width":384},{"text":"Not really saying at all how the heap itself is being modified here.","width":239},{"text":"Just that it is possible for you to give me the top ten.","width":308},{"text":"In this amount of time. ","width":153},{"text":"If you didn't want to modify the array, you could copy it first in n time, build the heap on your copy and then modify that copy instead.","width":538},{"text":"Wouldn't be in place anymore but that's fine. ","width":111},{"text":"I didn't specify it had to be in place. ","width":323},{"text":"So here's the first algorithm. ","width":99},{"text":"So this is better than nlog(n). ","width":158},{"text":"There's a different choice you can make. ","width":128},{"text":"Did anybody think of a significantly different way of doing this?","width":527},{"text":"This way is actually my favorite.","width":58},{"text":"Yeah.","width":874},{"text":"You're building a k area heap?","width":231},{"text":"Okay, using a binary heap. ","width":211},{"text":"You could probably do that but using a binary heap.","width":124},{"text":"Does anybody have any other ideas?","width":118},{"text":"Yeah?","width":413},{"text":"It doesn't have to be.","width":230},{"text":"For the first algorithm yes. ","width":114},{"text":"Yes.","width":64},{"text":"Aha!","width":140},{"text":"Yes!","width":64},{"text":"So, the observation is first algorithm is using a heap of size n.","width":384},{"text":"We make a heap out of all the elements.","width":192},{"text":"What if we just maintain a heap of size k?","width":448},{"text":"The contents of our heap are always going to be the top ten elements that we've seen so far.","width":601},{"text":"That's the trick here. ","width":107},{"text":"So this is going to be to maintain a heap of size k, containing highest elements thus far. ","width":1691},{"text":"Highest k elements. ","width":320}]