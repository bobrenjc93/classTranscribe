[{"text":"Is this public function recursive why or why not? ","width":1152},{"text":"Yea. Some has to be recursive here, that's certainly true, because you have to do some kind of modified traversal to find the element, so something here would be recursive, so the question is, is the public function recursive?","width":1088},{"text":"It can't be and its not because its const. I don't know what node I am at? ","width":576},{"text":"I have no way of keeping track of where I am. That function can't be the recursive one.","width":192},{"text":"I have no notion of what the current node is. ","width":128},{"text":"If this at function was recursive, how do I stop, the only thing its take is a K ref. ","width":640},{"text":"So if I am passing the same key the whole time, its just gonna recurse forever. Right, how do I call that --- at (key). O that's the function I am already in.","width":494},{"text":"There is no way for this to terminate. So the at function here as written can not be recursive. ","width":576},{"text":"What we are go to do is what we were doing for the list classes as well when we were writing these recursive functions. We gonna write a recursive helper function. So the helper function is gonaa be what is gonna be reucrisve here, but the at function itself will not be. ","width":896},{"text":"There is no way for me to check for the base case, because I don't know what node I am at. The only node I have access to here is root and that's never going to change.","width":640},{"text":".the at function can't be recursive here, so I am gonna call a private helper function to implement the recursion/","width":704},{"text":"Why do I know that its private?","width":64},{"text":"I am gonaa be dealing with nodes. One of parameters is probably going to be a node*. Right! at which point its certainly cant be public anymore, because nobody outside this class knows about node*s","width":1188},{"text":"The dictionary could be anything. It does not have to have nodes in it. Nobody knows what a node is. So they cant call functions that take nodes, so this helper function is definitely gonna be private. Ok.","width":640},{"text":"the call probably look something like this. I am gonna call the helper function find. I could have called it at, it doesn't change anything. I am just gonna call it find to be clear which one's the public, which one's the private.","width":640},{"text":"I am gonna call it find. I am gonna start at the root.","width":256},{"text":"and I am looking for that particular key. ok.","width":832},{"text":"so this find function is going to be my helper function and its going to return to me the value that it finds for the value for the key if it exists and if it doesn't, it should throw an exception.","width":832},{"text":"Ok. lets implement this. whats the signature gonna look like? whats the first thing I am gonna write here template.","width":960},{"text":"template <class K, class V>  ok fine, so now onto the actual signature part of it. So what is this function returning?","width":1024},{"text":"Some kind of value, right. So based on the signature we have got here, it should probably be a const V&.","width":640},{"text":"ok. alright next, bst good so I have to scope it.","width":1024},{"text":"bst<K, V> find. whats my first argument gonna be? some kind of node*. It looks like this particular find function doesn't modify the tree so it should probably be a const node* so that I promise that I don't change the nodes themselves, I just look at them. So I am gonna take a const node*  subroot, Ok. so what's my other argument?","width":2240},{"text":"Key so const& k","width":512},{"text":"Â Am I done writing the signature? No, I need to mark this const. Why do I need to mark this const?","width":832},{"text":"Ok, that's true. Why do I need to tell the compiler this function won't modify the tree?","width":1024},{"text":"Because I am calling it from a const function. Ok. Here I am calling find inside a function thats mark const. So if the helper function is not marked const, I am not allowed to call it","width":741},{"text":"right cuz, I promised inside that at function that I won't modify the tree, so if I call a function that's marked const. I have squeezed my way out of that contract, which is not allowed.","width":717},{"text":"So the compiler will enforse that if you are in a const function, you can only call other const functions.","width":448},{"text":"so my find function better be const because my at function is const.","width":320},{"text":"So thats my signature. So in what case do I throw the exception.","width":833},{"text":"Not subroot, so if I can't find it, i know what's gonna happen here is that I am gonna recurse recuse recurse recurse","width":448},{"text":"and eventually I am gonna have an empty tree. If i have an empty tree I can't find anything in the empty tree so there is no possible way I can return to you a valid const V& cuz there is nothing, so I should throw the exception.","width":896},{"text":"so in this case I am gonna throw the exception when not subroot.","width":320}]