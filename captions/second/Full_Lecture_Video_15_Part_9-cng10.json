[{"text":"","width":320},{"text":"definition of a binary tree. it has a root, a t left and a t right. t left and t right might be null, might be empty. it doesn't really matter","width":448},{"text":"if i have a node i know i have a tree has a root and subtrees","width":256},{"text":"","width":320},{"text":"for convenient, i'm going to say let's let the size of left tree be As, there are a elements in the left tree. and the size of the right tree is b","width":960},{"text":"","width":128},{"text":"given that, what is n?","width":320},{"text":"","width":64},{"text":"i tell you that there's a node in the left and b node on the right. how many nodes are there in this tree?","width":384},{"text":"a+b+1","width":128},{"text":"left,right, root","width":256},{"text":"again, by definition","width":128},{"text":"","width":512},{"text":"so this is just a fact we will know it for later","width":256},{"text":"","width":320},{"text":"we know then if n is a+b+1 and the size of left is a, and the size of the right is b","width":576},{"text":"what's true about t left and t right?","width":192},{"text":"in terms of n","width":64},{"text":"are they bigger or smaller than that?","width":128},{"text":"smaller","width":64},{"text":"right? 'cause +1 is n. so regardless of what you a and b to be, they have to be smaller than n, which means what?","width":448},{"text":"something happy","width":128},{"text":"yay. my inductive hypothesis works. so i'm gonna imply that","width":256},{"text":"with more space","width":192},{"text":"so i know than that the size of t left is less than n ,and the size of t right is less than n ","width":704},{"text":"so by the IH, we know that number of null pointers in t is the number of null pointers in t left + the number of null pointers in t right","width":2368},{"text":"'cause remember we keep the head as being one of those pointers. So even if I happen to have no children","width":512},{"text":"the left subtree is gonna count as an empty tree, we say has one null pointer. so it is gonna contribute that null pointer","width":384},{"text":"so our current tree if we have a node it doesn't contribute any null pointers, it just the trees that below it do","width":384},{"text":"","width":192},{"text":"then what is the number of null pointers in t left given the hypothesis?","width":320},{"text":"a+1","width":128},{"text":"what about t right? b+1","width":384},{"text":"","width":320},{"text":"and N + 1","width":256},{"text":"","width":576},{"text":"so the number of null pointers in a binary tree of n nodes is n+1 because we've proven that be the case by induction","width":576},{"text":"definitely it is true","width":256},{"text":"could you do this in ternary trees? left as an exercise to the student","width":448},{"text":"ok","width":128},{"text":"","width":256},{"text":"let's do this one together just cause we are certain to get close to time here","width":256},{"text":"we're gonna write a function, binary_tree<T> print()","width":320},{"text":"so this is a member function print() on a binary tree as it would appear in the .tcc file that prints the elements inside of the tree. write the recursive helper function as well. what the heck do i mean by that?","width":832},{"text":"recursive helper function. what is that?","width":192},{"text":"what's a recursive helper function?","width":256},{"text":"recursive function","width":128},{"text":"it's a helper function. so it's gonna be a recursive function that actually does the work","width":384},{"text":"why am i need that?","width":320},{"text":"i need to past in parameters, right. so what i am recursively printing, i need a way of keeping track of where i am","width":384},{"text":"if i don't pass any parameters, I have no idea where the heck I am","width":192},{"text":"i only be able to say root","width":192},{"text":"so my recursive helper function is going to take a parameter that tells it where it is ","width":320},{"text":"and so therefore i need 2 functions. I need one function that is the public function that just calls the helper on root","width":448},{"text":"and then the helper function actually does the printing recursively","width":256},{"text":"so then I have two functions here. so that's what the hint is about. so...","width":384},{"text":"","width":320},{"text":"T. void binary_tree","width":448},{"text":"","width":448},{"text":"what's wrong with this function's decoration? ","width":128},{"text":"","width":64},{"text":"const. yes. good!","width":256},{"text":"why should i say const here?","width":192},{"text":"","width":64},{"text":"right. printing a tree should never change it. so i should always say const when I can, and I can const in this case","width":448},{"text":"","width":128},{"text":"and then i'm going to call my helper function on the root","width":448},{"text":"","width":320},{"text":"I'm gonna say .get() because I don't want to transfer ownership to the helper function","width":256},{"text":"it just gonna hop around and observe, so it can be a raw pointer. so i'm gonna use a .get()","width":512},{"text":"","width":512},{"text":"so I'm gonna write a print helper function. you should raise me. so write your own print function. it's ok if it doesn't look like mine. there are several solutions here. we are gonna talk about what this means","width":704},{"text":"I'm just gonna write my own print(). so void...","width":640},{"text":"","width":2496}]