[{"text":"and remember, that makes our life much easier. when we can say, oh look! i've got multiple threads happening somewhere in my program, but in the stuff that's really complicated, when I'm changing data structures or reading data structures which might be changed, I just want one thread accessing this stuff","width":1027.1818182468414},{"text":"so that's what my lock is for","width":147.18181824684143},{"text":"alright, so here's my incredibly complicated data structure, it's called an array, here it is","width":259.18181824684143},{"text":"and I've got the count that counts the number of things inside my array","width":294.18181824684143},{"text":"and as they are global variables, we know they are going to be initialized to zero","width":453.18181824684143},{"text":"okay, so, here's what I can do to my data. I've got something to add something into my array, to push some data in, and I've got a method to delete something!","width":756.1818182468414},{"text":"which all it does it just reduce the count","width":183.18181824684143},{"text":"and hopefully we'll assume that no one tries to delete more items than there are","width":494.18181824684143},{"text":"ok, I'm also going to have a getLast() method","width":558.1818182468414},{"text":"so getLast() we could, if we're inside cs225, say, I'll tell you what, I'll just return a bad value if nothing is actually in there already","width":539.1818182468414},{"text":"but no, what we're going to do is make getLast() wait","width":225.18181824684143},{"text":"we're going to make sure that it doesn't continue until there really is at least one value inside our datastructure","width":804.1818182468414},{"text":"alright so, here's the game we're playing","width":258.18181824684143},{"text":"there's one thread that's going to be calling push data and delete and it might do it several times.","width":281.18181824684143},{"text":"I've got another thread that might call getLast() several time","width":550.1818182468414},{"text":"right, so we're going to develop this code slowly but here we go. so, here's the plan. any time we want to deal with condition variables, we're going to write something incredibly incredibly simple. just a busy wait. just a simple while loop that keeps testing something","width":1387.1818182468414},{"text":"right so, this is the code that I'm scared about. right. I'm going to try and get something inside my array but what would happen, for example, if the count is oops this should be count - 1","width":844.1818182468414},{"text":"here we go","width":155.18181824684143},{"text":"what would happen for example if count was zero?","width":179.18181824684143},{"text":"it means my array doesn't have anything in it","width":207.18181824684143},{"text":"so, I need to say the following \"look, while count is zero, don't carry on.\"","width":1009.1818182468414},{"text":"so while count is zero, just go around","width":442.18181824684143},{"text":"and, who cares about burning up my battery on my cellphone. alright. it's easy code to write","width":475.18181824684143},{"text":"this is the kind of code you might write if you didn't come to cs241","width":152.18181824684143},{"text":"you know just \"[something] count is zero, doesn't matter, just keep going around\"","width":166.18181824684143},{"text":"eventually, at some point, count will change and that's fine","width":195.18181824684143},{"text":"of course, that code might execute a billion times and used up several milliamps of current","width":477.18181824684143},{"text":"or milliamperes of power","width":167.18181824684143},{"text":"and um, but it's the best we can do, right. I'm going to show you how we can do better","width":363.18181824684143},{"text":"so how can we fix this code? well first of all, we can see there's a race condition, right, that I don't want these methods to run at the same time so I'm now going to put my locks in","width":725.1818182468414},{"text":"alright so, here's what I wanted to do. I'm going to call my pthread and pthread's a lot to write so I'm just going to write p","width":492.18181824684143},{"text":"pthread_mutex is a lot to write so I'm just going to write m","width":342.18181824684143},{"text":"lock","width":49.18181824684143},{"text":"and, pass in the address of my little lock structure and at the end, call unlock","width":637.1818182468414},{"text":"and, suddenly our code is easier to read. we don't need to worry about say, two threads calling pushdata at the same time even if the problem says that never happens","width":604.1818182468414},{"text":"my code now says \"because of that lock, only one thread can ever be inside that little piece of code\"","width":476.18181824684143},{"text":"and similarly, here, if I lock on the same lock","width":978.1818182468414},{"text":"I'm conpletely confident that even if you tried to call pushdata and delete at the same time from two different threads, the code would still work","width":456.18181824684143},{"text":"one thread would have to wait","width":84.18181824684143},{"text":"one thread wins the lock and can continue and change the value of count. the other thread has to wait until the mutex is unlocked and then it can lock the mutex and carry on","width":784.1818182468414},{"text":"alright so, the lock call may take a bit of time","width":320.18181824684143},{"text":"if someone else if currently in the bathroom, you're going to have to just twiddle your thumbs and wait until that lock has been unlocked","width":601.1818182468414},{"text":"we're good, okay, we're fine so far right? this is not complicated so far. this is easy stuff, yes?","width":345.18181824684143},{"text":"yes?","width":65.18181824684143},{"text":"I know it's a monday and the weekend was great but come on, this is not too bad","width":269.18181824684143},{"text":"alright so, now, haha, right, now let's see what we should do over here","width":382.18181824684143},{"text":"um, before checking this count, I should make sure that no one else is touching it alright?","width":513.1818182468414},{"text":"that no one else might be, say, changing its value halfway through","width":246.18181824684143},{"text":"so, um, before doing anything with these shared variables, let's put a lock call in at the beginning. there we go.","width":945.1818182468414},{"text":"we see how our code is becoming littered with these lock() and unlock() calls, yes?","width":527.1818182468414},{"text":"alright, so we write this code, what happens?","width":460.18181824684143},{"text":"if we tried to test it at this point?","width":448.18181824684143},{"text":"this is the, what, freddy mercury who wants to live forever code?","width":418.18181824684143},{"text":"alright so my. I'm fine if I'm just calling pushdata and delete","width":394.18181824684143},{"text":"things can bad though, the moment I call getLast()","width":264.18181824684143},{"text":"because, getLast() locked the mutex, so what would happen now, to any other code that calls pushdata and delete?","width":583.1818182468414},{"text":"they get stuck! yeah, they get stuck inside their lock call","width":181.18181824684143},{"text":"waiting for that lock to get unlocked","width":106.18181824684143},{"text":"which as we can see from the code is never going to happen. wahahaha. alright, so we've got a problem","width":650.1818182468414},{"text":"we can even imagine as well that this count, if this was zero, then we can get stuck inside this loop, and because we don't unlock it, pushdata will never happen","width":1080.1818182468414},{"text":"so, here's how we're going to fix our code now","width":396.18181824684143},{"text":"we're going to unlock the mutex, meditate, me-di-tate, with our condition variable","width":1098.1818182468414},{"text":"after we finish meditating, lock the mutex again","width":352.18181824684143}]