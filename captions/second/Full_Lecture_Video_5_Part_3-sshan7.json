[{"text":"There was a question about best fit.  Best fit will scan through, looking at all the possible holes.  Obviously we can ignore all the holes (or spaces) which are too small.","width":961},{"text":"And it will use the space which is at least as large as the request, but hopefully no larger.  And if it so happens that there's two spaces that satisfy that search, then we use the one lowest in memory.","width":1372},{"text":"So, question?","width":1072},{"text":"You would split it at the beginning. Right so, anytime you've got a space, you do the allocation at the beginning of the space.","width":1472},{"text":"*nothing happens here*","width":4224},{"text":"*again nothing, class discussion, Angrave filling out sheet*","width":6458},{"text":"Okay, so.  Let's have a look at this.  So first fit: I've gotten as far as filling out A, B, and C and now I've called free() on B, and now I need to allocate another 3 KB.  Where could we put it?","width":768},{"text":"Well, we've got space here and we've got space at the end.  And we're trying to do best fit.  So best fit is going to put it in here because it's a perfect fit.  If I put it starting at 3K, I would've had a space of one left over, so that's not quite as good.","width":1221},{"text":"And then we free A, and we allocate one KB.  Where could we put this?  Well, there's only one place.  There's one big giant space over here.","width":780},{"text":"So we'll put E there.","width":548},{"text":"What happens in worst fit?","width":542},{"text":"Nothing changes at the beginning here.  C, C, C.  Okay, so.  Now we free() B.","width":812},{"text":"And we allocate 3 KB.","width":160},{"text":"So: where's our choice?","width":68},{"text":"We could stick it here, or we could stick it at the end.  Which one is worst fit gonna use?","width":467},{"text":"B, yes!","width":42},{"text":"Because we have the largest space if we allocate it there.","width":245},{"text":"So let's put our D in here.","width":520},{"text":"And now we free() A.","width":304},{"text":"And we want to allocate one byte.  So what are our choices?  We've got a space of 3, space of 1, and space of 3.  Where's worst fit gonna put our final allocation?","width":747},{"text":"Yeah, it's a tie-up between the first few blocks here and the last few, so we'll put it just here.","width":313},{"text":"Okay, and first fit","width":93},{"text":"Okay, let's do this quick. ","width":829},{"text":"Right, so, we'll do the D.  3KB.  First fit is the Scrappy-Doo of fits.  As soon as we find enough space, we'll stop.  And we've just cleared out our space of four so yes, we can put D in here.","width":1258},{"text":"And now we'd free A, and finally we allocate 1 KB.  So we run along our spaces - oh, look!  Here's our free one.  And we'll stick E in here.","width":821},{"text":"I'm sorry, yes, you're right.  We'll stick it just there.","width":606},{"text":"Okay, so this was a pretty trivial exercise.  But what I wanted to show you is the mechanics of these programs, and that they also lead to spaces in different places.  Also, there's a little thing that we did quite easily but you'll have to remember to do in code, which is: look at this, we had A and B, and at some point we freed up two allocations next to each other.  And so we had to go from thinking that this is a space of two and a space of four into think that this is just one big space of 6.  And if we didn't do that, then if somebody asked for a malloc() of 6, then your algorithm would say, \"I'm sorry, I don't have space to allocate 6B because counting will keep this as a space of 2 and a space of 4.\"","width":3621},{"text":"We could coalesce those two free areas together into a single block, and so that is a common gotcha when implementing malloc().","width":610},{"text":"That you have to look at the space beforehand and the space afterwards to see if you can coalesce them.","width":448}]