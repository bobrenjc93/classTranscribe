[{"text":"um...so your...the answer is...the answer is a little complicated because it turns out when you say...when you say...when you got a template function, T ref ref A, that has different ","width":440},{"text":"rules, and so weird stuff  can happen. Cause...the observation is T could itself be a reference type. And when you have something like T ref, ref, ref, it has to collapse down to T ref.","width":1152},{"text":"So it's weird and you don't have to care about it.","width":896},{"text":"The answer is you could pass it as ref ref here because of the reference collapsing rules.","width":448},{"text":"But it's equivalent to pass in by reference here. Because the goal here is like we are not really saying like A and B are temporary values.","width":448},{"text":"we are saying A and B are gonna continue to live outside this function. So we are not trying to say that A and B are r-values. We are trying to say A and B are just values.","width":576},{"text":"and then we are using the move semantics to get something more efficient than doing a deep copy and doing the obvious copy assignments.","width":576},{"text":"There's no cloning or copy going on here at all. So A and B is going to refer to an existing T object somewhere else.","width":960},{"text":"A and B are gonna be l-values so the object needed to exist  before hand. ","width":512},{"text":"The move staff is just so that i can take the memory instead of the way this one works. Right?","width":576},{"text":" The move staff is just so that i can take the memory instead of the way this one works...right...is I got A and I got B, so I, you know, I clone A into something over here.","width":448},{"text":"so now I have two copies of A.","width":128},{"text":"Then I take B and I clone B into A, and I take that temporary value and cloned it into B. So I'm doing all these copies and I got sort of...","width":640},{"text":"duplicate copies of A floating around at one time and duplicate copies of B floating around at one time. So it's kind of wasteful.","width":384},{"text":"The second one is saying instead of doing like a deep copy of A  to hold over there so I can remember its value,","width":512},{"text":"just...I got a box here that got A stuff, and I got a box  two that gets B stuff in it.","width":448},{"text":"The old way was created a new box, fill it up with duplicate of all the things that were in A and put it over there.","width":384},{"text":"And  then take all of the things that were in B and duplicate them.","width":384},{"text":"Throw all of the stuff that was in A and put all those copies of B into A.","width":256},{"text":"Then do the same thing. Take that temporary that had clone all of the things inside of it and put those in B and throw out all of the stuff that used to be in B, and then destroy this extra box, which is sort of weird, that's not how'd you move stuff between box one and box two.","width":896},{"text":"The way it moves between box1 and box2 is, get a temporary box, take up the stuff that's in A, throw it to the temporary box, and A has nothing in it.","width":576},{"text":"Take out the stuff that were in B box, moved over to A, now B is empty. Take the stuff that's in the temporary box, put it in B, now the temporary is empry.","width":512},{"text":"So now there is no copying at all.","width":192},{"text":"That's the intuition to have here.","width":320},{"text":"So it's moving contents around.","width":128},{"text":"But there is no...like in this version, if a move constructor exists there is no copy needed at all.","width":640},{"text":"What does this look like...so let's say for simplicity, let's say I got T as being a class that got one member variable that is a pointer to a dynamic array of integers","width":1536},{"text":"So just an dynamic array as it like the raw type, not the thing that you write in your MP. ","width":448},{"text":"So like an actual heap allocated array of integers right.","width":192},{"text":"So I got, you know, maybe here, I got, you know, A, which is a class but inside that class I got a pointer to an array...roots 1,2,9,7,5","width":1088},{"text":"and b...and now I want to say swap A, B.","width":1664},{"text":"A and B are whatever type they are. So this instantiates the swap function with that particular type, which then compiles that code with T filled in, and now I have a swap function for that type and now I invoke it.","width":768},{"text":"So I'm going to get a new stack frame for the swap function. I have a A being in that name for that A down here.","width":1088},{"text":"This is just a reference, this is not actually a pointer, just a reference. So when I say A, I mean the A in main.","width":384},{"text":"not something else","width":128},{"text":"b it a reference to that b. So when I say b inside of swap it means b inside of main. I couldn't make this clear and call this ...you know, and say x and y and I'm going to swap x, y","width":1216},{"text":"Saying A in swap I mean x, when I say B in swap I mean y because of how reference is work.","width":1216},{"text":"so now...","width":128}]