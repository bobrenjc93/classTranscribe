[{"text":"I can ask the lists for their size, and that tell me the degree of their vertex. Alright, so when you ask: \"Hey is there an edge between u and v\" I know that the edge is kind of being stored twice here, and I can look and see what's degree of u, what's degree of v, and I can choose to walk down the list that's shorter. Okay. So the running time of this will be big-O of the minimum of degree of u and degree of v. Because I can pick which edge list I wanna walk. Pick the smaller one and walk that instead. The list is probably already keeping track of the size. You have to, otherwise you don't know yet. So if your'e using using a std::list that has a dot size that's constant time because it stores a number. If you're using your own list, then yeah you have to store that somewhere. You want for sure to be able to say what's the degree of v in constant time once you're at v. So you might store a number and also a head point for your list. Or you could use a std::list and you're done. Okay so now let's figure out what these extra boxes are for. So I want to remove an edge. Let's think of that one first. So I want to remove the edge (u, v). Okay. How long does that take if I don't draw anything else? Right. It's sort of the degree of v plus the degree of u. I have the walk the edge list for those two vertices and look and see if for each node if that's the other one and remove that. So I have to scan two edges list that's sort of degree of v plus degree of u. Okay. I claim that I can do this in big-O of min of degree of u, degree of v. Does anybody have an idea of what the terrible hack that involves lots of pointers is? Yes. So everything in this list is going to point at their corresponding pair. Every edge is stored twice. If I have an edge (u, v), I'm storing a list node that has v in the list corresponding with u. I'm storing a list node that holds u in the list corresponding with v. Alright, so what I'm going to do is have both of those list nodes refer to each other. I have this node right here represents the edge (u, v). So it should point at the other list node that represents the edge (u,v) which is this node. Okay so I'm going to have a pointer here that points there, and a pointer here that points here. So those two nodes are linked together. Similarly, for this node, this is the node that represents what edge? (U,w). So it should point at the other node that represents the edge (u,w) which is where? Head of the list at w right? That makes sense? There's two places I'm storing the fact that there exists an edge between u and w. One is in the list u and one is in the list w. Right. So I'm going to have this node here refer over to this node here. This node here refers to this node over here. What I'm wanting here is an easy way to immediately jump to its correspondent parent in another list. So, this edge here represents the edge (v,w) so it's going to have a pointer down to this thing and this is going to have a pointer to this thing. This edge is the (w,z) edge. So it's going to point down to this node, and this node is going to point up to this node. Now you see why there is pointer madness. So this drawing is horrible and terrible. The reason why I'm doing this is so I can get to the other edge, the other spot that corresponds with this edge that I'm removing. So now I can pick when I'm ask to remove the edge (u,v), I can pick which list is smaller. Walk that list until I see the other endpoint. Grab that point so I can remove it from the other list, and from my list. I did that in the minimum of degree u and degree v time. So then finally, given that I have this new thing there, how long is it going to take me to remove a vertex. We will stop here. Degree of v, Right? For every node in that list, in a list rooted at v, there are two nodes that I need to delete. One that is in v's list and one that's in the other node's list. I have a pointer in every node that goes to every node that I need to delete. So now I can just walk the list at v and delete all of the nodes that corresponds to all of the other nodes in this list. So that gives me big-O of degree v. So we will start with a summary of all of this next time","width":22976}]