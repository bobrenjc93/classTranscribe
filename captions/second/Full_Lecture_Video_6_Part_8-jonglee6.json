[{"text":"If I don't have this one at all.","width":192},{"text":"All of these one will invoke first one.","width":192},{"text":"Okay.","width":64},{"text":"So, it turns out that const reference can combine R values.","width":384},{"text":"If I wanna change, behavior is , when i get an R value. I add overload that takes R value reference.","width":512},{"text":"You can const R value reference, no one ever does that. Because it is useless","width":320},{"text":"Most of time when you are taking R value reference, probably wanna do something with temporary.","width":256},{"text":"But you can't take back const * reference value. ","width":384},{"text":"I ve got one overload that takes const reference. One overload that takes R value rerence.","width":512},{"text":" When the compiler is figuring out which one of these functions to compile in at the call site.","width":384},{"text":"It looks out what argument is and says that argument is L or R value.","width":512},{"text":"R value call the R value overload.. L value calls const reference overload.","width":192},{"text":"So our printout should depend on where argument of function is R or L value.","width":448},{"text":"Function is R value, it should print R value. Vice Verse.","width":320},{"text":"What about this first one?","width":384},{"text":"First one here, I am calling foo of sphere ()","width":576},{"text":"So first of all, what is that even mean?","width":256},{"text":"Foo of sphere braces.","width":256},{"text":"Yea, Making a default sphere. and then immediately passing it to food.","width":768},{"text":"(foo)","width":128},{"text":"the question is. ","width":256},{"text":"R value or L value?","width":256},{"text":"R value, it is temporary, does not exist yet. ","width":256},{"text":"It exists but I do not know where it lives or have a name, or if it can assign into it. This argument is an R value.","width":832},{"text":"Because it's temporary.","width":256},{"text":"Alright.","width":256},{"text":"What about this other one? So sphere of S, food of S ","width":320},{"text":"L value, It is going to print out L value, Because S has a name, has a memory location. has a initialization, not temporary. It is L value.","width":832},{"text":"Invoking const reference overload","width":128},{"text":"What about this one?","width":192},{"text":"Sphere S; foo is std::move(s) . ","width":192},{"text":"R value. Why is it that?","width":256},{"text":"Std;:move","width":192},{"text":"Note that std;:move does not do any moving. ","width":256},{"text":"All it does is flag something that is R value. ","width":256},{"text":"I know this thing got a name, because passing into a function. Pretend it's R value. Convert to R value","width":512},{"text":"Then pass that along to whatever i am calling. ","width":192},{"text":"I know S is an really L value. Make it be L value. It's gonna look.. fine. S is R value. invoke R value ","width":768},{"text":"Explicitly said, move. move is just gonna make it R value. It is not going to be R value. It is not going to do move. Move is in constructor.","width":768},{"text":"Move is making this thing R value. ","width":320},{"text":"At the end of foo, answer is true whether it does or doesn't. ","width":1088},{"text":" At the end of foo, is S now R or still L value?","width":640},{"text":"It turns out it is still L value.","width":192},{"text":"R value conversion is just for that function call.","width":256},{"text":"S would be still L value. still got memory location. ","width":192},{"text":"Using std:;move is way of forcing, for that particular reference to be R value. ","width":448},{"text":"Why you care?","width":192},{"text":"What about this one?","width":448},{"text":"I ve got a function. make sphere return sphere by value. Make on stack frame. ","width":640},{"text":"Okay returns by value./ ","width":256},{"text":"i ve got a call to foo of makes sphere.","width":320},{"text":"R value. ","width":128},{"text":"IR value(??)","width":320},{"text":"Temporary value. thing I am getting back is that return value copy. It is going to temporary.","width":832},{"text":"Our return value does not have a name. It is copied out of the make sphere function. It is temporary , does not have name anymore.","width":896},{"text":"The L value, because that is P inside of that stack frame got a name and memory location.","width":1280},{"text":"Then it is temporary, and has no name or location.","width":512},{"text":"You can kind of see, when overload would be invoked.","width":896},{"text":"What did function signature remind you of ? What's that look like?","width":704},{"text":"Kind of like argument of copy constructor by const reference. Right hand side looks like move constructor. R value. ","width":640},{"text":"Reason for that exercise is for you to able to look at the code and identify if you are going to make copy or move something","width":512},{"text":"Because same rules we apply picking which structure to invoke.","width":384},{"text":"I've got a tricky question for you","width":384},{"text":"Line of code there.","width":128},{"text":"What one does one called? Called R value of one? does it called L value of one.","width":1280},{"text":"Calls the L value of one. This is weird","width":64},{"text":"Even though, SP inside of function has been passed by R value reference, but you now have name for it. Now inside of function, it is L value.","width":896},{"text":"No, I know it's not R value","width":192},{"text":".Inside of the function it is L value. because I have name for it. whenever I refer to it I can say sp, I can take address of sp. I know what it is now. I named it.","width":768},{"text":"Now it is L value. ","width":192}]