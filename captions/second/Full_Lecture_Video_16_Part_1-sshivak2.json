[{"text":"If the queue is about a certain length, then that certain length is up to the TA to decide.","width":498.39999997615814},{"text":"The visit that the TA will have with you, is to be no longer than 15 minutes, and if it goes longer than that, they are allowed to just move on to the next person.","width":493.39999997615814},{"text":"Their goal at office hours, is to help you get unstuck, it's not to solve the mp for you, it's not to debug your code, it's not to answer your question of whether your function is right or not.","width":666.3999999761581},{"text":"That's not what they are for.","width":86.39999997615814},{"text":"The office hours are for helping you get unstuck. So, that means that you've already gotten stuck, that means you've tried everything at your disposal to try and get unstuck: you've debugged, you've opened valgrind, you've run it with ASAN, you've run it in gdb, printed out stuff, you know where the segfault is occurring, you know what the symptom is, you don't know why, but you know where and can explain to a TA, competently, exactly what's going wrong.  ","width":1502.3999999761581},{"text":"A bad question is \"I've got a segfault\". And the TA says \"do you know what line?\", \"No\", that means you haven't done your work.","width":427.39999997615814},{"text":"So, please before you add yourself to the queue, make sure that you have a well formed, specific question in mind and you've done your homework.","width":704.3999999761581},{"text":"Furthermore, the queue is not for you to sign up early. ","width":342.39999997615814},{"text":"You are to put your name on the queue when you are present in the lab for the office hours, for which you are attending.","width":529.3999999761581},{"text":"You are not to put your name on there at 6am anticipating you've got a question at 10. The TAs will delete you from the queue if you do this.","width":461.39999997615814},{"text":"So, if you are going office hours, go to the lab machine, log in, get your code up, get whatever diagrams you need to be able to explain the problem to your TA, open on the desk in front of you, and only then add your name to the queue.","width":1088.3999999761581},{"text":"So, I'm just doing these things to try and ensure that we can at least have a better shot at getting to the bottom of these queues, when they end up with 30, 40 people on them.","width":576.3999999761581},{"text":"Because, there's only so many staff to go around, and I have only so many dollars to pay those staff members.","width":236.39999997615814},{"text":"So, I'm doing what I can.","width":124.39999997615814},{"text":"Yeah? ....","width":768.3999999761581},{"text":"Contact me, contact me privately.","width":384.39999997615814},{"text":"Okay, let's jump in then.","width":320.39999997615814},{"text":"So, we were talking about trees. So, lets continue thinking about trees. So, here's a picture of a binary tree. On the right is our declaration of the binary tree class. And we've got the binary_tree.tcc below, that we are going to fill some stuff in.","width":1136.3999999761581},{"text":"We are going to write a function called traverse, which takes a const node* and a functor and runs that functor on every element of this tree.","width":886.3999999761581},{"text":"So for example, that functor might be something really really simple: it just prints out the data.","width":320.39999997615814},{"text":"It might be something that has a some other functionality. It might do something with the data, beyond just printing it, but all you have to think about is there's some operation that I'd like to do on everything that's in this tree.","width":933.3999999761581},{"text":"So, how do I do get that function to be called on every single data element in this tree?","width":347.39999997615814},{"text":"Note that the functor is not going to called on the nodes. Why not? well, nobody knows about nodes, except for us.","width":384.39999997615814},{"text":"So, the only thing that this functor is going to be invoked on are the data elements inside of the nodes.","width":360.39999997615814},{"text":"Remember the node class is private.","width":152.39999997615814},{"text":"So, saying to somebody you'll take a node for your functor, that they can't even say that type , so, doesn't make any sense.","width":465.39999997615814},{"text":"So, this functor is going to be applied to the data elements that are inside of the nodes in this tree. So, for example I might apply the functor to the value A, but not to the node that contains A.","width":790.3999999761581},{"text":"That's a subtle but important distinction.","width":256.39999997615814},{"text":"Okay, so, we are going to write this function, so let's try to declaration for it first.","width":448.39999997615814},{"text":"Declarations are always going to go in your header file.","width":256.39999997615814},{"text":"Where am I going to put this traverse function and why? Am I going to put it in the public section or the private section?","width":640.3999999761581},{"text":"So, here's the signature.","width":320.39999997615814},{"text":"Return void, it's not going to return anything at all.","width":192.39999997615814},{"text":"Where's is going to go? public or private?","width":192.39999997615814},{"text":"Private? why private? it takes nodes, right? nobody else can know about nodes except for the private and internals of the binary_tree class. This cannot be public, so, this is going to be a private function.","width":783.3999999761581},{"text":"So, we are going to put it in the private section.","width":384.39999997615814},{"text":"We are also taking a functor, a generic functor, that is not something that is part of a class hierarchy, just some object that happens to override operator parenthesis. ","width":845.3999999761581},{"text":"So this function is going to itself be a template function inside of the template class.","width":373.39999997615814},{"text":"So, this is going to be a template function, taking a fun(), whatever that functor happens to be, the type will be filled in when I invoked this function.","width":501.39999997615814},{"text":"So, even inside of the header file here, I'm going to declare this function as a template.","width":366.39999997615814},{"text":"So, we are going to have something like: template<class Fun> void traverse (const node*, Fun) const;","width":1920.3999999761581},{"text":"I'm omitting the parameter names here in the header file.","width":512.3999999761581},{"text":"For space. I could name them. You can not omit the name of the parameter in the definition of the function.","width":704.3999999761581},{"text":"You have no way referring to the parameter, if you do so.","width":287.39999997615814},{"text":"A large number of people just took size_t in their constructors for the quilt and then referred to it, using size_t as the variable name, size_t is a type!","width":550.3999999761581},{"text":"You have to have a variable of that type. okay?","width":258.39999997615814},{"text":"So, I'm allowed to omit the name of the parameter in the declaration of the function, cause I'm not using it yet. But in the definition, I am required to give it a name , in order to even refer to it.","width":828.3999999761581},{"text":"So, that's the difference, I can omit the names the header file, I can't omit the names in the cpp file.","width":392.39999997615814},{"text":"Cause I have to have a name to refer to the variable at that point. Here when I'm just writing the function signature, it doesn't care, it just wants the types.","width":384.39999997615814}]