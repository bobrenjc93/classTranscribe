[{"text":"ya, make it empty","width":64},{"text":"so i'm gonna make myself be the empty object ","width":256},{"text":"and then swap myself with the argument","width":256},{"text":"and then the argument is the empty guy and i'm not the empty guy. i'm just taking all of it's value","width":256},{"text":"now the argument is the empty guy and i'm the one that has all the values","width":256},{"text":"alright so this is just something be like you know, lines should be null; length should null","width":1344},{"text":"ok. so set myself all to be empty.","width":192},{"text":"and then just use my helper function to swap with my argument","width":192},{"text":"now the argument is empty. i'm the one that has the value. i've just taken everything from him","width":640},{"text":"ok. and then the argument is empty. i'm the one has the values so i'v just take the arrays without doing a copy here","width":640},{"text":"ok. without this, if my argument was a temporary, i'm going to do a deep copy.. i'm going to get all the memory in deep copying, all the values over, right? ","width":640},{"text":"for all the lines for all the length, right? a bunch of memory allocations for that. when i could have just use the temporary memory directly rather than making a copy","width":576},{"text":"right? so this is gonna be way faster than the copy constructor","width":192},{"text":"but it can only be invoked if the argument is an rvalue","width":256},{"text":"right? because otherwise i don't wanna do that because my copy constructor should just steal the values from the other guy right? that doesn't make any sense, right?","width":448},{"text":"so we still need a copy constructor but this is an overload for the case where we know the argument is an rvalue","width":320},{"text":"ok? let me quickly do the last one. this weekend actually finish the worksheet","width":384},{"text":"this is a saddle point and a good point to end on because we talked about the copy and swap operator thing","width":384},{"text":"so why do we not need to also provide a move assignment operator?","width":256},{"text":"if we're using copy and swap, and i sort of hinting to think about what constructors are invoked for this expression right here","width":1088},{"text":"what's happening here? book and making a book b that's got a hundred chapters. i'm doing whatever sets a line in that book","width":320},{"text":"i've got book a, it's got 10 chapters and then i say a is going to be std::move of b","width":512},{"text":"ok? so b is going to be treated as an rvalue","width":192},{"text":"and then i'm going to invoke operator =","width":320},{"text":"yes(Q&A)","width":192},{"text":"so i can actually, so what this is saying is that i'm going to treat b as an rvalue and i'm going to invoke the assignment operator","width":448},{"text":"if we wrote it with copy and swap, the system is going to invoke a constructor for the value argument","width":512},{"text":"taking whatever is on the right hand side,right hand side has now been flagged as an rvalue","width":448},{"text":"the system one invoked the move constructor instead of copy constructor,ok?","width":320},{"text":"then my value just steals everything from b inside of that function. i swap with it i return myself","width":448},{"text":"right? i didn't make any redundant copy because the copying now in the copy and swap was move","width":384},{"text":"right? so that copy and swap operator, equal is  often called the unifying assignment operator for c++11 and up","width":576},{"text":"because if you write that thing once, it works as you'd have expected for copying and for moving","width":384},{"text":"right so if you'd have that there it will do your move, it will do your copy assignment like you'd expect make a deep copying right?","width":384},{"text":"do that properly. strong exception safe","width":192},{"text":"if you're calling it with rhs that's an rvalue, it invokes the move constructor then swap. that's also strong exception safe","width":448},{"text":"ok. and i didn't have to write a separate assignment operator for overloading the case where was an rvalue because the system will automatically invoke the appropriate constructor for that value argument","width":640},{"text":"ok. that make sense right?","width":192},{"text":"wherever this system is going to make a value like you passing something in by value, you returning something in by value","width":448},{"text":"the system is gonna look for a constructor that just takes whatever that argument in it","width":320},{"text":"and if that argument happen to be an lvalue, makes a copy because that's the right behavior for that","width":320},{"text":"if that argument happen to be an rvalue like a temporary or whatever, it will do the move constructor","width":320},{"text":"so avoid making copies if they're not needed","width":192},{"text":"right?","width":128},{"text":"so it turns out if you do the assignment operator, the way i've taught you, you only need to write it once. you don't need to write it twice","width":448},{"text":"you do it any other way you have to write it twice. so don't,ok? lot's of advantages","width":384},{"text":"ok that's end and leave","width":5376}]