[{"text":"OK. So this is a good question. His question was OK, we got multiple things living in the bucket now, how do I find the thing inside the bucket?","width":754},{"text":"Once I go to the bucket, I know, for a given key I know which bucket it should live in, if it's there.","width":384},{"text":"So how do I actually locate it?","width":128},{"text":"Yeah.","width":256},{"text":"So I need to store both the key and the value in those list nodes.","width":476},{"text":"So what I'll do is I'll take my keys, I'll hash it and mod the size and go to that list.","width":313},{"text":"And then I traverse the list, looking for key that match my key.","width":256},{"text":"OK. So if I'm looking for, in this case, you know, 29, or even worse, 8, ","width":448},{"text":"When looking for the 8, I hash it, mod the size, I get cell 1, and I walk that list, asking each node \"Is your key 8?\". If not, move to next index, \"Is your key 8?\". If not, move to next one. \"Is your key 8?\". Oh, OK. It's 8, I found it. ","width":896},{"text":"Similarly, if I ask for something that hash to bucket 1, and it's not in there, I'll still have to walk the whole list to determine if it's not there.","width":640},{"text":"OK. So finding something is being translated to do a hash of a key, go to the bucket, walk everything in the bucket, to determine if it exist in the bucket or not.","width":824},{"text":"Yeah.","width":64},{"text":"We'll hit that in a second.","width":919},{"text":"The answer is when you resize, you need to rehash everything.","width":256},{"text":"How would I do like a remove?","width":432},{"text":"By say, like, remove 4","width":194},{"text":"What is that look like?","width":83},{"text":"Yeah?","width":448},{"text":"Right. It's gonna be erase() on your list class, right?","width":256},{"text":"The overall process for doing a remove would be remove 4, OK","width":448},{"text":"hash 4, mod the size","width":163},{"text":"gives me cell 4","width":112},{"text":"Going to that list.","width":115},{"text":"Get an iterator to the beginning.","width":93},{"text":"Walk the list until the iterator points at the node containing 4.","width":249},{"text":"If it exist, and if I find it, call erase() on that list with that iterator.It will erase that node.","width":384},{"text":"It might be convenient for me to have a doubly linked list here if I want to erase.","width":256},{"text":"through an given iterator instead of a erase after something.","width":256},{"text":"In the lab, you'll have doubly linked list, so that's easy.","width":192},{"text":"But, basically it boils down to locate the list it could be in, find if it's there, and if it's there, remove it, and if it's not there, don't do anything.","width":554},{"text":"Yeah.","width":64},{"text":"OK. So this is only true if my table is sufficiently large.","width":1152},{"text":"If I'm not resizing the table I can just trivially start insert more and more things here and the list and the list size is unbounded.","width":396},{"text":"If my table's size is 7 forever, and I just keep inserting more and more keys, and my list is gonna keep growing.","width":640},{"text":"So I have to be able to say something about what is the length of the list relative to the size of the table somehow.","width":448},{"text":"and resize the table.","width":128},{"text":"So we gonna do that.","width":256},{"text":"We gonna let N be the number of user specified key-value pair that exist in the table.","width":768},{"text":"And we gonna let M be the current size of the table.","width":384},{"text":"So M is the size of array cells we have, the number of the lists.","width":370},{"text":"And N is the number of key-value pairs we've got.","width":198},{"text":"Or the number of nodes.","width":128},{"text":"That question here that we have when we were thinking about, OK, these lists look like they are sort of growing so how do we know that that's OK?","width":1216},{"text":"We sort of wanna know, and by the way, I'm not gonna say anything about the worst case here, I'm now only gonna talked about amortized analysis, so in the average case.","width":644},{"text":"which is, just another way of doing the averaging.","width":368},{"text":"So I'm arguing about the expected time to find a key, so if you give me some key, what's the expected time to find that? ","width":470},{"text":"In other words, I wanna say what's the expected length of the list for, that's associated with a key x?","width":800},{"text":"So if somebody gives me key x, what's the length of the list for x?","width":230},{"text":"That'll tell me how long I sort of expect to find some key x.","width":256},{"text":"OK. If l(x) is the expected length of the list that associated with key x, ","width":1024},{"text":"How am I going to argue about how long I expect that list to be?","width":512},{"text":"Well, the list really only increases.","width":244},{"text":"The list only increases every time I have a collision, ","width":640},{"text":"So in other words, I sort of care about what the probability is of having a hash collision. ","width":784},{"text":"sorry, a table collision.","width":343},{"text":"for all of the other keys that might be in my table.","width":256},{"text":"Let's let T be the set of keys that are currently in my table.","width":576},{"text":"So what I'm gonna say is I want sort of sum for all y that are in my table.","width":640},{"text":"Of the probability that I see, a collision in my table.","width":704},{"text":"So I'm actually just write down the formula directly for this probability. ","width":448},{"text":"This isn't the probability that I have a hash collision?","width":256},{"text":"This is the probability that I have a collision in the hash table. So this is post-modulo. ","width":384},{"text":"What's the probability of that collision.","width":192},{"text":"You can still think of this in terms of kind of the same argument though, right? It's just our output space is significantly smaller now.","width":621},{"text":"The output space for our hash function is now m.","width":320},{"text":"If m tells us the number of cells in our array, the only valid output for our indices, are 0 through m-1.","width":708},{"text":"So the number of possible output value, which is little m, and we assuming uniform hashing, the distribution over those cells should be uniform","width":947},{"text":"So the probability of having for specific key x, the likelihood that I have some other key y going to the same bucket as x, is just 1/m.","width":896}]