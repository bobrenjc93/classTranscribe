[{"text":"Where little m is the number of buckets I got.","width":316},{"text":"If my index outputs are uniform, which I get from assuming my hash function is uniform. ","width":495},{"text":"The probability that some other key goes the same position that as x did is just 1/m.","width":384},{"text":"Just from the simple uniform hashing assumption.","width":128},{"text":"This, is the summation of how many things? ","width":768},{"text":"N. N is the number of key-value pair in the table.","width":320},{"text":"So what I have here is N/M as my result","width":558},{"text":"So the expected length of a list, the expected length of one of my list, is the ratio of the number of user-supplied elements to the number of buckets that I've got.","width":1068},{"text":"So the that's how long one of my list is.","width":448},{"text":"Notice that here if M is never changing, if M is constant, what's the expected length in terms of big O of N?","width":576},{"text":"O(N), linear, right?","width":174},{"text":"So this tells me necessarily that I need to be increasing M as N grows larger.","width":448},{"text":"Otherwise, this ratio is just gonna be linear.","width":192},{"text":"That's the observation you are making. Right? The list is just gonna be linear, almost.  It's like N over, how many buckets I've got,  right?","width":464},{"text":"So I need to be able to make the argument that my bucket count is always growing proportionally to N.","width":338},{"text":"OK? In other words, so I'm gonna give this thing, this thing has a special name, alpha, which is our load factor.","width":768},{"text":"OK? And this sort of telling us how full the table was, like what percentage, if everything went into it's own bucket, what percentage of bucket has something in them? ","width":1058},{"text":"It's not true here, but it is sort of a ratio that tells us how full is our table compare with the number of buckets we've got..","width":396},{"text":"And what we are gonna do for our resizing? ","width":204},{"text":"We need to ensure that alpha is always some constant.","width":576},{"text":"If alpha does not stay constant, we can't argue the expected length of our list is a constant.","width":415},{"text":"That's what we'd like to do. We'd like to say, OK, we've got enough buckets, so that this ratio N/M, is always some constant, some really small constant.","width":704},{"text":"so that the expected length of the list is like equal, or heck even smaller than one.","width":626},{"text":"I'm gonna bound this load factor to say that it's always constant.","width":237},{"text":"so we are going to resize not when all of the buckets have been filled ","width":336},{"text":"But when the load factor would increase above the fixed constant we cared about.","width":466},{"text":"So you just have to pick some fixed constant that you wanna guarantee","width":320},{"text":"is your load factor, and as soon as you insert another element you would go beyond that load factor, you need to resize the table.","width":448},{"text":"So my resizing strategy is no longer when the array fills, double it. ","width":362},{"text":"my resizing strategy is when the load factor increases above my threshold, resize.","width":349},{"text":"So there may still be many empty buckets when I do a resize. It's just, I do the resize when I have enough elements to warrant it.","width":543},{"text":"when N/M goes above whatever I set my constant to be.","width":256},{"text":"but I want my alpha to be never be any bigger than 0.7, which is the arbitrary number I picked for the lab.","width":419},{"text":"If I want my alpha to never be bigger than 0.7, I need to resize whenever N/M would give me something bigger than 0.7","width":448},{"text":"It's no longer about, like, running out the cells anymore.","width":225},{"text":"It's about the load factor of the table.","width":156},{"text":"So what do we actually gonna do, sorry, yes?","width":576},{"text":"OK. So let T be the set of all keys that are currently in my table.","width":832},{"text":"I wanna argue about what's the expected length of a list.","width":320},{"text":"the list that corresponds with some arbitrary key x?","width":320},{"text":"OK? So the expected length of a list at some particular position is sort of gonna depend on how many elements collided with it.","width":824},{"text":"So the expected length of any arbitrary list is going to be, the expected number of elements, for which their index value give me the same position is accident.","width":640},{"text":"The likelihood of that happening, if I have a uniform hash function, and then I mod by the size, that's still gonna be uniform, but it's just uniform over a smaller space.","width":768},{"text":"My smaller space now is the set of small integers from 0 to little m, where little m is the number of elements, sorry, the number of slots in the hash table.","width":611},{"text":"Number of buckets, right?","width":91},{"text":"So the likelihood that I have for any arbitrary key in the table, the likelihood that it collided with x, is just 1/m. It access some spot, the likelihood that they picked the same spot is 1/m.","width":763},{"text":"and then, If I care about, that's just for one key, I care about for all the keys with the probability they go there, ","width":512},{"text":"So I sum all of the keys in my table, and that give me, this N/m","width":476},{"text":"Where little m is the number of buckets, and N is the number of the elements.","width":364},{"text":"So it's sort of the uniform-hashing argument, except for  we've also moded the hash function now so our output space is significantly smaller. ","width":576},{"text":"Now we are directly in control of the size of our output space, in some sense.","width":512},{"text":"So when the size of our output space is sort of too small relative to the number of elements you got, you increase the size of the hash table output space to guarantee that the collision probability is low.","width":640},{"text":"The key thing here, is that the expected length of a list, under this collision resolution strategy, is exactly the load factor.","width":689},{"text":"So if the load factor can be held constant, then you can say, whenever I'm doing anything to the hash table, my load factor is at, or below a certain constant.","width":640},{"text":"Then I know the expected length of a list is a constant.","width":223},{"text":"Now no longer depends on the number of the elements.","width":256}]