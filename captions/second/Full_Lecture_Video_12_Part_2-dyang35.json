[{"text":"Ok, at a list of 3 elements it look like this","width":128},{"text":"where that head is a data member of that class","width":384},{"text":"and the rest of this is a chain in the heap","width":192},{"text":"We talked a little bit last time about also having an extra data member called tail","width":1856},{"text":"which is a raw pointer to this last node","width":256},{"text":"For the front it doesn't really matter, but it will matter later","width":320},{"text":"So what do I do if I want to add something to the front, push front onto a singly linked list","width":256},{"text":"so what can I do?","width":384},{"text":"What's the first thing I need to do?","width":256},{"text":"Make a node. So I'm gonna make a new node","width":448},{"text":"I use zero, say","width":192},{"text":"Okay","width":128},{"text":"Now what?","width":192},{"text":"I need the next of this new node that I've made, so presumably I've got some current","width":448},{"text":"owning pointer to that node that I just made","width":128},{"text":"so it sticks around and doesn't just leak","width":192},{"text":"I want curr's next to be pointing at head","width":256},{"text":"I want the next pointer of this new node to be own the old head of the list","width":320},{"text":"so I'm gonna move","width":256},{"text":"the value of head into the value of curr next, so we get something that looks like this, and head is currently NULL","width":448},{"text":"Alright","width":64},{"text":"If I maintain a size I should probably increment my size at some point","width":384},{"text":"and then what?","width":192},{"text":"head needs to point to the new node that I've created because this new node is now head of the list","width":256},{"text":"so I'm gonna std::move() curr with head, so head is going to point here","width":320},{"text":"and curr would be NULL","width":192},{"text":"or I could swap them, that is also equivalent","width":256},{"text":"RIght so how long did that take?","width":192},{"text":"Constant time, just a couple of pointer assignment","width":192},{"text":"I had to make a node, I re-adjust some pointers","width":256},{"text":"a couple of pointer assignments and allocation","width":128},{"text":"but it was all constant time, it didn't matter how many things I had in the list","width":640},{"text":"so for singly linked lists push front was constant time","width":448},{"text":"does the picture change at all?","width":128},{"text":"for a doubly linked list, if I add previous pointers","width":192},{"text":"does the running time change at all?","width":128},{"text":"No","width":128},{"text":"Do I have to do more work?","width":128},{"text":"Yes","width":64},{"text":"I have to do more work but it's still a constant amount of more work","width":256},{"text":"I have to adjust these previous pointers, so instead I'll have a doubly linked list","width":320},{"text":"which will look like this","width":128},{"text":"for the nodes are a little bit bigger","width":1152},{"text":"the next pointers are owning pointers","width":384},{"text":"the previous pointers are what?","width":128},{"text":"What type is the previous of a node in a doubly linked list?","width":192},{"text":"Raw pointer, why is it a raw pointer","width":192},{"text":"It doesn't own that node, right? The ownership of the node is maintained to be","width":320},{"text":"this way, towards the tail","width":128},{"text":"so the previous node owns the next nodes, but the current node doesn't own its previous node","width":320},{"text":"It doesn't own its parents, so to speak","width":192},{"text":"but we still had this head pointer","width":320},{"text":"If I want to add a node to this doubly linked list, it looks very very similar to before","width":320},{"text":"I make a new node","width":64},{"text":"with value zero","width":128},{"text":"make sure that it's initialized properly, so I probably wanna have a constructor for a node that sets things to NULL","width":448},{"text":"Do the same things where I'm gonna set","width":128},{"text":"this next to point there, now our head","width":256},{"text":"and the make head point to the new node","width":256},{"text":"But then I'm not done because I still have to adjust that previous pointer","width":256},{"text":"the old head's previous pointer needs to look at the current head, so I need to","width":320},{"text":"readjust that to look there, right","width":256},{"text":"Fundamentally, none of that took time proportional to the length of the list","width":320},{"text":"It didn't involve me scanning through the list or didn't depend on the number of elements","width":320},{"text":"it only did stuff locally at the head","width":128},{"text":"So this also for a doubly linked list","width":576},{"text":"What about the vector implementation?","width":384},{"text":"I wanna insert something at the front of that, what do I do?","width":512},{"text":"I gotta shift","width":64},{"text":"I have to do a shift of every element starting from the back","width":192},{"text":"move 3 there, move 2 there","width":128},{"text":"move 1 there and then","width":128},{"text":"this becomes zero, this becomes one and this becomes two, and this becomes three","width":256},{"text":"and to shift all of my data to the right so that I can put something at the front of this vector","width":320},{"text":"because the vector starts at index zero","width":384},{"text":"how long did that take","width":128},{"text":"O(n) now I had to do a copy for every data element that's currently in the list","width":448},{"text":"So this means that I took time proportional to the number of elements in the list which is O(n)","width":640},{"text":"What about the reverse operation? I wanna remove the thing at the front","width":384},{"text":"What do I have to do for a singly linked list?","width":448},{"text":"Change head. I need the head to point at head's next instead of where it used to point","width":256},{"text":"and make sure that the node that was at the head is freed","width":256},{"text":"an easy of doing that is just to std::move(head) into head's next","width":320},{"text":"which will cause that to become NULL, and since there's no longer any owner pointer to this node, so it gets freed","width":384},{"text":"Okay. How long did that take?","width":128},{"text":"head = std::move(head->next), how long does that take?","width":320},{"text":"constant time. It didn't have anything to do with the number of elements in the list","width":320}]