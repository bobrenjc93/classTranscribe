[{"text":"Alright.","width":64},{"text":"-----------","width":64},{"text":"So, let's look at this first thing which is these constructors and assignments and stuff.","width":384},{"text":"------------------","width":128},{"text":"What do we think about this first one?","width":128},{"text":"------------------","width":55},{"text":"So, p equals i, so p we're declaring a tripe of int, double, char 1, 1.2, 'a'. We're declaring a triple<int,int,int> i with 1, 2, 3 and then we're trying to assign i into p.","width":960},{"text":"How do we feel about that?","width":102},{"text":"------------------------","width":192},{"text":"Okay, incorrect, why?","width":64},{"text":"------------------------------","width":338},{"text":"So, these are, so, it goes beyond this. So, it's not going to try and do auto conversion of these things for you in this case. Right?","width":647},{"text":"So, what's going to happen is it's, this is an assignment operator. How do I know this is an assignment operator? Good review for the exam. How do I know this is assignment?","width":448},{"text":"--------------------","width":132},{"text":"p already exists, right? If it said, you know, triple<int, double, char> p equals i, then it's not assignment, right? That's construction.","width":547},{"text":"So this is assignment, because p already is there.","width":192},{"text":"-----------","width":16},{"text":"So I'm invoking an assignment operator here. ","width":192},{"text":"---------------","width":14},{"text":"Well, I haven't defined an assignment operator. Okay, no, but that's fine because the system provides me one. Remember? Just like if I don't provide a copy constructor, the system provides me a copy constructor. If I don't provide an assignment, the system provides me an assignment.","width":832},{"text":"So that's fine. The problem here, I agree with this being incorrect, the problem here is that the type of the left and the type of the right aren't the same type, right? When I'm doing this assignment, I'm looking for a function whose signature is something like triple<int, double, char>::operator=(const triple<int, double, char>& other) or right hand side, right?","width":1472},{"text":"And the right hand side isn't something of triple<int, double, char>. Even though those types might be able to convert, in this case you can't go, do it here, but even if they did, this still won't work because the types aren't the same. The types don't match. I don't find an equal operator that takes these different kinds of triples and so this doesn't work.","width":1408},{"text":"So this won't compile.","width":64},{"text":"-----------------","width":115},{"text":"Okay? And it's going to be a type mismatch.","width":128},{"text":"---------------------","width":192},{"text":"The only equal operator that exists for assigning into tripe<int,double,char> is from something of type triple<int,double,char>. That's the only way you can do that.","width":704},{"text":"-------------------------","width":192},{"text":"What about this one? So triple<double,int,int>  t2{i}, so I'm trying to copy construct into t2 from i. Does that work?","width":704},{"text":"--------------------------","width":256},{"text":"What's the type of i? Well, triple<int,int,int>. What's the type of t2? triple<double,int,int>. ","width":448},{"text":"----------------","width":128},{"text":"So these aren't the same type, so I'm not going to find a copy constructor here. Because the types are different. So this is not going to work. ","width":384},{"text":"-------------","width":128},{"text":"My copy constructor, I haven't provided one, right, so the system is going to give me one for free. But the signature for that is going to be triple<A,B,C>::triple taking a const triple<A,B,C> ref. Well, A, B, and C aren't the same here. So that means that these are actually different types.","width":1152},{"text":"-------------------","width":98},{"text":"When I say triple with different template arguments, that gives me a whole brand new type. It's not like all triples are comparable or assignable from one another, or copy constructable from one another. ","width":512},{"text":"They're actually different types. So triple<int,int,int> is not the same thing as triple<int,double,int> or something. Right?","width":491},{"text":"Those are two separate, completely different types. Despite the fact that this sort of came from the same place, they're different types. ","width":393},{"text":"So this doesn't work because I'm trying to construct from a value of another type and I don't have a constructor overload that takes something of that type. Okay? So this doesn't work either.","width":576},{"text":"--------------------","width":35},{"text":"Okay, fine, what about this one? triple<int,int,int> t{i}?","width":291},{"text":"------------------","width":128},{"text":"Yeah, that's fine.","width":64},{"text":"-------------","width":64},{"text":"What is this going to do?","width":64},{"text":"Yeah, copy construct. It does find the copy constructor now, because the argument is exactly the same type as the thing being constructed, so this fine.","width":640},{"text":"---------------------------","width":192},{"text":"Okay, triple<int,double,char> p2; Does that work?","width":448},{"text":"-------------------","width":192},{"text":"This is subtle.","width":64},{"text":"----------------------","width":192},{"text":"So this would invoke the default constructor. Do I have a default constructor? No. So this doesn't work.","width":512},{"text":"-------------","width":64},{"text":"Compiler provides one, if and only if I provide no other constructors.","width":320},{"text":"-------------","width":64},{"text":"So as soon as I provided a constructor that takes an A, a B, and a C, the compiler says okay, you know what you're doing, you know how to construct these things, so I'm not going to provide you a default constructor anymore.","width":640},{"text":"-------------------","width":128},{"text":"I can get back, if I want it back, I can get it back, and I can say something like triple","width":320},{"text":"--------------------","width":135},{"text":"equals default","width":98},{"text":"---------------------","width":192},{"text":"That's saying, okay, actually, I did want that. Give it back.","width":192},{"text":"------------","width":64},{"text":"I wanted that. That was useful.","width":64},{"text":"Now, it's fine because I do have a default constructor.","width":256},{"text":"--------------","width":18},{"text":"Okay, but there's this rule that says if I provide a constructor, if there is a user-supplied constructor, a compiler will no longer provide you the default constructor.","width":576},{"text":"So now you have to write one if you want that behavior.","width":192},{"text":"---------------------","width":113},{"text":"If you think about it, that sort of makes sense. ","width":153},{"text":"Right? If I've got a user-provided constructor, that means that I'm defining what you've got to do to make something of this type.","width":576},{"text":"---------------","width":64},{"text":"If the system also provided me a default constructor, that means there is another way of going around my constructor that maybe doesn't do the right set-up for me.","width":409},{"text":"Right? Imagine I've got a class that's got like dynamic memory in it. Right? And I've got a constructor that takes a size. And it's set to the size and it makes the dynamic array of that appropriate type.","width":512},{"text":"-------------------","width":128},{"text":"If I also had a system provided default constructor, what's it going to do? Well, it's just going to set the pointer to nullptr maybe if I'm lucky and the size is going to be garbage.","width":768},{"text":"So that's not what I wanted at all, right? So it sort of makes sense, right, once you provide a constructor, the system doesn't provide you the default one anymore.","width":479},{"text":"It will still happily provide you a copy constructor, but it won't provide you a default constructor anymore.","width":320},{"text":"--------------------------","width":1280},{"text":"This is just a way of not having to right anything implementation file at all. So it saved me like one, two, three, four, five lines maybe. Because I don't have to say the template stuff, I don't have to declare it anymore, it's just","width":704},{"text":"-------------","width":25},{"text":"This means exactly that. Leaving it without equals default and in the cpp file, declaring it, defining it with an empty body, does nothing,","width":576},{"text":"That'll do the exact same thing.","width":128},{"text":"----------------------","width":576},{"text":"Yes, I could make that valid. I would have to provide an explicit assignment operator for these different types now though.","width":384},{"text":"---------------------","width":320},{"text":"Like if I wanted to be able to like assign from triples for whom I know there's implicit conversions for their arguments for example, right, I would have to write an assignment operator that allows me to do that.","width":768},{"text":"---------------","width":128},{"text":"Or let's say I wanted to be able to assign into a triple<int,int,int> from an int and it sets all three to be the same thing. I could do that. I just have to provide an overloaded assignment operator for that case.","width":692},{"text":"So the problem here is that the default provided one is going to be only two things of the exact same type. And so since the template arguments differ, it doesn't find it because it's not the same type.","width":640},{"text":"But yes, I could add overloads to make that work if I wanted to.","width":320},{"text":"--------------","width":192}]