[{"text":"So here is the basic idea","width":237.18181824684143},{"text":"I'm going to have one per thread [gibberish]","width":760.1818182468414},{"text":"So our processes have at least one thread of execution","width":233.18181824684143},{"text":"And it would start in main, as far as we are concerned","width":138.18181824684143},{"text":"And finish when you either called exit or returned from main","width":334.18181824684143},{"text":"And now I'm going to show you how we can have multiple threads going inside each process","width":565.1818182468414},{"text":"So let's start on the stack. All the automatic variables, also known as temporary variables,","width":420.18181824684143},{"text":"(the reason they are called automatic is because they automatically disappear when we return from a function and our stack gets shorter)","width":763.1818182468414},{"text":"You'll find the return address for the CPU, in other words what code you want it to execute when it finished calculating the current function","width":810.1818182468414},{"text":"and the last thing we'll see is the previous stack pointer, or the previous SP","width":699.1818182468414},{"text":"Because we want our stack to shrink when we return from the current function","width":759.1818182468414},{"text":"So what happens if our stack gets too large?","width":294.18181824684143},{"text":"It's.... Stack Overflow. Yes! You've probably heard of the website called Stack Overflow.","width":412.18181824684143},{"text":"I actually registered as the username Infinite Recursion, I couldn't believe it wasn't already taken","width":679.1818182468414},{"text":"So we have a limited amount of memory so in a single threaded model, our stack would meet the heap. Kaboom, and we're out of space","width":933.1818182468414},{"text":"Our program crashes. In fact, by the power of Virtual Memory, what we can do is set up little pages of memory that are like quicksand","width":610.1818182468414},{"text":"If our program attempts to read them, then it will crash the program deliberately, we send it a Segmentation Fault. Yes? ","width":452.18181824684143},{"text":"[Student asking question]","width":201.18181824684143},{"text":"Can you sbrk more memory for the [stack]. No, no you cannot. Sbrk represents the top of the heap.","width":434.18181824684143},{"text":"[Another student question]","width":257.18181824684143},{"text":"No, but where they meet depends how big your heap is and how big your stack is","width":425.18181824684143},{"text":"What we're going to do is make multiple threads though, supposing we have multiple CPU's working at the same time","width":474.18181824684143},{"text":"So what we'll have to do is make our stack start in different places","width":212.18181824684143},{"text":"So there is actually a possibility of one stack hitting another stack if it gets too large","width":483.18181824684143},{"text":"Now let's have a look at some code, let's play with some code","width":450.18181824684143},{"text":"Here we go. C'mon. Great.","width":353.18181824684143},{"text":"We are going to be working with a thread framework called pthreads","width":250.18181824684143},{"text":"It's very popular, you can run it on Android machines as well","width":291.18181824684143},{"text":"Here's the plan: We are going to make our program do some CPU cycles","width":470.18181824684143},{"text":"We agree that our program will never print Hello World, it will just go around this loop forever","width":401.18181824684143},{"text":"But what I would like to do is have a second CPU working on my machine","width":316.18181824684143},{"text":"And for that, I can call pthread_create","width":243.18181824684143},{"text":"There's four arguments, let's have a look at them","width":233.18181824684143},{"text":"First, we have a pointer to pthread_t, some attributes which can just be NULL, this scary looking thing and finally an arg","width":939.1818182468414},{"text":"Let's talk about each of these","width":222.18181824684143},{"text":"First of all, this is a function pointer. It looks pretty scary, void star start routine ahhhhh!","width":505.18181824684143},{"text":"Here's how to read this: You see where it says start routine?","width":214.18181824684143},{"text":"Just interrupt that as the name of your function and then work backwards. It's going to return a pointer to a void* and it takes an argument void*","width":813.1818182468414},{"text":"And then we wrap the name of the function with an extra set of parenthesis. Let's take this and write our function","width":931.1818182468414},{"text":"Cool beans","width":506.18181824684143},{"text":"Alright, what should we do inside cool beans?","width":133.18181824684143},{"text":"Let's sleep for 2 seconds, then we will print out the pointer","width":902.1818182468414},{"text":"And a new line. Ok, so now let's call pthread_create","width":357.18181824684143},{"text":"We can have a pthread id. So we pass in the address of that stack variable, we aren't doing attributes today","width":781.1818182468414},{"text":"Now we can just pass in the function name. If you ever pass in a function name without the parenthesis, it means \"Tell me the address of this code\"","width":725.1818182468414},{"text":"And finally we can pass in a void *, so we write (void *) 12345","width":922.1818182468414},{"text":"Let's write something in hex. I need a hex value. How about 0xdeadcode?","width":857.1818182468414}]