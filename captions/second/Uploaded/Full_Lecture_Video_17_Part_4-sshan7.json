[{"text":"self","width":121},{"text":"so we've got a lot of work to do","width":105},{"text":"we've gotta have first mutex locks in here and we're gonna have to put some condition variables in here so that","width":366},{"text":"if we're not yet ready to add or subtract our thread should just block, it should just go to sleep","width":365},{"text":"right, so a quick refresher on condition variables","width":328},{"text":"how should we use them? well, remember, before calling cond wait, ","width":610},{"text":"you must have locked a mutex","width":289},{"text":"right, so above it somewhere at the beginning of your code you're going to lock a mutex","width":266},{"text":"but the good thing about cond wait is that it will unlock the mutex for you","width":269},{"text":"right, so let's pass in our pointer to a condition variable and a pointer to a mutex","width":443},{"text":"and when we do that, it unlocks the mutex, the other threads have an opportunity to run, and then it sleeps","width":368},{"text":"okay, how we wake up a sleeping a thread inside cond wait? easy, kick the monk","width":365},{"text":"right, how do we kick the monk?","width":335},{"text":"call cond signal!","width":207},{"text":"and that wakes up the monk","width":71},{"text":"before that thread can continue, though, it must reacquire the lock on the mutex","width":577},{"text":"so, it's ready to go, it's woken up, well now it's stuck inside a lock call","width":474},{"text":"so remember this actually does three things:","width":149},{"text":"it unlocks","width":265},{"text":"locks or sleeps","width":159},{"text":"and then relocks before returning.","width":522},{"text":"right, so this doesn't actually tell you what happened. so, in practice, what do we need to do?","width":326},{"text":"we need to write a little while loop","width":279},{"text":"here where we put some condition","width":190},{"text":"while something is true, go back to sleep","width":296},{"text":"if we want to wake up a whole load of monks, then you use broadcast ","width":471},{"text":"on the condition variable","width":346},{"text":"right, the last thing to do is before you return, call unlock","width":419},{"text":"and the beautiful thing about this is that the code that we actually see in front of our eyes can only be executed by one thread at a time","width":540},{"text":"because of this lock that we've booked, i'm sorry, unlocked","width":364},{"text":"because of the mutex","width":184},{"text":"these mutual exclusion means that only one thread can be doing stuff, can be accessing our variables inside the code that we write","width":471},{"text":"alright, so I'm going to stop and then i'm gonna let you go, so we've got the pthread mutex","width":385},{"text":"initialized in here","width":440},{"text":"and, there's something similar for condition variables as well, so there's pthread","width":293},{"text":"cond initializer","width":200},{"text":"so it's just a magic constant","width":181},{"text":"which says","width":115},{"text":"please initialize my","width":455},{"text":"my object here, my condition variable or my mutex","width":196},{"text":"right and now this is where you come in.","width":141},{"text":"it's time to write those","width":197},{"text":"three methods","width":97},{"text":"using mutex locks and condition variables","width":320}]