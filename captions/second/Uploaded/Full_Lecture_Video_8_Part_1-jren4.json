[{"text":"ok, what would our value be now?","width":503},{"text":"again, about 1.5 million, certainly not two million","width":318},{"text":"our pyrax cannot count","width":262},{"text":"OK, so why did it fail? why did my sum not get two million?","width":504},{"text":"thank you! yes! two threads are touching the same memory location","width":262},{"text":"so even though we wrote sum++, sum++ is not an atomic operation","width":413},{"text":"now life would be easy if our threads were like gorillas","width":262},{"text":"if they walked up to a memory location mine!","width":455},{"text":"they changed it, they added one to it","width":247},{"text":"they asked it any other thread","width":181},{"text":"and they threw it back","width":168},{"text":"ok, but that's not how it works of course, no instead we're copying bit patterns","width":301},{"text":"we're copying bit patterns from main memory into the CPU ","width":207},{"text":"we're running through our model adding machine and then we're putting the value back into memory","width":268},{"text":"during that time another thread may have come along and coppied the original bit pattern from memory and done it's thing inside its CPU","width":619},{"text":"and then put it back","width":112},{"text":"so hopefully you can see that it's possible that the value could be less than two million","width":720},{"text":"if it turns out that are trying to add at the same time","width":405},{"text":"in fact it's possible for  the value to be much smaller than that","width":622},{"text":"but let's talk instead about how we can actually fix this","width":392},{"text":"we've made it deliberately interesting by making sure that each threads are touching the same memory","width":457},{"text":"it would be pretty boring if they were working inside their own stack space","width":337},{"text":"or we'd give them different memory locations to play with, say if we'd give them sum one and sum two then of course everything would be fine","width":358},{"text":"life gets interesting when we actually have two threads competing and working on the same memory","width":387},{"text":"so what we'd like to do is say 'oh I've got a problem and here's a piece of my code that I only want one thread to play with at time'","width":574},{"text":"in other words, I've got a critical section","width":131},{"text":"and inside this little example here this single line is my cirtical section","width":381},{"text":"it's the piece, it's the lines of code, where you say 'I only want one process or one thread to read this memory or modify this memory'","width":639},{"text":"because if I have two threads working then they may see things or leave things in an inconsistent state","width":552},{"text":"now we're programming with a very simple exaple with integers and sums","width":224},{"text":"but now think about your other data structures you wrote in say CS 225","width":266},{"text":"where you've got multiple memory structures, you've got pointers to arrays, integers which reperesnet the number of things in an array","width":481},{"text":"if you didn't write that thing directly than the STL library did it for you","width":294},{"text":"all those things need to be in a consistent state","width":151},{"text":"if you wrote linked lists then you'd better make sure that you're sentinal value is actually present","width":432},{"text":"and there's a few nanoseconds where that's not true","width":210},{"text":"so whilst you'll updating a data structure you don't want anybody else to touch it","width":297},{"text":"you don't want anybody else to read it and you certainly don't want anybody else to try and update it at the same time","width":276},{"text":"so that's where mutex locks come in ","width":487},{"text":"so a mutex is a very valuable thing","width":360},{"text":"it's like having a girlfriend or a boyfriend or a dob","width":280},{"text":"it's yours","width":101},{"text":"and you're not going to let anybody else own it","width":199},{"text":"very objective thing","width":152},{"text":"it's mine, I'm jealous","width":113},{"text":"don't let if you are holding a mutex, you don't want anybody else","width":254},{"text":"any other thread to try to lock that mutex","width":276},{"text":"if they do they have to wait until you've finished with it","width":454},{"text":"now to be procise we are locking and unlocking","width":166},{"text":"I just wanted to give you some ideas so that in your next jealous outburst you can remember this lecture","width":586},{"text":"alright, so, let's have a look to see how we can do this, what we'd like to do is around this critical section we'd like to lock a mutex and afterwords we'd like to unlock it","width":895},{"text":"unlocking doesn't take anytime at all","width":118},{"text":"locking usually doesn't take anytime at all unless somebody else has locked the same mutex","width":384},{"text":"in which case you're out of luck","width":146},{"text":"it's a bit like trying to walk up to a counter, the clerk is currently busy, you'd have to stand there and wait and twiddle your thumbs","width":461},{"text":"in fact you might actually use up a bit of CPU time while still twiddiling thumbs, it's often called a spin lock","width":415},{"text":"which is how this thing is implemented underneath but we don't need to talk about that","width":230},{"text":"but essentially we've got a little piece of code that says ok, i have to wait i have to wait i have to wait i ahve to wait until the mutex lock has been unlocked","width":606},{"text":"but they're designed to be efficient for when you want to lock them and unlock them in the very near future","width":468},{"text":"so let's actually have a look at the code for that, how do we do that?","width":207},{"text":"we'll it's part of the pthread library","width":119},{"text":"and we can say I've got a pthread_mutex, here it is, it's a pthread_mutex_t type","width":525},{"text":"and I'll just call it my mutex one","width":360},{"text":"so now we want to lock it","width":182},{"text":"how can I possibly write that code if pthread_mutex_lock()","width":291},{"text":"what do I need to give it? the address of the mutex","width":280},{"text":"and guess how I unlock it","width":169},{"text":"you write pthread_mutex_unlock()","width":293},{"text":"OK, so now we think we've got working code","width":256},{"text":"let's try it and just for fun I'm going to reduce the number I wrote by an order of magnitute to make it run a bit faster","width":806},{"text":"tick tick tick","width":78},{"text":"suddenly we noticed even though I made the for loop to help with the speed I think it returned","width":504},{"text":"OK, heres, here's to the first surprise, it shouldn't have worked","width":448},{"text":"[laughs]","width":142},{"text":"it appeared to work, but that's just lulling us into a false sense of security","width":392},{"text":"the second surprise is that it took a bit longer","width":221},{"text":"so at least I'm sorry I took the loop down by an order of magnitude yet it still took a long time","width":427},{"text":"so this is a not free the lock and unlock are not free, it takes a certain amount of time","width":298},{"text":"especially if you look at how much overhead we're doing in this example","width":186},{"text":"we're just incrementing and getting them out of a loop. so they don't take a small amount of time to run","width":548},{"text":"the second thing is that they may not work if you've forgotten to initialize them","width":280},{"text":"and this time for a lecture demonstration i was unlucky that it did work","width":254},{"text":"what we should do is make sure that our mutex locks are properly initialized","width":338},{"text":"alright, so how can I do that?","width":127},{"text":"well before using them we should call pthread_mutex_init","width":437},{"text":"and let's look at the man page","width":275},{"text":"we can pass in a pointer to our mutex as some attribrutes if we'd like as well","width":361},{"text":"so I can say 'ok initialize my mutex and here's some additional attributes I could set up for them as well","width":410}]