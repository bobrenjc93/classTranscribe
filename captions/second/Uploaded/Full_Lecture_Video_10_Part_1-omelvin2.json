[{"text":"alright, but at some point, we'll write another thread that says \"ok, guess what? I've delivered great coffee to bervandes, and you saw it, and you wake up your meditating monk, aka your thread\"","width":764.1818182468414},{"text":"at this point, the monk wake ups. okay, I better see if there's good coffee at bervandes now","width":446.18181824684143},{"text":"alright, now, there's a little gotcha here, which is that sometimes monks wake up by acident","width":473.18181824684143},{"text":"this is called a spurious wait","width":319.18181824684143},{"text":"in other words, we'd like our monks to meditate forever until we do the little tip symbol, yes? ding! wake up","width":497.18181824684143},{"text":"unfortunately, it's not a perfect system. they may wake up by accident. but that's okay, because we will write a little loop to say, \"okay! before you attempt to purchase any coffee, actually go and see if it's any good\"","width":770.1818182468414},{"text":"\"and if it isn't, guess what I'm going to ask you to do. go back to sleep. continue meditating\"","width":562.1818182468414},{"text":"alright. now, there's a little bit more to this course.","width":418.18181824684143},{"text":"for starters, I've suggested that you can signal a waiting monk. you can throw something at them","width":562.1818182468414},{"text":"turns out that actually normally you can use wake one monk","width":295.18181824684143},{"text":"you can get the largest gong you can buy ebay and bash it like hell","width":374.18181824684143},{"text":"wake up all of them","width":171.18181824684143},{"text":"because maybe you want to wake up a lot of monks","width":133.18181824684143},{"text":"so that's a design decision. we'll see how we can do that in a little bit","width":296.18181824684143},{"text":"alright so that's the beginning of condition variables","width":155.18181824684143},{"text":"we'll let that simmer into your brain","width":128.18181824684143},{"text":"we'll come back to that in the second half","width":365.18181824684143},{"text":"because right now, hahaha. I've got some more critical section problems for you to look at","width":658.1818182468414},{"text":"I've written four potential solutions to the critical section","width":402.18181824684143},{"text":"and remember, what are we trying to do here? well, I've got some code here (my critical section stuff) that's only going to work if I've got one thread or one process at a time inside that code","width":863.1818182468414},{"text":"so I want to make sure that if I happen to have two threads or two processes attempting to get there, that one of them will lose","width":464.18181824684143},{"text":"one of them will have to wait until the first one has finished","width":350.18181824684143},{"text":"and remember, all code runs more than once","width":137.18181824684143},{"text":"so you can think of the critical section, for example, as using a data structure or updating a data structure. you don't want these two things to happen at the same time.","width":728.1818182468414},{"text":"I'm not quite sure how often this code is going to be called.","width":231.18181824684143},{"text":"but we do have our three desired properties. we want mutual exclusion so only one thread or process can enter the critical section at a time, bounded wait, and progress","width":725.1818182468414},{"text":"so, I've got some problems here, and this is where your neighbor comes in, because I'm going to ask you to actually evaluate these in terms of those properties","width":650.1818182468414},{"text":"and see whether they are good solutions to the critical section problem or not","width":430.18181824684143},{"text":"and I'm going to come around and answer any questions you might have","width":192.18181824684143},{"text":"[long pause]","width":17721.18181824684}]