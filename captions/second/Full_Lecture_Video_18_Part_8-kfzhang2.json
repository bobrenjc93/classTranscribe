[{"text":"","width":1295},{"text":"Constant amortized, right?","width":99},{"text":"Because I might run out of room.","width":289},{"text":"If I remove a specific key from an unsorted array,","width":231},{"text":"How long is that going to take me?","width":190},{"text":"O(n). I've got to find it first and foremost","width":160},{"text":"And then when I find it I've got to do a linear shift.","width":142},{"text":"So both of those operations take linear time, so it's like cn + kn which is just n.","width":448},{"text":"","width":64},{"text":"Okay, I want to find the element now.","width":192},{"text":"","width":24},{"text":"Still O(n). I still have to look through the whole array.","width":192},{"text":"It's not sorted. I have no idea where it's going to be.","width":64},{"text":"I can't use binary search because it's not in any particular order, so...","width":320},{"text":"That's order n.","width":192},{"text":"So I've made a trade-off here","width":128},{"text":"Between sorted and unsorted. Sorted has faster lookup times but slower insertion times","width":320},{"text":"Unsorted has fast insertion times, but really slow lookup times.","width":329},{"text":"Pretty much any time you're picking a different implementation you're making some kind of trade-off.","width":384},{"text":"","width":30},{"text":"","width":36},{"text":"What about a linked list?","width":192},{"text":"So...","width":184},{"text":"Let's insert a key-value pair into a linked list. How long is that going to take?","width":448},{"text":"","width":25},{"text":"Well, it sort of depends on what I mean.","width":128},{"text":"Am I going to sort this thing, or not?","width":128},{"text":"Let's say I'm not going to sort this.","width":128},{"text":"It's constant time. I can place it either at the front of the list or the back of the list, wherever is convenient, depending on the list implementation I've chosen.","width":448},{"text":"So...","width":94},{"text":"This can be constant time.","width":128},{"text":"If it's unsorted, how long does it take me to remove a key?","width":345},{"text":"Okay, I heard constant time, it could be constant time if I knew exactly where it was in the list.","width":322},{"text":"Like, if I was given an iterator to that position.","width":128},{"text":"But here I'm just being given the key.","width":128},{"text":"So I have to go find the node that contains the key.","width":128},{"text":"And then remove there.","width":128},{"text":"So finding it is going to take linear time, then the removal itself will take constant time.","width":320},{"text":"But I still have to figure out which node I'm removing, and I don't know ahead of time.","width":256},{"text":"","width":64},{"text":"Okay, and then for the same reason","width":192},{"text":"Find is linear, because I have to find it.","width":128},{"text":"","width":384},{"text":"Well, these both kind of suck.","width":192},{"text":"What about a binary tree?","width":128},{"text":"So I'm going to use a binary tree, and I'm going to insert a key-value pair","width":256},{"text":"into a binary tree. How long is that going to take me?","width":256},{"text":"","width":128},{"text":"Okay, any binary tree. Just an arbitrary binary tree.","width":256},{"text":"Constant time. I hear constant time. Why constant time? I agree, this is constant time.","width":384},{"text":"It's just an arbitrary binary tree. We're saying nothing about it at all. Just a binary tree.","width":384},{"text":"Where is it convenient to insert?","width":192},{"text":"The root.","width":64},{"text":"So, for inserting, you know, a new node into this structure, say, zero","width":384},{"text":"I can just go, okay... boom.","width":192},{"text":"There's my new tree.","width":64},{"text":"I didn't have to go down the height, I didn't have to traverse at all.","width":179},{"text":"I just took ownership of the old root as my right or my left or whatever","width":256},{"text":"and then set the root to be the new node, right, so that was constant time.","width":418},{"text":"Okay, what about remove? If I ask you to remove a certain key from this structure?","width":320},{"text":"It's a binary tree. Just an arbitrary binary tree.","width":256},{"text":"I hear log(n), I hear n...","width":320},{"text":"n. I agree with n. Why is it n?","width":320},{"text":"","width":83},{"text":"It's a traversal. I don't know where it is.","width":192},{"text":"Let's say that the numbers in here are the keys.","width":165},{"text":"Remove 7.","width":114},{"text":"You don't know where 7 is.","width":128},{"text":"You have to look for it.","width":64},{"text":"So in the worst case, you're going to look for a ","width":128},{"text":"you're going to traverse the whole tree looking for 7.","width":247},{"text":"So, removal is just a traversal, and then similarly, find","width":317},{"text":"I have to traverse. I have to look for it. I don't know where it is.","width":164},{"text":"So find is linear time.","width":197},{"text":"All of these suck!","width":127},{"text":"","width":107},{"text":"What the heck? Why are we learning about binary trees at all?","width":192},{"text":"So it turns out that we can do something","width":128},{"text":"We can look at a particular kind of binary tree.","width":256},{"text":"And we can make these running times significantly faster.","width":192},{"text":"The thing that was crippling us was just saying \"any old binary tree\".","width":256},{"text":"If I give you any old binary tree, you have no choice but to traverse for some of these things.","width":320},{"text":"If I tell you something about that binary tree, that it has some nice property","width":256},{"text":"Then we can do a little bit better.","width":128},{"text":"Yes.","width":64},{"text":"","width":64},{"text":"","width":260},{"text":"Oh yeah.","width":64},{"text":"","width":64},{"text":"","width":64},{"text":"If I inserted the next thing and I made it the right child of the root, and I inserted the next thing... You'd end up with a tree that looks like...","width":384},{"text":"","width":448},{"text":"We'll come back to that.","width":128},{"text":"","width":64},{"text":"So, when we start talking about this next data structure, we're going to talk about running times that are O(h)","width":384},{"text":"And we know that if we're not careful, O(h) looks like O(n).","width":256},{"text":"Because it's essentially a giant freaking linked list.","width":192},{"text":"With a dead null pointer on one side.","width":256},{"text":"Or, it could could look like this","width":128},{"text":"","width":128},{"text":"Which is equally bad.","width":192},{"text":"Right, so even if you try to get clever","width":64},{"text":"\"Oh, I'm going to alternate, I'm going to have an int in my tree, and I'm going to increment it and I'm going to alternate\" you still end up with something that looks like this.","width":512},{"text":"So you've got to be a little bit careful about the height, and we'll get to there sort of more towards the end of this week and next week.","width":512},{"text":"For now","width":128},{"text":"We're going to look at the very first thing that's going to help us.","width":192},{"text":"So the trees that we're looking for at the end are going to have several properties that we need.","width":256},{"text":"We're going to look at the first one for now, and think about that one for a while.","width":192},{"text":"And then we'll come back to figuring out this height problem in a bit.","width":128},{"text":"Yeah.","width":64},{"text":"","width":64},{"text":"","width":256},{"text":"That's the right idea.","width":128},{"text":"So we'll get there.","width":128},{"text":"That is exactly what we're going to do.","width":192},{"text":"Except for it's not the root, but we're going to insert somewhere and then ask the tree to balance itself.","width":384},{"text":"Then there's going to be clever algorithms for that to ensure that everything ends up being fast.","width":256},{"text":"","width":128},{"text":"So let's look at this tree.","width":192},{"text":"So here's a binary tree.","width":192},{"text":"","width":87},{"text":"What do you notice about this binary tree?","width":128},{"text":"","width":111},{"text":"It's not complete","width":128},{"text":"First and foremost, it's not like it's a heap","width":192},{"text":"","width":192},{"text":"It's a binary search tree. I haven't said that word yet. So what does that mean?","width":256},{"text":"","width":256},{"text":"","width":101},{"text":"Right.","width":64},{"text":"So this tree is ordered.","width":128},{"text":"We've talked about the ordering property in the lab.","width":192},{"text":"You did an isOrdered and you had a function, that, given this kind of tree, would have returned true.","width":320},{"text":"Right? And the constraint for the ordering property was that if you did an in-order traversal of this tree, you would get the elements in sorted order.","width":576},{"text":"So if you think about that, what that actually means is equivalent to saying ","width":256},{"text":"if you look at a node, if you look at any arbitrary subroot,","width":256},{"text":"all of the nodes that occur to its left ought to be smaller than it.","width":256},{"text":"And all of the nodes that occur to its right ought to be greater than it.","width":256},{"text":"So if you look at this tree, that's true everywhere.","width":192},{"text":"Everything to the left of the 14 is smaller, everything to the right of the 14 is bigger.","width":320},{"text":"Everything to the left of the 7 is smaller, everything to the right of the 7 is bigger.","width":192},{"text":"So this tree, if you look at this recursively, this tree is actually ordered.","width":320}]