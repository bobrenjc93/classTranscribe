[{"text":"Make it be a heap, right?","width":192},{"text":"I just give you a random array it's not a heap, so you better build a heap first. How long is that gonna take?","width":320},{"text":"Order n?","width":128},{"text":"Ok, so the algorithm idea is build a...","width":640},{"text":" and in this case... what kind of heap we're going to build will depend on what order we want the sort to take. Ok? ","width":512},{"text":"So we want the sort to be smallest numbers first, largest numbers last, we would want to build, in this case, a max heap. ","width":512},{"text":"We'll see why in a second. ","width":192},{"text":"If we want a largest numbers first, smallest numbers last, that's what we would get here since we made a min heap. ","width":320},{"text":"So depending on which order you want the number sorted, you’ve gotta make a heap with priorities flipped the other way around. ","width":576},{"text":"So if you want things smallest to largest, you’ve gotta make a max heap, which is sort of not too intuitive","width":320},{"text":". If you want things largest to smallest, you’re gonna make me a min heap.","width":192},{"text":". And we’ll see why its flipped in a sec. ","width":192},{"text":"So in this case, we’re gonna build a heap. ","width":192},{"text":". Again, thats an in-place algorithm. ","width":256},{"text":"you know that if I give you an array, you acan run the build heap algorithm on that array without allocating a new space. ","width":384},{"text":". So that’s fine. ","width":192},{"text":"So once we’ve got this heap, what are we gonna do to actually sort the elements? ","width":576},{"text":"So think about this case,here, I’ve made a min heap. ","width":256},{"text":"And I’m gonna use this min heap to sort the data so that its largest to smallest. ","width":256},{"text":"So I want the smallest thing in my data set, its the smallest thing in my heap, the smallest thing in the array, to end up at the back of the array. ","width":704},{"text":"The second smallest thing to be one before that, and the third smallest thing to be one before that. ","width":256},{"text":"If we draw that array that we’ve got here… ","width":384},{"text":"so it’s 4, 5, 6, 15, 9, 7 20, 16, 25, 14, 12, 11? Is that right? ","width":1856},{"text":"So that’s what our array looks like right now after we built the heap.","width":256},{"text":"Obviously this isn’t sorted, we’re not done .we hafta do more work","width":320},{"text":"It’d be a miracle fi we could just build the heap and it’d be sorted.","width":256},{"text":"And you’d win like the Turing award since you’ve proven something impossible. ","width":256},{"text":"So we’re not done, we still hafta do something.","width":384},{"text":"And I’m telling you that in this particular example I want to sort this particular array so that the largest elements come first. ","width":384},{"text":"So what could I do (using heap algorithms?)","width":256},{"text":"So what element do I sort of know the most about in this heap? ","width":1024},{"text":"The root, right? ","width":128},{"text":"Being the root of the heap tells you quite a bit about the elements that’s there. ","width":320},{"text":"It’s smaller than every single other element in the entire array. ","width":512},{"text":"How can I leverage that knowledge? ","width":128},{"text":"I need to swap it to the back cuz that’s where I want it to be, right? ","width":640},{"text":"If I want this array to be sorted from largest to smallest, and I know wehre the smallest element is (it’s the root of the heap) I can just move it to back where I want it.","width":640},{"text":"The difference here is where we’d ordinarily do a pop on a heap, we’d swap it to the back and also call pop back on the vector to get rid of it. ","width":576},{"text":"We’re not gonna get rid of it here. We want to keep it around. ","width":192},{"text":"So we’re gonna swap to the back and instaed of doing a pop back, decrement an index. ","width":384},{"text":"The index is gonna tell us where we’re pretending where the end of the heap is, even though we know the array has more stuff in it. ","width":448},{"text":"So we’re gonna start the algorithm off like this, where, that index is gonna steel us where the end of the heap in the array. ","width":576},{"text":"Now we’re gonna do a pop, with this modified pop algorithm . ","width":384},{"text":"Doing a pop, what’s that gonna do? ","width":128},{"text":"We know that it swaps with the back of the array so that it’s easy to remove, but now we’re not gonna remove it. ","width":512},{"text":"So we do the swap, which means that the array pictured is like this. ","width":576},{"text":"And then instead of popping the back to get rid of the element, we’re just gonna decrement our index. ","width":320},{"text":"So we’re just gonna say ok. Our heap on only exists up to the 12. So for our algorithm that has the same effect as doing this. Ok?","width":640},{"text":"If we modify our algorithm so that they instead of saying back.size() they look at our size_ variable.","width":576},{"text":"Now they don’t have to care about the fact that there’s elements that come after the elements in the array, they just care about what the elements are from 0 up until that index, or 1 up until that index depending on what you did.  ","width":576},{"text":"And then we gotta finish this up, we’re not done, so we gotta move.Heapfiy down the 11 to the appropriate spot so that’s gonna swap it with the 5, ","width":960},{"text":"and then swap that with the 9 and then we’re done, right?","width":512},{"text":"Ok, so we end up with this being 5, this being 9, 15, 11, after we do all those swaps that’s the picture we end up with","width":1088},{"text":". I don’t think I’ve screwed up, I think its fine. ","width":256},{"text":"Alright, so now what? ","width":320},{"text":"Oh we know we got the smallest element at the back, so now we care about the second smallest element! Where is the second smallest element now","width":704},{"text":"? It’s the root? ","width":256},{"text":"Notice that every single time we do this we’re gonna get the next smallest element at the root, by design. That’s what the heap is for! That’s why this works as a priority queue. It always moves up the smallest thing, or the largest thing, depending on the priority that you’ve chosen. To the root. ","width":896},{"text":"So if I keep doing this iteratively, I’m gonna keep putting the smallest thing at the last unset element in my array and keep decrementing the size.","width":640},{"text":"You keep doing this until you run out of space","width":192},{"text":". So in this case I’m donna remove the 5, which will swap with the 12, ok so the 5 is gonna go there, the 12 is gonna go here. And then I decrement my index. ","width":1024},{"text":"So now notice that this part of the array… WHOA  ….notice that his part of the array is in fact sorted . and in descending order.","width":640},{"text":"Right? The part of the array that is no longer part of our heap will end up always being sort in descending order if we use a min heap. ","width":576},{"text":"The reason being, we’re always taking the smallest thing and moving it to the back. So we’re gonna start with smallest thing, second smallest thing, third smallest ,fourth smallest thing and eventually add all elements. And then we’re done. ","width":832},{"text":"When our heap no longer contains anything, we can’t pop anything out of it so we just stop. ","width":256},{"text":"So this will continue following this process, where you know I just keep calling heapfiy down, so that’s actually 12, so that’s gonna swap with the 6","width":704}]