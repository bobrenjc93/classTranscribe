[{"text":"add in the size from the other root that I'm making to be a child, and then update the child to point at me.","width":1229},{"text":"Alright? Update the size, update the pointer, and we're done.","width":335},{"text":"Okay?","width":124},{"text":"And so then what about the other case?","width":569},{"text":"Yeah. Sort of the reverse of the same thing I just did. Right?","width":193},{"text":"So if the array at root 2 is smaller than the array at root 1,","width":611},{"text":"then I know root 2 should become the new root, because that has more things in it.","width":260},{"text":"The goal here's to increase the depth of the fewest number of things,","width":180},{"text":"so I wanna make the set that got the smallest number of things in it be the child.","width":357},{"text":"And the thing that's got more things is to stay the root.","width":164},{"text":"Yeah?","width":151},{"text":"If they're equal, we have to tie break somehow","width":120},{"text":"I don't remember the how the mp has you tie break.","width":170},{"text":"It'll say explicitly what you're supposed to do if they're equal.","width":243},{"text":"In this case it'll always go down this else branch, the way I have written it.","width":198},{"text":"But I could do, you know, less than or equal to, and then it uses the first branch.","width":182},{"text":"So just... However you wanna tie break this is fine. It doesn't actually matter.","width":355},{"text":"Okay, and so in this other case it's just gonna look exactly the same","width":374},{"text":"except for I'm using root 2 to be the root, so I have to add in","width":389},{"text":"the size of root 1 into it, and then update","width":695},{"text":"update root 1 to point at root 2.","width":592},{"text":"Yeah I might wanna check to see if that I'm not merging together these two things.","width":493},{"text":"So I can easily add that. You know, right there.","width":198},{"text":"It's just if root 1 == root 2, return or something.","width":1243},{"text":"The difference there is actually not gonna be in how you compare?","width":725},{"text":"It's gonna be in how you update.","width":178},{"text":"Right. In either case I wanna make the new root be the element that stores the smallest number,","width":320},{"text":"because in union by height I wanna make the root be the tree that's taller","width":279},{"text":"which is gonna have the smaller number.","width":100},{"text":"So the only difference is how you do the updating.","width":128},{"text":"You have to be careful when you're doing union by height to make sure that you're ranks are being updated appropriately only when you increase","width":531},{"text":"Alright, whereas if you're doing by size, you always increase the size after a merge.","width":276},{"text":"So the thing you would want to customize is, what you do here.","width":406},{"text":"and there, and that sort of gonna depend on what the values are.","width":540},{"text":"I mean you could probably do that.","width":228},{"text":"But this code is so short that it's probably easier to just write a separate class that pass it.","width":432},{"text":"These are the only two functions really that you need,","width":224},{"text":"so the whole class is like, 5 lines, 10 lines maybe.","width":1182},{"text":"I'm not gonna prove it. I'm not gonna prove it.","width":308},{"text":"It's just, I'm not gonna prove it. It just is.","width":217},{"text":"If you're curious go look up the papers for it.","width":135},{"text":"I'm gonna show something better in like 3 seconds and then it's,","width":192},{"text":"and that is definitely beyond our scope of proving,","width":150},{"text":"so it's just not worth it to prove.","width":166},{"text":"The running time is actually better than log n.","width":173},{"text":"We have to do one little trick, but it's better than log n.","width":142},{"text":"So I'm not even gonna bother proving that statement.","width":334},{"text":"Okay, so this is fine. This gives us sort of logarithmic heights,","width":369},{"text":"and that was shown quite sometime ago.","width":346},{"text":"But it turns out you can be a little bit more clever if you allow your find operation actually change the ","width":417},{"text":"set structure.","width":263},{"text":"Okay? So before find was looking at stuff and not modifying anything.","width":206},{"text":"We're gonna change find, so that we can actually modify the up tree while we're finding the root.","width":436},{"text":"of a particular element.","width":81},{"text":"Why might we want to do that?","width":473},{"text":"Is it gonna help us on this particular find?","width":336},{"text":"No.","width":139},{"text":"But it might help us on future finds, right?","width":243},{"text":"So the intuition here is once we get the results for our find call,","width":332},{"text":"we know every single thing we visited along the way, ought to just point directly at that root, right?","width":432},{"text":"I mean, look at this up tree up here, right?","width":335},{"text":"If I do a find on 11, we know that once we get all the way up to 4,","width":451},{"text":"11 should point directly at 4.","width":151},{"text":"Also 5 should point directly at 4.","width":161},{"text":"Also 10 should point directly at 4. It already does.","width":263},{"text":"But sort of everything along the path that we took to get to the root,","width":275},{"text":"we can update to point at the actually root node there.","width":208},{"text":"So that we never have, you know, structures that look like this for very long.","width":320},{"text":"Like as soon as somebody does a find, it's gonna change this tree","width":280},{"text":"if somebody did a find of 11, we would change this tree to look like","width":576},{"text":"this immediately, which is sort of the best case tree.","width":384},{"text":"Alright?","width":128},{"text":"Yes.","width":1344},{"text":"So I'm not loosing any information. The reason for that is the thing that I'm using to represent every element in this structure is the root of the tree it's in.","width":704},{"text":"So changing the parent nodes of thing is fine as long as they're still pointing at the root that they actually belong to.","width":602},{"text":"Alright? So if I jump the gap between 5 and like to make 5 not point at 10 anymore but to make 5 point at 4,","width":448},{"text":"I still haven't changed the result of what find of 4 would give me.","width":263},{"text":"Alright? Remember the only things I can do on this, are find me the root for this id, and merge the sets for these two id's together.","width":547},{"text":"That's all I can do.","width":128}]