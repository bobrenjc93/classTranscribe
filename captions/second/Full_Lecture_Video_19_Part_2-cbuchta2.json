[{"text":"[silence]","width":512},{"text":"Is this public function recursive? Why or Why not? ","width":448},{"text":"Yeah? [student answers]","width":384},{"text":"Something has to be recursive here, so thats certainly true. Because you have to do some kind of modified traversal to find the element. So something here will be recursive.","width":512},{"text":"The question is: is it the public function thats recursive. ","width":320},{"text":"It cant be, and its not because its const. ","width":320},{"text":"What node am i at?","width":256},{"text":"I have no way of keeping track of where i am. That function cant be the recursive one. I have no notion of what the current node is.","width":512},{"text":"If this at function was recursive. How do i stop? Well the only thing its taking is a K ref. So if im passing the same key the whole time, its just going to recurse forever.","width":896},{"text":"How would i call that? \"At(key)\"? Well thats the same function that im already in. Theres no way for this to terminate. So the at function here as written cannot be recursive.","width":896},{"text":"What were going to do is what we were doing for the list classes as well when we were writing this recursive functions. Were gonna write a recursive helper function.","width":576},{"text":"So the helper function is gonna be whats recursive here. But the at function itself will not be.","width":384},{"text":"Theres no way for me to check for a base case.","width":256},{"text":"Dont know what node im at, the only node i have access to here is root, and thats never going to change. ","width":448},{"text":"The at function cant be recursive here. ","width":256},{"text":"So im going to call a private helper function to implement the recursion. Why do i know that its private?","width":640},{"text":"Im gonna be dealing with nodes, one of my parameters is probably going to be a node* at which point it certainly cant be public anymore since nobody outside of this class knows about node stars.","width":704},{"text":"Alright, the dictionary could be anything it doesnt have to have nodes in it. Nobody knows what a node is, so they cant call functions that take nodes.","width":384},{"text":"So this helper function is definitely going to be private. ","width":256},{"text":"The call probably looks something like this: Im gonna call the helper function \"find\" i could have called it \"at\" as well. It doesnt really change anything im just going to call it \"find\" to be clear which ones the public which ones the private.","width":640},{"text":"Im going to call it \"find\" im gonna start at the root.","width":512},{"text":"And im looking for...that particular key. ","width":512},{"text":"So this find function is going to be my recursive helper function. Its going to return to me the value that it finds for thee associated key if ones exists. And if one doesnt it should throw an exception.","width":1216},{"text":"Okay, so lets implement this. Whats the signature gonna look like? Whats the first thing im going to write here? Template. ","width":704},{"text":"Template class K class V ","width":448},{"text":"okay","width":64},{"text":"Fine, so now on the actual signature part of it. So what, what is this function returning?","width":448},{"text":"Some kind of value, so based on this signature weve got here, it should probably be a const V ref.","width":896},{"text":"[silence]","width":192},{"text":"Alright next, \"bst\" good, so i have to scope it. ","width":960},{"text":"\"bst<K,V>::find\" Whats my first argument gonna be? Some kind of node*.","width":448},{"text":"It looks like this particular find function doesnt modify the tree so i should probably have it be a const node* So i promise that i wont change the nodes themselves. I just look at them. ","width":576},{"text":"So im going to take a const node* subroot.","width":640},{"text":"Okay and then whats my other argument? \"Key\", so a const K ref. ","width":960},{"text":"Am i done writing the signature? No, i need to mark this const. ","width":448},{"text":"Why do i need to mark it const? [fields answer from class]","width":576},{"text":"Okay, so thats true, why do i need to tell the compiler that this function wont modify the tree? Because im calling it form a cosnt function.","width":768},{"text":"Here im calling find inside of a function thats marked const. So if the helper function is not also const. Im not allowed to call it.","width":640},{"text":"Because ive promised inside that at function that i wont modify the tree, so if i call a  function that can modify the tree i just squeezed my way out of the contract which is not allowed.","width":640},{"text":"So the compiler will enforce that if youre inside of a const function, you can only call other const functions. So my find function had better be const because my at function is const.","width":1024},{"text":"So thats my signature.","width":128},{"text":"So in what case do i throw the exception? ","width":448},{"text":"Not subroot, if i cant find it. I know whats gonna happen here is im gonna recurse, recurse, recurse, recurse, recurse, and eventually im going to have an empty tree. If i have an empty tree i cant find anything in the empty tree. So theres no possible way i can return to you a valid const v ref.","width":1216},{"text":"Because theres nothing so i should throw the exception. So in this case i should throw the exception when: \"not subroot\".","width":512}]