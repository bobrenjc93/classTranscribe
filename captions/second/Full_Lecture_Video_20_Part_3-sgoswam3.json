[{"text":"pass it in as a node pointer.","width":766},{"text":"You still need some way of like you don't have a way of modifying that pointer directly anymore.","width":463},{"text":"SO by just passing a node* subroot. If later on like remove node i say subroot = some other tree..","width":521},{"text":"I am no longer changing the pointer in the tree itself anymore.","width":512},{"text":"Alright so the reason I am passing it by references so that when I refer to subroot I am actually referring directly to some existing pointer in the tree.","width":421},{"text":"If I just pass a node* down that can't refer to any pointer in tree because all the pointers in the tree are unique pointers","width":687},{"text":"Okay so then you'd need the if you wanted to change the pointer pointing at the given node, you would need a pointer to the parent node now","width":1015},{"text":"If you just have a pointer to the node that you want to remove, you have no way of modifying the parent right when you remove that node what you want to do is actually change the parent right.","width":674},{"text":"If I have go this picture right here and I want to remove the 9, what I really need to change is 11.","width":433},{"text":"So really if you are gonna do it that way you need to pass a pointer to the parent and not to the child you want to remove.","width":509},{"text":"So you could do it that way, it's just a little bit more complicated.","width":245},{"text":"Cause now you have to... your recursion can't stop when you find it it has to stop when you get to the parent that contains it.","width":485},{"text":"So at every step you'd have to be like looking at the left child instead of the actual subroot.","width":417},{"text":"So I do it this way so that I can actually have my base case just be I found the node and now I have got a handy reference to the pointer that I want to to change which is actually the pointer in the parent.","width":879},{"text":"That makes sense?","width":239},{"text":"That is a very good question","width":109},{"text":"It's important to understand why why it is that we are passing by reference here. Yes","width":756},{"text":"Ummmm ok so it is O(h)","width":168},{"text":"If I am able to argue that h is O(logn) then yes you are right if I can't argue that h is logn then it might have been something worse.","width":503},{"text":"For NOW it's definitely O(h) and then we are gonna come back to how we how can we guarantee that the height is nice.","width":747},{"text":"Okay I am gonna scroll down now","width":320},{"text":"Okay, we are finally good. So we have written the code now that does this process of locating the node that we wish to remove. SO if we run that function above on this tree, on root and 9 so we start at the root, we wanna remove the node containing 9 we would do this process we would stop at 50 we would stop at 17 and we would stop at 12 and then we are stopping at 9.","width":1705},{"text":"We have actually located it now so we are going to call remove node on the 9 and what I mean by that is that we are calling it on this pointer here.","width":946},{"text":"Cause if I want to remove the 9 I ought to really be changing the left pointer of the 12. SO I am passing the left pointer of the 12 into the remove node functions. SO that I can change it.","width":1059},{"text":"For this case, what should remove node do?","width":300},{"text":"Yeah","width":427},{"text":"Allright so we need to... if we wanna remove the 9 from this tree all we really have to do is get rid of that node. There is no subtrees to worry about.","width":622},{"text":"So we don't have to worry about you know making sure that the ordering property is still satisfied when we remove the node of some tree. it has no children. So this is a no child remove case.","width":599},{"text":"So in that case all I need to have true at the end of that function is that the left pointer of the 12 is null and I didn't leak the 9.","width":597},{"text":"I would need to delete the node 9 itself okay.","width":463},{"text":"SO fine we'll see how to do that in a sec. We will see how to do that in a sec we will write the code for that ok.","width":293},{"text":"Sooo ok fine so what about another case. What about if we want to remove the 23?","width":427},{"text":"Which nodes are visited when I ask you to remove the 23?","width":376},{"text":"50 17 23","width":332},{"text":"23 is smaller than the 50, so I go left the 23 is larger than the 17 so I go right. 23=23 so I stop at this node and I call remove node on the 23 and again what I mean by that is calling it on this pointer of the 17","width":1011},{"text":"Right the right child of the 17 so that I can change what the right child of the 17 is after I do the removal.","width":492},{"text":"What should happen now. So this is no longer a no child remove..this is a one child remove. So what do you do if the node that you have been asked to remove has one child?","width":945},{"text":"Right you jump the pointer to your child instead of to you. okay","width":383},{"text":"I am going to adjust subroot, to instead of pointing at where it currently points to point at subroots left in this case","width":479},{"text":"Or if the child happened to be on the right it would point at subroot's right","width":355},{"text":"So pictorially is what I am gonna have here is that this pointer is changing to here and this node is being deleted.","width":613},{"text":"And this works regardless of how complicated the picture below it might be like I might have arbitrary binary search trees that are below the 19 on either side and the process is exactly the same by virtue of that subtree existing in the tree that is to the right of the 17 I know that everything in there has to be bigger than the 17 so its fine to just move that tree up.","width":1521},{"text":"Because the ordering property had to have been satiesfied before the removal","width":327},{"text":"We are guaranteed that every time we do an operation we are still gonna have the ordering property. SO I can abuse that fact in everything I am doing now. So if I know that the ordering property is already satisfied then I don't need to do any more work and all I have to do is to move that tree up into the position where my old node used to be so I am getting rid of subroot and I am replacing it with either subroots left if that's the non null child or the subroot's right if that's the non null child.","width":1600},{"text":"That moves that whole subtree up","width":266},{"text":"Intuitively does that make sense? We will write the code for it today.","width":384}]