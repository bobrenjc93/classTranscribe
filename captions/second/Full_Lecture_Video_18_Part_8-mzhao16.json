[{"text":"so, good thought, so, okay, any question about the sorted array?","width":64},{"text":"constant amorted, right, because I can run out of room, if I remove a specfic key from an unsorted array, so how long it will take me","width":1408},{"text":"o(n), i am gonna to find it first, and when i find it I need to linear shift, so both of the operating will take me a linear time, so it's like cn plus kn , just it's just n ","width":1600},{"text":"ok, i want to find the element now, still o(n), i still need to look the whole of array, i can't use binary search , cuz it doesn't have any order, so it's O of n","width":896},{"text":"so let's trade of here, right, between sorted and unsorted, sorted has faster look-up time but slower inserting times. Unsorted has faster inserting time but really slow look-up times, right","width":704},{"text":"so, pretty much anytime you're picking a different implement, you are making a different trade-off","width":384},{"text":"ok, what about a linked list, so ","width":512},{"text":"let's insert a key-value pair into a linkedlist, how long it going to take","width":512},{"text":"it sort depends on what i mean, i am gonna to sorted the thing or not, let's say, i am not gonna to sort this","width":320},{"text":"it's constant time, since I can emplace it at the front of the linkedlist or the back of the linkedlist for its convenience, depends on the linkedlist's implement you choose","width":448},{"text":"so, this can be constant time.This unsorted linkedlist, how long it will take me to remove a key","width":448},{"text":"ok, i hear constant time. it could be constant time if i knew exactely where was in the list. like if i give a iterator for that position.","width":576},{"text":"but here i'm just been giving the key, so i have to go to find the node contains the key , and then remove there. So finding it is gonna take linear time.","width":576},{"text":"Then the remove itself will take constant time.But it still need to figure out which node,  i am removing. I don't know at time.","width":512},{"text":"ok, for the same reason, finding is linear, cuz I have to find it, right","width":448},{"text":"ok, fine, well. The both kind of suck, what about a binary tree, ","width":640},{"text":"so i am using a binary tree, and insert a key-value pair, into a binary tree, how long it will take me?","width":576},{"text":"ok, any binary tree, arbitrary binary tree, constant time... i hear constant time, why constant time. I agree, this is constant time.","width":704},{"text":"just arbitrary a binary tree.  we say nothing at all. just a binary tree. where it's convenient to insert? ","width":512},{"text":"root! ok, so inserting you know, a new node in this structure , say zero, i can just go, ok, boom ","width":576},{"text":"this is my new tree, right. And I have to go down the height to traverse at all, i just","width":384},{"text":"to got the ownership of my old root as my left or right, or whatever. and then set the root to be the new node. so that will be constant time","width":512},{"text":"ok, what about remove. so if i ask you to remove a certain key from this structure, it's a binary tree, just a arbitrary binary tree","width":576},{"text":"log(n), i hear n... n? i agree with n, why it's n","width":896},{"text":"it's traverse, i don't know where it is. let's say, the numbers heres of keys, remove seven, you don't know where seven is, so you should look for it.","width":640},{"text":"so the worse case you'll gonna to look for a... you gonna to traverse the whole tree to look for seven ","width":320},{"text":"so, removing is for traverse, similarly for find, i have to traverse, i need to look for it, i don't know where it is. So finding, is linear time. All of this suck","width":832},{"text":"what's the hell? why we learn binary tree at all. so it turns out that we can do something, i can look at a particular kind of binary tree. and we can make the running time significant faster.","width":832},{"text":"the thing bothering us was just saying, any old binary tree, if i give you any old binary tree, you have no choices but to traverse for some base things","width":640},{"text":"if i tell you something about the binary tree, i has to have some nice properties,then we could do it better","width":320},{"text":"yes, oh ,yeah","width":704},{"text":"if i insert the next thing, i make the right child as the node like the next thing,you end up the tree looks like","width":576},{"text":"we will come back to that. ok, so when we talk about the next data structure, we'll gonna talk about the running time of big O of h, ","width":832},{"text":"and we know, that we are not careful about big o of h, it looks like big o of n. because it finally free linkedlist ","width":448},{"text":"right, the dad of no pointers on one side, or it could look like this, ","width":512},{"text":"it's equal to the bad, you need to try to  get clever,  i am gonna to alternate. i am gonna to insert in my tree. I  am gonna to increment. i am gonna to alternative. so it will end up like this","width":704},{"text":"so we got to be carefully about the height, how to get there, sort of how to mortes the end of this weight and next weight","width":512},{"text":"for now, we're gonna look up this first thing that helps us. so the tree we are looking for in the end will have several properties that what we need. We'll look up the first one for  now. and think about that one for a while. And then we will come back to figure out this height problem.","width":1088},{"text":"that's the right idea. so we will get there. that's actually what we are going to do..","width":704},{"text":"it's not the root, we will insert somewhere, and ask the tree to about sort, it could be a clever algorithm for insurancing everything go fast.","width":640},{"text":"ok...so let's go to look at this tree. here is the binary tree. what we know about this binary tree","width":768},{"text":"it's not complete. so, it's not like a heap","width":640},{"text":"it's a binary search tree. i haven't say about that word yet, so what does that means?","width":256},{"text":"","width":64},{"text":"right, so this tree is order, we talk about order in lab, rgiht, you did. in order, you have a function that gave this kind of tree, it will return true.and ","width":1152},{"text":"the consideration for the in-ordered property is that  if you did in-order traverse of the tree, you will get the elements in a sorted order.","width":448},{"text":"so if you think about that, so what that actually means, is equivalent to say if you look at a node, any arbitrary subroot, ","width":576},{"text":"all of the nodes accure on the left is smaller than it , and all of the nods occure on the right is bigger than it ","width":576},{"text":"so if you look at the tree, it's true everywhere. everything  on the left is smaller than 14,  and everything on the right is bigger than 14. everything on the left of 7 is smaller, and everything on the right of 7 is bigger.","width":640},{"text":"right, so this tree, if you do, if you look at the tree recursively, this tree is acturally in-ordered","width":320}]