[{"text":"okay, right, so, now, this is where you come in","width":425.18181824684143},{"text":"remember how I said, OSX doesn't implement semaphores? well guess what, it's your lucky day!","width":294.18181824684143},{"text":"you are at Apple and in the afternoon, they accidentally left you access to the source code so you decided to actually implement sem_wait(), sem_post() ecetera for Apple so we can actually get these things working","width":988.1818182468414},{"text":"alright, and we can use condition variables. condition variables are more general, they're more powerful than semaphores because we get to write any condition that we want inside the little while loop","width":671.1818182468414},{"text":"so, how would you write these things? okay, how do we implement our semaphores?","width":427.18181824684143},{"text":"okay, so what do we need inside our semaphore?","width":255.18181824684143},{"text":"well, we need some sort of count","width":209.18181824684143},{"text":"to remember when that count gets to zero, then our sem_wait will wait","width":324.18181824684143},{"text":"and presumably, we also need some sort of pthread_mutex_lock","width":372.18181824684143},{"text":"there we go. and we'll have a pthread_cond variable","width":549.1818182468414},{"text":"there we go","width":244.18181824684143},{"text":"so with both things inside our semaphore, now we can figure out how to write sem_wait() and sem_post()","width":1894.1818182468414},{"text":"so, what's the first thing we should do inside sem_wait?","width":459.18181824684143},{"text":"we're going to be accessing our count variable so before we do that, we want to make sure that we have sole access. exclusive access to it. alright. so what should we call first?","width":778.1818182468414},{"text":"yes! let's lock our mutex","width":123.18181824684143},{"text":"alright, so, pthread_mutex_lock, and passed in a pointer to that structure so we'll do s, get the lock","width":779.1818182468414},{"text":"um, we'll make these little pointers just for speed today. right, and at the very end, we are gonna unlock stuff as well","width":1061.1818182468414},{"text":"so, when did we need to actually meditate? when did we actually need to pause?","width":508.18181824684143},{"text":"so if the count is zero, then let's send this monk to sleep. let's send this thread to sleep. so now we can call pthread_cond_wait","width":1302.1818182468414},{"text":"and you'd pass in a pointer to the condition variable and a pointer to the mutex","width":454.18181824684143},{"text":"and remember, that does three things for you. it unlocks the mutex, sleeps on the condition variable, and when eventually where it wakes up from that meditation, it's going to relock the mutex before returning","width":1088.1818182468414},{"text":"so one way to look at this code is that inside this code, at all times, the mutex lock is actually locked in terms of the code that we writing. in terms of say, checking this count.","width":557.1818182468414},{"text":"we know that that mutex lock is always locked","width":197.18181824684143},{"text":"it's only if it actually goes to sleep inside this cond_wait will the mutex lock become unlocked","width":575.1818182468414},{"text":"alright so, we get around there. and the last thing we need to do in our wait call is to reduce the count","width":520.1818182468414},{"text":"so, in our count structure, reduce it","width":615.1818182468414},{"text":"what would happen if two threads called sem_wait at the same time? doesn't matter. our lock would ensure that only one of them wins.","width":399.18181824684143},{"text":"that only one of them executes at a time","width":182.18181824684143},{"text":"so maybe the first thread will successfully call sem_wait() and continue. the second thread, though, calling sem_wait() might see the count value zero and then it's forced to meditate","width":702.1818182468414},{"text":"alright, what about our post? our post is not going to do any sleeping.","width":560.1818182468414},{"text":"it will increment the count","width":308.18181824684143},{"text":"okay, oh! look at that! I've touched part of the structure. I better make sure that what?","width":431.18181824684143},{"text":"what should I have done first?","width":123.18181824684143},{"text":"get the lock! yes.","width":95.18181824684143},{"text":"okay, so pthread_mutex_lock() and pass in a pointer to the lock that everyone's playing with","width":415.18181824684143},{"text":"there we go","width":189.18181824684143},{"text":"so now I know when I get back from this that I've got exclusive access to this data structure because all the code I'm writing always locks the same lock","width":811.1818182468414},{"text":"and now, I can call pthread_cond_signal()","width":811.1818182468414},{"text":"on the condition variable","width":236.18181824684143},{"text":"and finally, unlock the mutex. so this code would work","width":469.18181824684143},{"text":"but we can do a little bit better","width":263.18181824684143},{"text":"which is that our post is always asking the operating system to find a sleeping monk and ring the bell","width":505.18181824684143},{"text":"and, we could do a little bit better reasoning about this, we can say well hold on, the only time that there could be a sleeping monk is if the count is actually already been reduced to zero","width":761.1818182468414},{"text":"so if I've just incremented the count, then I'm going to wake up one monk","width":423.18181824684143},{"text":"so if the count has just been incremented to one, now I know that I should try to wake up a monk. if there happens to be no monks waiting, doesn't matter. that's okay, that's not my problem","width":1020.1818182468414},{"text":"but for the other times, if count says greater than one, then there can't have been any monks waiting. there's only going to be monks waiting if we've reduced the count down to one.","width":803.1818182468414},{"text":"alright and in here we write the standard code to initialize our mutex lock and our condition variable","width":415.18181824684143},{"text":"okay, and with that, we're out of time! I will see you on wednesday and you will have a quiz on friday! more about that on wednesday","width":554.1818182468414},{"text":"a reminder that malloc part 1 is due today","width":340.18181824684143},{"text":"come down and, it is isn't it?","width":271.18181824684143},{"text":"come down and see me if you have any questions! welcome to condition variables","width":348.18181824684143}]