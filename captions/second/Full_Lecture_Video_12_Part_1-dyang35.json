[{"text":"Ok, does any body have a nice definition of amortized analysis for me, they wanna share?","width":1472},{"text":"What is amortized analysis, what does it involve?","width":704},{"text":"What is amortize analysis, what is that you spent 15 minutes watching?","width":320},{"text":"what was the point of that?","width":64},{"text":"What was I doing?","width":256},{"text":"Yeah, I wanted to come up with the running time of a particular operation, right?","width":320},{"text":"The problem was that the running time of that operation, drastically varied","width":320},{"text":"depending on the state of the structure that I was operating on, right?","width":192},{"text":"Incrementing that counter, sometimes I only have to flip a single bit","width":192},{"text":"and other times I have to go all the way to the most significant bit","width":192},{"text":"and flip that, right?","width":64},{"text":"flipping bits the entire way","width":128},{"text":"So sometimes I have to do a whole bunch of stuff, and sometimes I only have to do very very little","width":320},{"text":"And the result is though, the ratio of those really long operations to the really short operations","width":448},{"text":"would be enough that, maybe this is faster on average than the worst case would suggest","width":384},{"text":"The worst case for that algorithm was flipping every single bit that's been set in the current value of the counter","width":448},{"text":"So flipping logarithmic number of bits ","width":128},{"text":"That would be the worst case, but we thought that sometimes that's not true","width":192},{"text":"sometimes you only have to flip the least significant bit if it happened to be a zero there","width":320},{"text":"So amortized analysis","width":192},{"text":"instead tries to look at what's an average running time for this function","width":256},{"text":"On average, or on expectation, how long should I expect this operation to take","width":320},{"text":"how long should I expect incrementing a binary counter to take","width":128},{"text":"Sometimes it will take a long time and sometimes it will take a short time","width":192},{"text":"but on average how long does it take","width":128},{"text":"that's the question that we're trying to answer","width":128},{"text":"Okay","width":64},{"text":"Why is it useful?","width":192},{"text":"So why do we care about that?","width":192},{"text":"how long we expect something to take rather than what is the worst case for that operation?","width":320},{"text":"So to be more accurate","width":192},{"text":"If you model it as, what's the worst case operation time","width":320},{"text":"and you treat that as the running time of every single operation that you're doing","width":256},{"text":"the you're gonna to be very pessimistic, you're gonna be right","width":192},{"text":"'cos it's big O","width":64},{"text":"but you're gonna be very very pessimistic, you can have a much tighter bound","width":192},{"text":"if you thought about, well, on average how long is it taking?","width":192},{"text":"How long should I expect this operation to take?","width":192},{"text":"Rather than, what's the absolute worst case scenario possibility that this operation might take","width":320},{"text":"even if it happens, once in a blue moon","width":192},{"text":"If you assume that, if you take the worst case stand","width":192},{"text":"then you're gonna have a running time that's bigger than what it may actually be in practice","width":256},{"text":"So amortized analysis let you have a little bit of a tighter bound","width":320},{"text":"In particular you apply it to situations where each operation sort of has a","width":384},{"text":"maybe one or two different classes of how long it takes","width":192},{"text":"sometimes it","width":64},{"text":"is really really fast, and every once in a while, there's one that really sucks","width":256},{"text":"But the one that really sucks doesn't happen all that often","width":256},{"text":"So maybe the fact of these operations, most of the time they're really really fast","width":320},{"text":"can make up of the fact that every once in a while we have something that takes really long time","width":320},{"text":"We will use this technique when we're looking at, removing","width":320},{"text":"hmm... this assumption","width":384},{"text":"We're gonna make that assumption for now when we're doing that analysis","width":128},{"text":"but we're gonna then remove that assumption then talk about how we analyze the situation where","width":320},{"text":"this thing has to fill up","width":64},{"text":"and we have to, necessarily make more room for new elements, okay","width":320},{"text":"And amortized analysis is gonna let us have a little bit of a better bound on that","width":256},{"text":"than the worst case analysis would've suggested","width":192},{"text":"Alright","width":128},{"text":"Okay so what is amortized analysis","width":128},{"text":"looking at x expectations, or looking at","width":256},{"text":"the average running time of a particular operation","width":256},{"text":"There are several ways of doing it, one way of doing it would be looking at","width":1024},{"text":"look at the running time for n different operations, and then divide by n","width":320},{"text":"to get an average, what is the average case of one of these operations ","width":256},{"text":"And if you have the case where we have a bunch of really really cheap ones and one really really expensive one","width":320},{"text":"averaging it out could result in, you just see the average case is really really cheap","width":320},{"text":"Every once in a while you pay a cost, but","width":64},{"text":"on average it's ok","width":128},{"text":"So looking at the running time for n operations, ","width":192},{"text":"divide it by n","width":320},{"text":"Fundamentally that's what we're gonna be doing, we're going to look at how long it takes to do n things","width":192},{"text":"and then divide by n, the number of things we did","width":256},{"text":"Okay then, and this is useful","width":1024},{"text":"inconsistent runtimes","width":320},{"text":"thing that are cheap, cheap, cheap...","width":128},{"text":"really expensive, cheap cheap cheap cheap...","width":192},{"text":"really expensive, right","width":128},{"text":"Because if you look at, blocks of n of that sequence, it's actually not that expensive","width":448},{"text":"Amortization is not purely an algorithmic thing, it's used in a lot if finance","width":448},{"text":"you amortize on payments or something","width":192},{"text":"you can amortize the cost of that over this many month or whatever","width":192},{"text":"But really you're still paying that fixed cost up front, it's not something that","width":256},{"text":"it's not something you actually pay over each of the months, but...","width":192},{"text":"amortization is a thing that's beyond just algorithm analysis","width":256},{"text":"But it's useful here for the same reasons","width":256},{"text":"Okay","width":128},{"text":"Let's revisit our lists","width":128},{"text":"let's finish off this table that we were starting last time","width":256},{"text":"I'm gonna fill in from scratch again just so we can review the first part","width":256},{"text":"We're looking at our different choices for implementations of a list ADT, so we have a list class","width":448},{"text":"and we have 3 choices for implementation of the internal data storage for this list class","width":448},{"text":"one is the singly linked list","width":128},{"text":"where you have a recursive node structure, each node points at the next node, right","width":384},{"text":"You have a doubly linked list, where you have","width":128},{"text":"again a recursive node structure, but each node points at both the next and the one that came before","width":384},{"text":"so you have links in both directions instead of only one direction","width":256},{"text":"and a vector","width":64},{"text":"so a vector is a","width":128},{"text":"an array-based implementation, where the","width":192},{"text":"first element always starts at index zero","width":256},{"text":"So this is an array where the front is always at index zero","width":448},{"text":"Right and we wanna look at how long some of these operations took, a lot of these are list ADT functions","width":320},{"text":"like adding things from the front, removing things from the front","width":128},{"text":"adding them from the back, removing them from the back, etc","width":192},{"text":"we wanna know how long each of these operations takes","width":128},{"text":"give our choice of implementation, because that answer will vary","width":256},{"text":"Okay so let's look at push front and pop front","width":320},{"text":"so in the case where we have a singly linked list","width":256},{"text":"our memory diagram looks something like this","width":256}]