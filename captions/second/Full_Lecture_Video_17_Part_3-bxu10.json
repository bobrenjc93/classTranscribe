[{"text":"Alright, so we call heapify down on the index, either 0 or 1, depending on whether you’ve chosen to have 0-based or 1-based heaps. ","width":625},{"text":"So we call heapify down on the root index. We need to figure out where we should move the 20. ","width":676},{"text":"Now that’s sort of equivalent to saying that what should the new root of this subtree be, the subtree we build at 20. ","width":512},{"text":". What is rhetorical? What should the new root be for the tree that’s rooted at 20?","width":704},{"text":"3, why should it be the 3? ","width":161},{"text":"It's the smallest element, i.e. it has the highest priority, right?","width":439},{"text":"So we leverage the fact that we know that our two children, our two subtrees, are definitely heaps to be able to figure out what’s the most promising looking elements right now. ","width":804},{"text":"So we can just look at the root of both of those subtrees and figure out which one is smaller, and we know that that one ought to be the new root.","width":517},{"text":"So in this case we notice that 3 is the smaller child, so we swap 3 up to the root, and 20 down here, right? ","width":576},{"text":"Couldn’t swap with the 4, because then we will have 3 being on the right hand side, still being smaller than the root, so that’s no good. ","width":694},{"text":"So we have to make sure we are swapping with the right child, the correct child, not always the right, the correct child when we are heapifying down, and I’m not done here I need to call heapify down again on where I move the 20, because the 20, right, this tree here could still be messed up and in fact it is. ","width":1245},{"text":"I know that pretty much everything over here is now fixed, okay?","width":388},{"text":"I move the smaller of the two children up to the root, so I know that the left subtree or the right subtree, without loss of generality, is happy, because I moved something smaller than its root above it, so it doesn’t care. ","width":640},{"text":"So the only part of the tree I have to worry about now is again the tree rooted at 20, so I call heapify down again on the index where I moved the 20. ","width":576},{"text":"So again, I compare with the small, I see, which of my two children is smallest.","width":357},{"text":" In this case it’s the 4, then I say, is that smaller than me? ","width":234},{"text":"Yes, so now I need to swap again with the smaller of the two children, which is the 4. ","width":384},{"text":"Now the 20 is backward started. Notice now that the heap property is satisfied? ","width":810},{"text":" And then also notice like what is the farthest we could possibly move that 20 down?","width":525},{"text":"How many swaps are there in the worst case for this? ","width":279},{"text":"O(h), the number of bubbles in this structure. ","width":344},{"text":"Because every time I recurs I’m moving down to the next level, so I only care about the height, so it’s also O(h). ","width":846},{"text":"I want to remove one more element, so again, the same process, I’m gonna swap the 3 down here, and I think that was a 7, right? ","width":573},{"text":"Then I can pop back, easier move the 3, and now it’s matter putting 7 in its appropriate place, so I heapify down on the root here, I look for the smallest child, which is the 4, so now the 4 is back where it went and now it’s the 7 here. ","width":1111},{"text":"Again I have to heapify down on the place where I moved that element, so I heapify down on the index where 7 resides, and I look at the smaller of the two children,  which is 6, so now the 6 is swapped with the 7 and we are back looking like this. ","width":1008},{"text":". Convenient. Now it looks like I’ve done nothing at all. I could have done a whole bunch. ","width":739},{"text":"Any questions on what that pop operation looked like? ","width":388},{"text":"Again the intuition here is sort of move the elements where it’s convenient, and then fix the heap property that you may have violated in the process of gaining that. ","width":613},{"text":"So we swap the root down with the back, and then fix the root to going to the proper position.","width":940},{"text":"Either.","width":256},{"text":"Some people find starting at 1 easier for doing the left and right and parent calculations.","width":376},{"text":"I don’t, because it’s easy to do it either way.","width":256},{"text":"If you’re doing a 1-based heap, you’re wasting one element space. ","width":320},{"text":"I always just put it at 0 because that’s easier, for me, but there is not really any convention there. ","width":494},{"text":"The reason why at all somebody might start from 1 is purely just for convenience, calculating what your left and right and parent should be. ","width":512},{"text":"The problem is if you’re moving it, you’re gonna, like, if you’re moving the 20 down, you’re not replacing the value where the 20 used to be, but if I’ve got, you know, let’s say I’ve got a 30 here, and I wanna do a pop, right? ","width":3136},{"text":"I can move the 30 up to here, and then remove this, right? ","width":576},{"text":"And that’s fine, but now I’m moving it down, I need to actually swap, it has to be a swap. ","width":413},{"text":"If I just trying move the 30 to the smallest position, which will be 5 here, all that’s doing is moving the 30 here, it’s not doing anything about correcting the root, and now I’ve lost the 5.","width":787},{"text":"It has to be a swap. I’m not just moving the 30 down, I’m moving other elements up as well.","width":569},{"text":"It has to be a swap. If I just move elements down, I lose the 5.","width":563}]