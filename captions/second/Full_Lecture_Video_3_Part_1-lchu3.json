[{"text":"Pretty much everything I’ll say has like little extras connected to it cause you can always shoot yourself from the foot if you really really","width":384},{"text":"Since I’m not gonna teach you how to shoot yourself from foot, you should have to worry about.","width":256},{"text":"Okay, so one of the reasons you want this is to help you, as a programmer, ensure that you are maintaining some semantic functions. ","width":832},{"text":"So, if I, for example, if I am, and it matters more when you passing classes around than anything else, but imagine I got a function and all that function is gonna do is to compute something that is given, I don’t know, a triangle, right?","width":1216},{"text":"Maybe I give it a triangle class and the triangle class consists of 3 points and 3 spaces or something, right? ","width":320},{"text":"And, or even 2D space, and I want to compute its area or something, right? ","width":448},{"text":"There’s no reason for me to have to copy all of the thing over into the functions. So, you know, it’s probably not reasonable for me to pass it by value because..Why?","width":832},{"text":"It’s also not likely that I want to change how the triangle, change property of the triangle when I’m just computing its area, right?","width":768},{"text":"So I might pass that to a function as a const reference, right? So I might say const triangle reference T, right? As the parameter in my area.","width":640},{"text":"Now I know when I’m inside that function, I cannot do anything that will change the property of T, that triangle.","width":64},{"text":"If I do so, it’s a compiler error because that T is marked as constant. ","width":768},{"text":"If I call something that try to modify, try to change its member variable or something, that won’t work because I declared that thing is constant.","width":448},{"text":"So most of the time when you will be seeing const, using const, it trying to guarantee the semantics of the function are clear, right?","width":640},{"text":"This function, if it takes parameter as a const reference, you know will never modify it, right? or take something by, you know, it takes a const triangle *p, it knows you are not gonna modify the triangle at the end of the pointer, right?","width":1024},{"text":"You use const to guarantee that people aren’t gonna modify things you don’t expect them to be modified. We will touch it a little bit again a little bit later but I want to make sure that at least you understand that point.","width":832},{"text":"Are new and delete in C++ same as null and free in C? That is the exactly the right analogy to have.","width":896},{"text":"They are not exactly identical but essentially new will eventually go down and call a memory allocator which may happen to be a null and delete will eventually call something which is free in memory which might happen to be free. But it doesn’t have to be.","width":1024},{"text":"So it is a little bit more general that the null and free can be but it’s the exactly same idea. It’s superior. ","width":256},{"text":"If you null allocate an array and you have to remember to free it later, your null-allocated, you know, you have to remember to free it later.","width":384},{"text":"It’s the same thing if you new something you have to delete it later, right? Null can free away when interacted with the free storage just like new and delete away and interacted with free storage in C++. ","width":512},{"text":"So that’s the exactly right analogy. Someone say I’m a little bit fast-paced. Yeah, there’s the first two weeks are gonna be.","width":640},{"text":"I’m not familiar with 173 things. Do I have recommendation for a book? Magerate Fleck’s lecture notes and I think she also wrote a textbook available. Like CS173, you should find her material.","width":1536},{"text":"What is the difference between int const star and int star const? Can anybody answer that question?","width":832},{"text":"Question is int const *x vs int *const x. Right. ","width":2688},{"text":"So, this is a difference of, again, this is the one actually a little bit easier cause the const is not the weirdness of const has to apply right cause there’s nothing to left. There’s something to the left of both these const. So they just apply left.","width":704},{"text":"So what the first one means is that x is a pointer to a constant integer, meaning that the thing at the end of the pointer cannot be changed. ","width":640},{"text":"However, what  the pointer looks at could be changed. So the following would be wrong.","width":384},{"text":"Now I’m trying to change the value that exists in the integer at the end of the pointer, right? I can’t do that cause the thing that is pointing at has been declared as a const int, or int const.","width":896},{"text":"So the integer at the end of the pointer can’t be modified. That’s a compiler error. However, this is fine. I can change what it looks at all day. ","width":1280},{"text":"I just can’t change the value at the end of thing it looking at. So I can change the pointer but I cannot change the pointee. So even after I do x equals new int, I can’t assign a value into that integer as it is declared as const. ","width":1216},{"text":"Does that make sense? Cause the thing that is const is at the end of the pointer.","width":576},{"text":"What about this one? Well, if we use the rule that const applies left and we read the type from right to left, we have x is a constant pointer to an integer.","width":704},{"text":"So what is const there? The pointer or the pointee? The pointer.","width":448},{"text":"So that means I can’t change the memory location that’s stored inside of x, meaning that it’s looking at this particular integer forever. It will never locate another integer. You cannot change it. So now you know x equals new int and that’s a compiler error now.","width":1152},{"text":"Now I can go ahead and say *x equals five. That’s fine now.","width":832},{"text":"Because the thing at the end of the pointer is not const but the pointer itself is const. I cannot change the memory location it’s looking at but I can change the thing the end of the pointer as much as I want.","width":320},{"text":"okay, this is a really good question. So, references can’t be null, a const pointer could. ","width":1472},{"text":"Reference always have to be initialized to refer to something. But if I have a pointer, I can initialize it as a nullptr.","width":640},{"text":"I can’t make a reference to nothing. If I declare a reference variable, I have to set it refer to something. But if I have a const pointer, I have to set it up right away, but I can set it up pointing to null.","width":1280},{"text":"Questions? We will get a little bit more about the difference between them and why might prefer one than the other later on.","width":640}]