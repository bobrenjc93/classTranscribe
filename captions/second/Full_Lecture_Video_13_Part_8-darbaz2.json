[{"text":"then I'm going to","width":320},{"text":"move with the head pointers that I look at this","width":256},{"text":"and then move with the head pointer again so the head looks there","width":256},{"text":"constant time, right","width":192},{"text":"easy, didn't have to update the tail, push 3 same story, add a node","width":384},{"text":"pointers up, short cutting some steps here","width":640},{"text":"but that's easy that looks like it's constant","width":192},{"text":"if I do this though, and I tell you to pop","width":320},{"text":"what happens?","width":192},{"text":"what do I have to do here","width":576},{"text":"yeah I need to change head, just move this over","width":256},{"text":"I have to be a little bit careful If I wanted to return that but I'm not returning it, I'm just removing it","width":512},{"text":"so that implementation looks okay","width":256},{"text":"so where is the top of the stack if I do it that way","width":320},{"text":"the head of the list","width":128},{"text":"so I'm adding things to the head of the list and the next thing I'm removing is always the head of the list","width":576},{"text":"that sort of looks like our best case so let's write that down","width":384},{"text":"singly linked list, o(1) for push, O(1) for pop, how do I do peek","width":448},{"text":"just look at the head pointer","width":256},{"text":"O(1)","width":256},{"text":"okay so that's fine","width":128},{"text":"what if","width":192},{"text":"what if I add at the back instead? If I say the top of my stack is the back of the list","width":1024},{"text":"so I push 2 instead of doing it at the head I'm going to do it over here so that means I'm going to make it two and I set the tail to point at that","width":768},{"text":"easy push back","width":320},{"text":"push three, easy, same thing. that doesn't look like it's that hard, maybe it's okay. this might be another valid implementation","width":896},{"text":"what if I do pop now","width":192},{"text":"what do I have to remove if I have to do pop? what nodes are going away? 3. how long is it going to take me to remove the 3?","width":832},{"text":"O(n) why","width":128},{"text":"I've got to get to the one before it and I don't have any way of getting there without walking the list","width":640},{"text":"I have to be careful here, moral of the story is that. when I'm using a singly linked list for my implementation of a stack, it really matters where the top is.","width":960},{"text":"I need to make sure the top of the stack is the head of the list, not the tail","width":384},{"text":"alright so what else could I do?","width":1152},{"text":"what's another structure I can use to implement this stack","width":320},{"text":"doubly linked!","width":128},{"text":"natural analogy. so let's try that.","width":320},{"text":"where do I insert? I'm going to add a 2. or does it matter?","width":1088},{"text":"let's insert at the tail, and see if that matters.","width":448},{"text":"should be sort of a review because we talked about these operations before but it's good to cover it more than once. alright so we're going to add something to the tail.","width":832},{"text":"so that means this is going to point there, this is going to point there, that's a unique pointer.","width":896},{"text":"then we update tail","width":192},{"text":"we've covered the operations. we have the exact c++ statements you need to do before. If I want to do that again, just make my new node","width":1024},{"text":"add it on the back, so that's good","width":960},{"text":"what if I want to remove now? where do I remove from?","width":320},{"text":"the back, the tail of the list. and how long does it take for a doubly linked list? constant time why","width":640},{"text":"right, I can right to the node that I need to get to to remove the tail, I can set curr directly to this by saying tail->prev","width":576},{"text":"then I can blank out that pointer and the node no longer has an owner, which means that it's going to be deleted by either a destructor or the clear() function inside of the unique pointer when I set it to null. okay that was easy and constant time","width":1216},{"text":"and the front of the list case won't change at all because if it worked for singly linked list why wouldn't it work for doubly linked list? so I could insert either at the tail or the head it doesn't really matter.","width":768},{"text":"but for the singly linked list case, it made a big deal of difference, so for doubly linked list it doesn't really matter which one I do. I can do order 1 push order 1 pop and order 1 peek","width":1216},{"text":"if the head is at the tail I just look at the tail pointer, if the head is at the head I just look at the head","width":640},{"text":"so now, which of these would you prefer?","width":576},{"text":"if you were implementing a stack, which of these would you pick and why? let me rephrase","width":704},{"text":"which of these implementations would you not pick? the array, why not an array? you need to resize it but it's amortized constant, so that shouldn't be so bad right?","width":1088},{"text":"it is a little bit more expensive. what's good about an array though? the operations on the array are going to be very fast compared to popping the pointers","width":1088}]