[{"text":"But yeah, this triple function is just a free-standing function. It has nothing to do with the class itself. So if I derive from triple, therei s no inteheritance going on at all. This isn't a member function. Only member fucntions are inherited. ","width":2624},{"text":"Right, so if I make a derived class of triple, like triple bubble or something, this make_triple function isn't, I'm gonna have to rewrite one for the derived class. It's not inherited, it's not a member function.","width":1152},{"text":"So only a member function was scoped and I put it inside the header class itself.","width":576},{"text":"This is outside of the triple. It's a free-standing function. It's still a template function so still gonna show up in the header somewhere.","width":192},{"text":"But it's not in the triple class itself. It's outside of it.","width":128},{"text":"I didn't need anything that was private in triple to do this. ","width":448},{"text":"I just used  a public constuctor and returned by value. ","width":64},{"text":"I construct one inside of the function and then I construct one to put back into the stack frame.","width":960},{"text":"The compiler may optimize the second one. ","width":192},{"text":"Which is what you'll see most of the time.","width":128},{"text":"There are cases where it can't","width":128},{"text":"But most of the time, if you do this and you print out something, triple constructor, you'll only see one. ","width":640},{"text":"But yes, there are two halves of this. ","width":384},{"text":"If you actually try this, you'll see that there is only one call. ","width":640},{"text":"So I prefer this one, just because it is shorter to write for me as a programmer","width":128},{"text":"Sure, I had to wade through all of that but I've done that once and now everytime I'm making a triple, I just call this function and not have to type out everything. This is going to be faster.","width":896},{"text":"Ok.","width":320},{"text":"So switching gears entirely. Now, ok.","width":128},{"text":"\\Done thinking of templates for a while. Think about inheritance and virtual functions and stuff. ","width":704},{"text":"So I've got these two classes, I've got this hello, which has got a virtual int foo, ","width":576},{"text":"So is hello an abstract class?","width":64},{"text":"No.","width":128},{"text":"It doesn't have any pure virtual functions. It's got a virtual function but not a pure virtual function. ","width":640},{"text":"There's a difference between virtual functions and pure virtual functions.","width":64},{"text":"Not all virtual functions are pure virtual functions.","width":384},{"text":"How would I know if this is a pure virtual function? = 0.","width":384},{"text":"It's got a private int bar, and i've got a hello with a public int baz.","width":832},{"text":"The question is, where could the following assignment occur?","width":256},{"text":"Could it appear in a member function of class hello? could it appear in class world?","width":832},{"text":"What about a free standing function like main? No. It's a private member variable, I can never assign it. ","width":960},{"text":"And furthermore, I would have to say something like .hello. something .bar. What about the inside of the hello class? Could it appear inside of virtual int foo. ","width":896},{"text":"Ya.","width":192},{"text":"It's a private int variable and foo is inside hello. So it's fine","width":320},{"text":"Can bar = 2 appear inside of baz.\\","width":896},{"text":"No.","width":128},{"text":"It's private to the hello class and that private accessing is not inherited. Even though I am a hello, I still can't access the private variables of hello.","width":832},{"text":"Private means to member functions of that class not of any deriving classes.","width":960},{"text":"What would I change here if I wanted to say that?","width":256},{"text":"Change to protected.","width":256},{"text":"Here's one that's a little tricky","width":1472},{"text":"What is printed when I do this?","width":512},{"text":"Here's main. make a monolith. return 0;","width":832},{"text":"I am invoking default ctor for monolith. Inside of monolith, you see that it is an obelisk and it's also got a basilisk inside.","width":1984},{"text":"So there are lots of things that are happening.","width":448},{"text":"If we think about it, draw monolith","width":576},{"text":"it's public obelisk. it's got those and extra stuff.","width":1088},{"text":"This part is obelisk. ","width":1088},{"text":"And then, down here is monolith.","width":512},{"text":"what's in a monolith. we've got a member variable of type basilisk called b.","width":2240},{"text":"so what's a basilisk int? It's a template class.","width":704},{"text":"And every single constructor and dtor is printing stuff. so what order?","width":1216},{"text":"So, if I wanna make a monolith m, invoke default ctor.","width":768},{"text":"I'm going to invoke it","width":576},{"text":"However, a monolith is an obelisk. So i must construct the obelisk part first.","width":1280},{"text":"So I'm not invoking a particular ctor, it will invoke the default ctor of base class.","width":1792},{"text":"So the very first thing I will see here is stone. ","width":320},{"text":"Now I've made obelisk. Now I make monolith. But before that, all of my instance variables will be initialized. They will call my default ctor.","width":2560},{"text":"in the order that they are declared. ","width":704},{"text":"we're going to invoke this function. so we're going to say hisss next","width":1344}]