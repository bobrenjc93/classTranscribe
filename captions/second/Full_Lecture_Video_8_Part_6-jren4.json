[{"text":"so I can say to a data structure given the next item, if the data structure's empty that call can just block and it can block until there's data to be retrieved","width":1113},{"text":"so these become very powerful primitives in multi-threaded code","width":329},{"text":"and by the way you can use semaphores as well to even work with multiple processes, but let's not worry about that today","width":763},{"text":"still I want to show you this little example here where I'm going to use sempahores with signals","width":787},{"text":"now a quick comment, semaphores don't work in mac os x","width":386},{"text":"so if you happen to have an apple machine in front of you please go intern at Apple and fix this","width":652},{"text":"don't worry, we'll work at how to get around that in a different lecture, but you can check to see if it works by looking at the return value of sem_init()","width":612},{"text":"so remember typical posix calls return -1 if they fail","width":213},{"text":"so it's a good idea to find out early that our semaphore failed instead of just carrying on and assuming it wasn't a problem","width":682},{"text":"so I want to show you a common way of using semaphores, and that's this","width":260},{"text":"let's have a thread that's going to do some clean up for us","width":309},{"text":"and the first thing this thread does is call sem_wait()","width":566},{"text":"alright, so I've got a little method here called sing song","width":247},{"text":"and the clean up is going to do sing 'yo ho ho ho a pirates life for me!'","width":455},{"text":"which you can imagine in say your java virtual machine there's a whole lot of clean up you might want to do before it exits","width":501},{"text":"and so this is a perfect example of how we can use a semaphore","width":182},{"text":"we're going to call sem_wait() which means this thread blocks, which means this this thread cannot continue because there's nothing in the pizza box right now","width":738},{"text":"now, I'm going to set up a signal handler so that when I press ctrl-c I call my little handler","width":750},{"text":"here's my handler","width":121},{"text":"so when I press ctrl-c I call sem_post()","width":334},{"text":"hold on a moment, why couldn't you've just printed 'yo ho ho ho a pirates life to me' directly from my signal handler?","width":644},{"text":"and the reason is because printf() might actually allocate some memory and the number of functions you can call from the signal handler is actually quite small","width":800},{"text":"sem_post happens to be one of the few functions that you're allowed to call from within a signal handler, printf() is not","width":702},{"text":"why? because there could be race condition","width":205},{"text":"it could be that malloc is being called from somewhere else in our code and the internal data structrues may not be correct, it may not be ready for another malloc call to run at the same time","width":1159},{"text":"so that's our trick, right, inside the handler we put an extra slice of pizza inside our counting semaphore","width":473},{"text":"we increment the count from zero to one and in doing so and a moment later sem_wait() can return","width":445},{"text":"at last that thread can eat! at last it can take a slice of pizza","width":595},{"text":"alright, so, let's run this","width":489},{"text":"so, you can see I'm using gcc. you need to give the option -pthread to say include the pthread support and because I didn't specify an output file it's just compiled to a.out","width":815},{"text":"so let's run this","width":277},{"text":"nothing happens of course until I try to press ctrl-c in which case it now prints 'yo ho ho ho a pirates life for me!'","width":502},{"text":"we caused the signal handler to run which posted the semaphore which let our other thread go","width":488}]