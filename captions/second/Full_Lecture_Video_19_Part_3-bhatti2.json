[{"text":"which is equivalent to say that subroot == nullptr.","width":256},{"text":"ok, when I have an empty tree, throw the exception, I can't find anything for you in the empty tree. Its not possible.","width":384},{"text":"So that the unhappy base case. What's the happy base case?","width":384},{"text":"Actually found it, so what the condition for that?","width":320},{"text":"subroot's key == key that I am looking for , so key I am looking for is the samething as subroot. In which case what do I return?","width":1536},{"text":"just the value.","width":320},{"text":"ok. so if I don't hit either of these cases. I know that I am a non-empty tree and the key at this position is not the samething as the key I am looking for.","width":1152},{"text":"so now what do I do?","width":256},{"text":"yea, I have to recurse, so I am not going to do a full traversal, remember we go this ordering property, so I am allowed to throw off half of the tree in the process of doing this traversal. It's not like I am gonna hit every node.","width":1280},{"text":"So, i am only gonna go down one side. How do I check if I need to go down the left side.","width":384},{"text":"the key I am looking for is smaller than the current key I am at. I know that it can only exits in the left subtree if at all","width":576},{"text":"Right its not possible for it to be in the right subtree, if it was, the tree wouldn't be a binary search tree.","width":256},{"text":"If the key I am looking for is smaller, it better be to my left. so if key is smaller than subroot key.","width":832},{"text":"then I better return the result of recursing on the left subtree. so return find in subroot's left.","width":1152},{"text":"Â converting to a raw pointer. I am still looking for the same key. Ok.","width":512},{"text":"it's important that I return here cuz otherwise in the case where I don't find the key, my recursive doesn't return a value, you will get something like. warning no return statement out of a non void function and clang is allowed to miscompile your code. you getting a valid code, and then scratch you head for a long time because you ignored the warnings. Don't ignore the warnings.","width":1408},{"text":"Ok. so I have to return something here, so I am just gonna return the result of running the helper function on the left subtree. Then, if it finds an element I will return my value that its helper function returned and that returns the value that its helper function returned etc. So it bubbles all the way back up.","width":1152},{"text":"If I omit the return here, my helper function gives me the value and I ignore it and go the mirror way and no body gets the value. So I have to return here.","width":704},{"text":"Ok so finally what's this last case. This last case is where we have a non-empty tree, the key is not the same as me and its not less than","width":576},{"text":"Now what do I do?","width":192},{"text":"O yea return the find on the right subtree. So I am gonna recurse right. So .. ","width":1106},{"text":"and again its important that I return cuz it gotta bubble up all the way back out of recursion.","width":1216},{"text":"Alright, so if I tell you that the tree we are operating on has height h, what is the running time of this function in terms of h.","width":768},{"text":"O(h). Right. We aren't traversing another side of the tree so its not like its O(n).","width":259},{"text":"Right, we are only going down and in the worst case the height of the tree which could still be bad but in this case its proportional to the height of the tree, so if later on we can come up with a way of making the height not suck then the running time of this function will also not suck.","width":1078},{"text":"We will just gonna leave it in terms of h and we will come back to this later.","width":448},{"text":"Ok, so here is a picture of a binary search tree. Now I want you think about how you would insert the following elements into the tree.","width":896},{"text":"You gotta be careful, when you are inserting into a binary search tree.","width":448},{"text":"Because you have to make sure that the ordering property is satisfied.","width":196},{"text":"Right, so I can't just stick wherever I would like to, because it might ruin the ordering property.","width":354},{"text":"I have to make sure that the ordering property is always satisfied when I am doing these insertions. ","width":256},{"text":"Furthermore, i am not just gonna add everything to the root anymore. ","width":512},{"text":"don't do that. if you do that, you can sort of fairly easily see that you gonna end up with one of the worst case looking trees if you do a bunch of these insertions.","width":799},{"text":"So we are gonna do a different insertion strategy that tries to at least make the tree look a little bit better than you know something that looks like ","width":576},{"text":"that or that or the other way around, right.","width":611},{"text":"So we are not just gonna stick things to the root.","width":192},{"text":"So if I wanted to insert 8 into this tree.","width":448},{"text":"How would you do that?","width":192},{"text":"Where do you think 8 should go, if I tell you it can't be the root.","width":435},{"text":"Yea. The only place it can go is to the left of 9.","width":317},{"text":"Right, if it went anywhere else, I will be violating the ordering property. If I tell you I can't make it the root","width":448},{"text":"ok, I can't just trivially make it a root and make the whole tree as its right child. ","width":282},{"text":"Furthermore, I have no idea of knowing that was valid or not. ","width":285},{"text":"Even if I did that I would have to sort of know for sure that there is nothing smaller that 8 in the left subtree, so you know if I said insert10 ","width":559},{"text":"Right and I try to make 50 be the right subroot of 10. that's not right because there is a 9.","width":320},{"text":"in its right.","width":128},{"text":"So I have to actually kinda locate where this thing goes. I can't just stick thing into the root anymore or it won't even work","width":256},{"text":"so right, the only place I can stick this 8 ","width":256},{"text":"is to the left of 9 and it has to be satisfying the ordering property. I know that it has to be to the left of 50. I know that it has to be to the left of 17. I know that it has to be to the left of 12. I know that it has to be to the left of the 9 and then there is sort of noway left to go.","width":896},{"text":"","width":22},{"text":"So when I have an empty tree throw the exception. I can't anything in the empty tree for you, its not possible.","width":384}]