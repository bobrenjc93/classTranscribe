[{"text":"Yes, its a little complicated. You get into a little bit of...programming because you have to be able to look into that type and that type turns into that type so it get complicated. Its beyond the scope of the class.","width":1728},{"text":"The answer to most things in c++ is yes, you can do that.","width":384},{"text":"The right way to do this would be to have a seperate template function that takes another triple up like DEF and then do template metaprogramming to check if D can convert to A, E to B, and F to C\\","width":1280},{"text":"and then if that condition is not true, don't enable the function, but doing that is way beyond what we'll get to. That is possible that's the right way to do it.","width":768},{"text":"Auto has to--it always has to be in a variable declaration and always with some assigner on the rhs","width":896},{"text":"Because all auto does is look at the equal on the rhs, figures out what that type is and then fills out the type. So if I just said auto a; which would be what would happen if I said triple auto auto auto, it would say auto first;","width":1088},{"text":"if I say that it doesn't work because there is no initializer so it can't tell what that type is supposed to be, so that wont work.","width":576},{"text":"Auto will only infer on a local level it wont work for template","width":1344},{"text":"You should--if you need to provide a overloaded meaning for what it means to copy your class, you need to provide an assignment operator. ","width":2112},{"text":"If the default behavior or memberwise copy is fine, you shouldn't bother. You could and it would work, but youre gonna write code thats gonna do the same thing that the system would do.","width":768},{"text":"So for this class I dont have dynamic memory I don't need to change what means to copy, copying a triple should just do memberwise copy that's fine.","width":192},{"text":"So I wouldnt provide any of a copy constructor,move constructor, assingment operator here, because the default behavior for all of them is fine.","width":640},{"text":"The answer is mostly--if you need to redefine what it means to copy, then you should also write a move constructor and assignment operator","width":896},{"text":"But if that's not true, if your default behavior of copying is fine, don't bother. So here I wouldn't bother.","width":384},{"text":"Let's say that I did have this equals default thing. So now I can default construct these things, and it just makes a default whatever those arguments are. How do we feel about that last line? p2=p, so p2 is a tripe int double char, p is a triple in double char","width":1600},{"text":"So what do we think about that?","width":192},{"text":"Do these types match? Yes. They should be fine.","width":896},{"text":"The system provided assignment operator is going to look for things of the same type, so if lhs and rhs have the same type you should be fine.","width":512},{"text":"It's only when those 2 types aren't the same that we have problems.","width":384},{"text":"I would probably give you this, and then add in the declaration for this, so I would probably glue those things together and say what happens, does this compile, does it have a runtime error, if not what is the output?","width":2048},{"text":"So the answer is it doesn't compile because there's no default constructor for this. Even if it did this won't work.","width":576},{"text":"Here it would be fine. ","width":512},{"text":"Here it would be this doesn't compile because there's no default constructor provided for triple int double char","width":192},{"text":"content you need for each part. I would not give it as what would all these do.","width":640},{"text":"That would be like question1, what does the first one do? Question2, what does the second one do? And I would give you--here's the entire snippet.","width":320},{"text":"If I didn't have the default, this doesn't compile. The first one didn't work, obviously the second one won't work either because it didn't compile.","width":1600},{"text":"If I say the second one was working, conditioned upon us having a valid default constructor. I switched modes on you for a bit. Let's say we did provide a default constructor now does the second line work? And then the answer is yes.","width":1216},{"text":"Yeah, absolutely. If I don't have a default constructor it doesn't compile so it doesn't even get to that line.","width":192},{"text":"Now let's write this make triple function. We're gonna write a template function make triple that given 3 parameters constructs a new triple and returns it by value.","width":1088},{"text":"So this is just a template function, is this going to be a member function of the triple class? Or is this going to be a free-standing function?","width":896},{"text":"Free-standing function.","width":384},{"text":"All this is doing is create a triple and give it to me. It doesn't need to be part of the triple class.","width":384},{"text":"It's just a function that takes some arguments and then returns a triple. It doesn't need to have access to the private member variables of the triple class..","width":512},{"text":"It's just going to invoke a constructor for the triple and return that.","width":192},{"text":"This actually can be outside the triple class.","width":320},{"text":"The answer should most of the time be if it can be a free-standing function, it ought to be a free-standing function. Most of the time you should prefer free-standing functions","width":576},{"text":"Unless there's a particular reason why you can't do it. ","width":192},{"text":"I can do this as a free-standing function so I'm going to.","width":320},{"text":"What's the very first keywork I'm going to write?","width":128},{"text":"template","width":256},{"text":"This is my template function it takes 3 parameters, so I should probably have it take 3 different type parameters again, so class T1, class T2, class T3.","width":1536},{"text":"I take T1, T2, T3 as template arguments, now what does it return?","width":512},{"text":"A triple, so my return value is triple of T1, T2, T3.","width":640},{"text":"Name of the function make_triple.","width":512},{"text":"What are the arguments?","width":192},{"text":"T1, T2, T3 of some variable name, so T1 first, T2 middle, T3 last. So good question, I will refer you to last lecture's video. We will take them by value for the same reason we took them by value for the constructor for the triple when we wrote it.","width":2112},{"text":"That is, we don't have to write 8 overloads for the different types of ref and rvalue ref.","width":384}]