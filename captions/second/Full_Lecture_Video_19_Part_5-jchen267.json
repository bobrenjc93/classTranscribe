[{"text":"The elements that's inside of the node struct, is an unique pointer. ","width":982},{"text":"So okay I could have but I would have to change my base case. ","width":384},{"text":"So if I pass.. so the question was like okay why couldn't we have a node star?","width":291},{"text":"And the answer is well the way I'm gonna write it it cannot be a node star. ","width":219},{"text":"There exists a way to write it where it could be a node star but then you would have to change what's your base case. ","width":256},{"text":"My base  case is going  to be when the pointers when I'm recursing into an empty tree.  ","width":384},{"text":"I'm gonna say okay let that empty tree now be the tree with one node containing this key value pair. ","width":320},{"text":"And that's sort of the simple base case. If you pass in a node star, you now have to change your base case a bit so that it's","width":640},{"text":"The base case is now actually when I'm at the node and whatever direction I'm gonna go has a nullptr there, I'm gonna change it there rather than recursing it. ","width":640},{"text":"So you have kind of your base case up one, and now you have to deal with this nastiness of what if the tree is empty and you don't have a node to start off with. ","width":491},{"text":"cause now your base case is now a one-node tree and you have to special case that maybe up in the helper function...in the public function, which you can do. ","width":509},{"text":"You can make it work but it's significantly more code than well not significantly but it's.. I think it's a little bit more work than doing it this way. ","width":512},{"text":"This way is simple cause you can think of your base case as just being an empty tree in which case I'm gonna replace the empty tree with a new tree with one node. Yeah?","width":448},{"text":"Yes, you would have to move it. ","width":576},{"text":"Well unless you've moved it. That's what I mean that if somebody is giving you ownership or something","width":320},{"text":"In order to pass in an unique pointer by value, somebody would have to have an unique pointer and move it into your function. ","width":384},{"text":"That moving process is that I'm giving you ownership of this thing. This thing that I was in charge of? Nah now you're in charge of it. Alright. Okay. ","width":640},{"text":"So no moving happening here, just references. And we need that reference so that we can modify the tree cause my base case is gonna be ","width":437},{"text":"fairly simple, it's just an empty tree. So I'm gonna kick this function off by passing down the values that I need, ","width":576},{"text":"which I know it's gonna be okay the root, the root itself. ","width":335},{"text":"Notice that if the tree is empty, my base case would still work here right? If the root is a node pointer, I'll hit my base case right away and replace that nullptr with one node. ","width":679},{"text":"So I don't have any special case, the case where the tree is empty, it just works. ","width":320},{"text":"okay then I'm also gonna pass down my key and my value. There're numbers of different ways you can do them. You can pass them so here I'm passing them into the function here by value--both the public and the private helper function. ","width":907},{"text":"You could do that, you can pass in by const reference. Either of these would work. The point here is that you only want to make one copy of these. ","width":640},{"text":"So what I'm going to do is pass them in by values, make a copy or do a move if I need to. ","width":268},{"text":"And then move them at every other function call. So the very first public function is either going to move construct the K and move construct the V, or copy construct the K and copy construct the V, or any combinations of that. ","width":777},{"text":"And then from there one I'm just gonna move it down the call chain. ","width":256},{"text":"But you can sort of write this in a bunch of different ways, and all of them should be fine. ","width":320},{"text":"The key thing here is if you're passing into by value, don't make a bunch of unnecessary copies. So I'm gonna move the values down. ","width":448},{"text":"So if you have a value that's like a PNG, it's gonna be copied once and be moved down all the recursive functions..rather than copying every time. ","width":448},{"text":"So when I'm calling my helper function I'm actually gonna say std::move(key)","width":1152},{"text":"I'm just gonna move the key and the value down to the next function. Cause remember whenever I'm passing by value it has to create a local object of that type from whatever the argument was. ","width":570},{"text":"So if your argument is std::move of that thing of the same type, it's just gonna move construct of it . ","width":448},{"text":"At most one copy made here. Assuming k and v are move construable,  ","width":361},{"text":"So what I'm actually gonna do in this helper function? I've said a lot about what the base case is, we'll handle the base case. ","width":768},{"text":"I said our base case is gonna be the empty tree. ","width":448},{"text":"If not subroot, that is if the subroot is null, meaning that I've got an empty tree ","width":402},{"text":"Now I know that I'm actually at the location where I want to insert it. So now I'm at..you know..","width":384},{"text":"Here where I'm recursing on this null pointer in the 54. So that is the null pointer I've got so I'm gonna change that null pointer to point at a new node that I've created. ","width":729},{"text":"with the right key value data. So I'm gonna say..","width":640},{"text":"","width":1152},{"text":"I'm gonna say subroot should be equal to std::make_unique, what's make_unique?","width":384},{"text":"This just gives me a unique pointer to the type that I put in the bracket, right? ","width":448},{"text":"And the argument to that is just the arguments for the constructor for that object. So whatever the arguments for the node struct are for its constructor I'm just gonna give to the std::make_uni","width":634},{"text":"and it'll do whatever it needs to do to construct it. So in this case, probably my node struct takes in a k and a v for the key and a value in that order and I'm gonna std::","width":1280},{"text":"","width":320},{"text":"std::move(key), std::move(value) to move them into the constructor for the node, and then I'm done. ","width":448},{"text":"So this is replace the current tree with the current tree which is an empty tree with a one node tree that contains this key and this value. ","width":768},{"text":"I'm gonna have a bunch of other additions. ","width":576},{"text":"I don't wanna copy them again. Think of a value as a png object. ","width":960},{"text":"","width":896},{"text":"This like make_unique, you can think of make_unique as like being just a function that says return std::unique_ptr{new T(..)} and then return that","width":1086},{"text":"So it's just wrapping up that long ugly, I wrote the type like twice, and the arguments again. ","width":470},{"text":"So it's just making that shorter and that's effectively the same thing as creating unique_ptr with some new node that I've created with a constructor and moving it into the pointer. ","width":576}]