[{"text":"People are getting mad at it when we say, okay, how long are we gonna take to build a heap? 2^(h +1) - h - 2....","width":832},{"text":"They don't know what h is. So it's our job to make sure that it's in terms of n in stead of h. But we know what h is.  h has to be log(n). So this is the same thing as 2^(logn + 1) - logn - 2","width":2368},{"text":"So I could just say that this is just 2*2^(logn) - logn - 2, which is just, n - logn - 2 = O(n). The n is gonna dominate log. log is not gonna matter when n is really big. So if we look at the growth rate of these functions","width":2560},{"text":"It's linear.","width":128},{"text":"This is better than nlog(n)","width":384},{"text":"So that's why our build_heap running time is linear","width":512},{"text":"","width":448},{"text":"I wanna do 10, and I'm gonna leave 11 for you to think about. We're probably not gonna cover it.","width":512},{"text":"So just of that as a practice for the exam. Cause I can ask questions like that","width":896},{"text":"Let's get this one real quick. Let's design an algorithm that sorts the array in place by using the heap algorithm we talked about and how does it compare to other algoritms we know. ","width":320},{"text":"How do we sort using a heap? We're gonna do it in place. So that means we are not gonna create a new array and move things over into the new array. We're gonna do it in the same array taht is being used for our heap. So in order to even do anything with a heap, we are gonna first build a heap. ","width":1280},{"text":"So we're gonna pre-process this to make a heap, which is gonna take linear time.","width":576},{"text":"Once we got a heap, how can we sort it in place?","width":128},{"text":"So that we use the same storage the heap is currently using to sort the array?","width":512},{"text":"Sort each row...","width":448},{"text":"Okay, so, yeah.... tha's not gonna be as fast as I like.","width":832},{"text":"(Student's answer)","width":256},{"text":"","width":768},{"text":"Swaping subtree is not sufficient here. ","width":640},{"text":"(Student's answer)","width":448},{"text":"","width":512},{"text":"let's say I wanna sort this array in place so that the largest thing is at front","width":768},{"text":"I want the smallest thing to be at the back of the array","width":512},{"text":"I can remove the element, but not actually delete it from array. If I have this heap, and I pop. ","width":640},{"text":"The 4 is gonna end up at the back of the array. If I keep it there. And i just make I heap oblivious to the fact that there's an element there. i can do another pop. Which will remove the second smallest element and put it at the second last position of the array, and make my heap oblivious to the fact that there's tweo elelment s there. Do it again.... See how this is working?","width":1920},{"text":"if I have a max heap","width":256},{"text":"then I'll be moving the largest heap into the back, and it gives me sorted in ascending order. So the idea here is to build a max heap and repeatedly call pop without removing the elements from the array. So remove it from what you treat as your heap without actually getting rid of the elements. ","width":3456},{"text":"So then when you're done, the part of the array you are treating as your heap is nothing, and all the elements are gonna be there in the reverse order of removial.","width":640},{"text":"So the preprocessing time is building the bmax heap. We know we can do it in linear time, and how long is that sorting proces gonna take, which is repeatedly calling pop, how long will one of them take where i is an element of the heap? log(i)?","width":2240}]