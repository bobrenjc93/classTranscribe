[{"text":"So what kind of heap is this going to be?","width":379},{"text":"We're going to maintain that it has k elements in it.","width":220},{"text":"And those k elements are always going to be the largest k that we've seen so far.","width":234},{"text":"What kind of heap are we going to have?","width":507},{"text":"What kind of thing do I want to be removing from it?","width":89},{"text":"Yeah?","width":788},{"text":"So exactly.","width":36},{"text":"So we're going to be using a min-heap in this case.","width":166},{"text":"And the reason is if you have a heap that contains your top ten candidates right now and you see a new element....","width":573},{"text":"What elements are you likely to replace in your set of candidates?","width":206},{"text":"Well the smallest thing right?","width":162},{"text":"That's the only guy you might replace.","width":128},{"text":"So we want to build a heap for which accessing the smallest element is convenient. ","width":299},{"text":"So we're actually going to build a min-heap here.","width":142},{"text":"And we see our new element we say okay, here's this new element, here's the root of our heap.","width":273},{"text":"The root of our heap is gonna be the smallest largest thing we've seen so far.","width":384},{"text":"So in our set of ten candidate elements, the smallest one of those ten candidates is sitting at the root.","width":397},{"text":"","width":2},{"text":"So we say okay, is the new element that we're seeing bigger than the smallest candidate that I know about?","width":372},{"text":"If so, then that smallest candidate is not the right element so I should remove it, and add this new element to my candidate list.","width":576},{"text":"If however the new element is smaller than my smallest candidate I know that, well, the smallest candidate is still bigger than it so this is not a top ten, so I can just drop it.","width":704},{"text":"Okay, so does that make sense?","width":128},{"text":"So we're going to have a heap of size k. ","width":247},{"text":"Adding one element to that heap of size k is going to take me log(k), because the heap has size k. ","width":911},{"text":"So the height of that heap would be log of k. ","width":278},{"text":"Removing one element is going to take.......","width":510},{"text":"I have a heap of size k, remove an element.","width":128},{"text":"How long does that take?","width":106},{"text":"log(k).","width":576},{"text":"So one way of doing this is to have a min-heap. ","width":350},{"text":"Maintain that there's always k elements on it at the end of your for loop.","width":264},{"text":"At the end of every iteration of your for loop.","width":113},{"text":"So just take the element that they're proposing, put it in your heap and then remove the smallest thing.","width":542},{"text":"So your heap will.. if k is ten, you'll add an element to your heap, your heap is now size 11.","width":342},{"text":"You shrink it by one by removing the smallest thing, so then you know that you're always left with the top ten things afterwards, right?","width":357},{"text":"Regardless of whatever is the statues of the element that you just added. ","width":269},{"text":"You'll always remove the smallest thing. ","width":192},{"text":"So what's the overall running time of this then?","width":593},{"text":"So think of the inner loop.","width":179},{"text":"The inner loop is push, pop.","width":266},{"text":"When it's filled the size k. ","width":114},{"text":"We can just pretty much ignore the first ten pushes because we're just going to keep everything.","width":258},{"text":"After that it's going to be push pop, right?","width":164},{"text":"Every iteration of that loop. ","width":128},{"text":"We know that push takes log(k), pop takes log(k), so the inner body of our loop itself takes log(k).","width":418},{"text":"How many loop iterations are there?","width":128},{"text":"All n. ","width":39},{"text":"We have to look at every element in the array. ","width":150},{"text":"So this is going to be big O of nlog(k). ","width":991},{"text":"If log(k), if k is some constant, this is pretty darn good.","width":414},{"text":"If k is ten, log of ten is something really small.","width":256},{"text":"So this is just n with a very small constant in front of it. ","width":256},{"text":"If you happen to log like the top thirty thousand things, okay, then the k really does matter, because it is getting larger, it is getting close to n.","width":512},{"text":"But if we make the assumption like we did at the very beginning, that k was significantly smaller than n, this log(k) factor really doesn't matter a whole lot.","width":527},{"text":"So this looks close to linear.","width":231},{"text":"The best known algorithm that I'm aware of for doing this can give you big O of n running time without any log(k)'s, has no dependence on k whatsoever. ","width":663},{"text":"This is called quickselect, and you'll end up writing an implementation of this in the next mp. ","width":264},{"text":"Not this one, but the next one. ","width":459},{"text":"I mentioned I sort of like this second algorithm a little bit more.","width":256},{"text":"Does anybody know why that might be the case?","width":816},{"text":"Why is the second algorithm maybe preferable?","width":704},{"text":"Yeah maybe it's a little bit larger, because I got a log(n) factor. ","width":320},{"text":"Maybe. ","width":45},{"text":"That's not my reason, but that's a good explanation.","width":256},{"text":"Yeah?","width":704},{"text":"His observation was the space needed for the algorithm to work in the second case is really small.","width":472},{"text":"If you're looking for the top ten things, you're heap only is ever an array of size like eleven.","width":333},{"text":"If you're doing the add and remove step, if you're always making it always be size ten, then the array is never any bigger than ten elements. ","width":448},{"text":"In either case, it's always, your array is really small. ","width":320},{"text":"And notice that the amount of memory that you need to use to do this algorithm has nothing to do with the number of elements in that array.","width":536},{"text":"So instead of it being an array, it could be a stream of elements coming to you over a network.","width":462},{"text":"It could be any source of data, potentially doesn't even fit in memory, and you can still find the top ten things in it.","width":576},{"text":"Because you are only maintaining ten elements at any time.","width":230},{"text":"So this one is nice because it's space complexity is really small.","width":384},{"text":"Normally we look at runtime complexity, which is what is the running time as a function of n.","width":448},{"text":"But another way of looking at algorithms is to look at their space complexity and say okay how much memory do they use as a function of n. ","width":448},{"text":"By increasing the amount of input data to this algorithm, how does the memory usage grow?","width":256},{"text":"Well in the first it's going to grow linearly with the amount of data you've got, because you've got to build a heap that contains all of the elements.","width":448},{"text":"Furthermore, the first one has to work given the assumption that you have all of the data available to you right now.","width":557},{"text":"The second algorithm can kind of just sit there and wait for the next element. ","width":256},{"text":"It can be days later, it could be a couple of minutes later.","width":128},{"text":"And it's always going to tell you what the top ten things were as of that point in time.","width":273},{"text":"So the second algorithm is actually really nice, it's an instance of what's called a streaming algorithm.","width":320},{"text":"So if you're curious you can go look up streaming algorithms that operate in this setting where you can't assume that all of your data is there, and you furthermore can't assume that you can even store all of the data in memory.","width":576},{"text":"You can't even assume that you've got big O of n storage.","width":201},{"text":"So you need big O of 1 storage to operate over a huge amount of data, and the second algorithm satisfies that.","width":832}]