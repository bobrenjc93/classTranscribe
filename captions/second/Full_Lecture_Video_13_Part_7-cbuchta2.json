[{"text":"Where have we seen this before? Lab Yay good!","width":704},{"text":"Prior to today where have you seen this before? 125? Okay. Stack Frames! Function calls!","width":704},{"text":"The first two weeks of the class. This is what we were doing every day. We were drawing a stack, Now you know why it was called a stack. This data structure is called a stack.","width":1024},{"text":"And the same concept applies to functions.","width":256},{"text":"In your program. Remember when youre program is executing. What stack frame is going to go away first?","width":704},{"text":"Most recent one called. Right. Main is the very last thing to go away but its the first thing put in. Main is always at the bottom and then function call one, function call two, function call three, function call 4. The 4th one is going to go away first then the 3rd one then the 2nd and the the first before main.","width":1152},{"text":"Weve seen this before its already being used to manage the memory associated with functions. On the stack. So this is a very familiar structure. But it could be useful to also have a progrmatic stack. ","width":960},{"text":"That is a data structure that represents a similar kind of thing.","width":320},{"text":"So this is a stack. What internal storage would you use?","width":320},{"text":"There are like all kinds of valid answers. I want to look at all of them.","width":448},{"text":"So what could i use? Give me 1 thing i could possible use. An array. Good. I could use an array.","width":576},{"text":"So lets say i have an array. Actually lets make it a small array first. ","width":960},{"text":"We have this array. Okay fine. Push 1. What do i do? How does my picture change where does the 1 go?","width":640},{"text":"On the left okay so 1 goes here. Push 2. Middle. Push 3. End. Push 4? ","width":640},{"text":"Resize. How big do i make it? Double. Right. ","width":512},{"text":"And thats the same exact analysis that we just did. ","width":512},{"text":"So we know that the amortized cost of that is going to be what? O of 1. So...","width":896},{"text":"The Star by it is to let you know thats amortized. Not worst case. What is the worst case? N","width":576},{"text":"Worst case could be N, amortized is what we really care about, im going to denote that with a little star so you know its no the worst case.","width":448},{"text":"Okay, so thats fine. ","width":256},{"text":"How do i do a pop?","width":256},{"text":"I would either blank out the cell or move my capacity marker or size marker down.","width":512},{"text":"So then if you think about it. If you think of this as being the picture. Wheres the top of the stack? In this array based implementation? The back of the array. The last element. The bottom of the stack is the first element.","width":1280},{"text":"This means that i can use a vector for this implementation. Remember vectors have push back and pop back.","width":512},{"text":"So push is just push back and pop is just pop back. You can use a vector for this very easily i didnt even have to write the resizing array myself. Thats handy.","width":768},{"text":"Okay, so thats good. How long will pop take for an array then?","width":512},{"text":"If we just talked about how to do it. How long does it take? Constant. Do i need to worry about amortization. No? We could I could. Why might i want to? What would i have to be doing to care about amortized analysis for doing pop for this structure?","width":1408},{"text":"If i want to make the array smaller. Suppose i pushed a whole bunch of stuff and i get this huge array. And then i pop it all.","width":512},{"text":"I really dont need an array of 3 and a half million elements when i have 2 things in the stack. So i could employ an array downsize strategy as well.","width":896},{"text":"And you can do a single amortized analysis for that,i wont do it here. You can do the same thing there. The one caveat is you probably dont want to do it when youre less than half. When youre just less than half full. Because then somebody can sit right at half way and insert remove insert remove causing a resize everytime.","width":1152},{"text":"So typically implementations will do resize when full to twice the size and downsize when less than 1/4 full. You have to be really empty for this to resize back down. Then it resizes down to just enough to hold.","width":1344},{"text":"You need to, if you did that then its hard to argue that its constant time without doing amortized analysis. How long does it take to downsize and copy the data? But were not gonna worry about that here.","width":960},{"text":"How would i do a peek? Just tell me the next thing thats gonna be removed?","width":256},{"text":"I heard constant yes but what do i do?","width":448},{"text":"Yeah i just check the index. Wherever the index thats telling me where the last thing is, just go to that array index.","width":448},{"text":"Okay, good. Is that the only way? No. Singly linked list. How can i do this with a singly linked list?","width":896},{"text":"Like this.","width":448},{"text":"Push we put a new node. not much thinking there. If i want to push 2, Where does it go?","width":832},{"text":"Does it matter?","width":192},{"text":"Suppose that i put it in the front? So i remember that if im using a singly linked list i have something like the head is here. I also have a tail pointer. And im gonna push 2 and im gonna stick it on the front okay. ","width":1152},{"text":"So that means that Im gonna make a new node and just doing push front. Weve already written this.","width":512}]