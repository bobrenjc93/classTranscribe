[{"text":"Now if this was a very small... two things could happen: our program could just crash - malloc() could just give a bad answer.  But we want to be a bit more systematic than that.  So at this point we'll go back to the operating system and say, \"Hey!  You know that memory stuff that's really valuable?  Give me some more, I need some more.\"  So actually malloc() at that point has to go back to the operating system and say, \"Hey, you know that memory you gave me?  I've run out.\"","width":2033},{"text":"I need some more. I'm addicted to the stuff, right? So, I need more memory.  So malloc() can get some more memory from the operating system. there we go.","width":733},{"text":"How does it do that?  Well, classically it would call something like sbrk().","width":640},{"text":"What is sbrk()? You can write this bit down if you want to.  Let's jump into the rabbit hole for a moment and think about our process where we've got all these memory addresses to play with.  ","width":1328},{"text":"So what do we find inside memory?  We've got our code, we've got our global variables or the static variables... up here we've got the environment and the stack...where's our heap live?","width":2355},{"text":"Just here.  It starts off just here.","width":547},{"text":"So it can grow, right?  We can say, \"Excuse me, system.  I actually need some more space.\"  And that's what sbrk() does.","width":596},{"text":"It says, \"Look, you've got this watermark (this threshold) of what the maximum address is.  I want to bump it up, I want to play with some more room.\"","width":1329},{"text":"So this means we could write a really, really simple memory allocator.  Here it is.","width":521},{"text":"Any time the program asks for more memory (x bytes) all we will do is say to the system, \"Hey!  I need more bytes.  This is the number I need.\"","width":999},{"text":"And anytime the program decides it's finished with some bytes, what should we do?","width":932},{"text":"Nothing!","width":119},{"text":"That's the simplest memory allocator we could write.","width":332},{"text":"It's not a very good one, though.  We're not re-using any memory.","width":608},{"text":"Because we're not keeping track of which pieces of memory are actually being allocated.  We're just simply saying, \"Oh look!  I've got some more passengers on my boat, I need a bigger boat.\"  Or, \"I've got more people on my bus, I need a bigger bus.\"","width":682},{"text":"And not keeping track of how many seats are actually unoccupied.","width":330},{"text":"So it's really, really fast but completely inefficient.  We're very quickly going to exhaust all of our memory.","width":500},{"text":"And so this sets the stage now for our memory allocator.  We actually need to start keeping track of which bytes are currently being used and which bytes are available for suitable calls to malloc().","width":854},{"text":"So we only want to call this sbrk() thing when we truly are out of memory.  When we have no way to allocate any more memory.  ","width":984},{"text":"So the MP (which will be out maybe the end of the week or maybe next week) is actually going to ask you to write an efficient malloc().  And it fact it's going to be a competition.","width":1056},{"text":"So there'll be a page with results and you can see if your malloc() is faster than your neighbor's malloc().","width":616},{"text":"So remember when they step away from the keyboard to put a sleep() call into their code.","width":505},{"text":"Okay, so what's to stop you from doing this all the time?  Easy: the competition is actually going to put a hard limit on the amount of memory that you are allowed to play with.","width":839},{"text":"So now we have to start coping with the fact that memory's being freed.","width":975},{"text":"So if we are working with writing a good malloc(), let me show you a little problem that we might run into.","width":1025},{"text":"Here's some memory that's been allocated.  Here's some other memory that's been allocated at different times.  And then our program says, \"You know what?  I'd like 2 KB.\"","width":1354},{"text":"Now you can see from my little diagram that I've actually got 3 KB of memory which are unused.","width":631},{"text":"But I cannot give you 2 KB.  I cannot find any space which is 2 KB because my spare space has all been fragmented.  It's no longer in a contiguous block.","width":1202},{"text":"So why can't I just take all the contents of this memory and just move it into there, and then carry on?","width":673},{"text":"Why can't I just move that?","width":232},{"text":"Why can't my malloc() just start shuffling stuff around?","width":365},{"text":"Yes, thank you! Yeah, I can copy stuff!  My malloc() can copy it to there.  However, the rest of my process is using pointers.  It assumes that the stuff that's inside here is where it is so it assumes that if I've got a variable that's pointing to a linked list that it's using this area.  ","width":1401},{"text":"So all those pointers will be invalid.","width":256}]