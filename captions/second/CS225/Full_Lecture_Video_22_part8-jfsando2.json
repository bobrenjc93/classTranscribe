[{"text":"No way. Not going to do it?","width":320},{"text":"Okay fine. Let's trace this code.","width":448},{"text":"Soooo uhhh. If the root is equal to null. we do nothing. There's nothing to be done.","width":384},{"text":"There's no memory associated with the thing. So that seems to be okay","width":320},{"text":"Otherwise, we clear out. Oh wait. I'm doing something wrong already.","width":768},{"text":"What is root here?","width":128},{"text":"Yeah, root is a copy of r","width":448},{"text":"It's a parameter. It's a copy of the original root.","width":448},{"text":"So what this code does is it clears out the left. It clears out the right. It frees this memory. That's what this delete does. And then it sets this equal to NULL. Is that what we wanted?","width":896},{"text":"No, so how do we fix it?","width":320},{"text":"Pass by reference is the answer. That's right. So we need to pass by reference there, and then this code works fine.","width":512},{"text":"And what's the running time of it","width":256},{"text":"Big O of N","width":384},{"text":"Which traversal does it happen to look most like","width":256},{"text":"post order thats right. 2 recursive calls and then a little bit of work","width":384},{"text":"So by ananlogy, to post order traversal","width":512},{"text":"okay good?","width":128},{"text":"alright let's keep going. alright here we go. This is a grandma moment. Grammy moment. Alright something totally different. I think level order traversal is a perfectly reasonable way of expressing the contents of a tree like this. The problem is level order traversal doesn't use the connectivity of structure in anyway. You jump from subtree to subtree. And so the approach to communica...","width":1920},{"text":"byyyeeeee","width":192},{"text":"The approach to communicating...isn't that mean. The approach to writing this algorithm is not a recursive approach because we can't express the level order of the main tree elegantly using recursive expressions of the level orders of their subtrees. Alright so here;s how the algorithm goes for a level order traversal","width":2048},{"text":"So the first thing we're going to do is we're going to create a queue and put the root on it, and here's my queue. Woah this is gonna be hard i'm gonna be doing a lot of writing. Here's my queue i'm going to put the root on it. Root node. Probably a point. Probably a root node pointer.","width":1472},{"text":"Alright so this is make a queue and add root.","width":320},{"text":"and then until the queue is empty do the following: remove an element from the queue, yell it's value. So this is a, b, yell the value. And add its children. Enqueue its children. Okay so that means I remove plus from the queue, yell its value, and enqueue its children. By convention we do that left to right. By convention i'm going to add minus and asterisk to the queue. Can I keep going here? I'm going to dequeue, yell and add children. Uh oh its an empty tree and the slash. Would you rather I put a NULL there? I don't know what a NULL looks like. Its a little box with a slash in it right?","width":5440}]