[{"text":"The reference to a parameter for the recursive call, right that's like the start of an edge in this picture.","width":960},{"text":"The passing of a parameter is like the path past this edge going forward. Yes, do you buy it?","width":1088},{"text":"So when I do cRoot->right, it's like I'm walking down that edge, kind of.","width":512},{"text":"And the actual visit of a vertex corresponds to this moment or this moment or this moment.","width":960},{"text":"So those three red dots correspond to actually being inside this program code here or here or here. ","width":896},{"text":"The evaluation of this conditional is constant time. So we're actually not going to worry about it very much.","width":704},{"text":"But now what we observe, is thinking about the vertices and the edges actually corresponds to exactly the code that sits here.","width":832},{"text":"It corresponds to at least accounting for what happens in the code that sits here.","width":512},{"text":"I forgot the other side of the edge.","width":448},{"text":"I forgot this part of my little walkaround. That corresponds to passing control back to the call function.","width":576},{"text":"What's the punch line here? The punch line is that the amount of work that we do per data element is constant.","width":1152},{"text":"It's three little visits, a function call, a return, a function call, a return.","width":960},{"text":"That's it, that's constant.","width":128},{"text":"But we do that for every vertex. If it's constant per vertex, then what's the running time?","width":448},{"text":"Linear.","width":192},{"text":"So constant O(1) per node implies O(n) for the algorithm.","width":1024},{"text":"Ok, any question about that?","width":448},{"text":"Now notice that this is different than the way we evaluate running times for a iterative algorithm.","width":640},{"text":"Usually, when you see a for loop, you think oh that's a factor of n.","width":384},{"text":"At least that's where you start in your reasoning. When you evaluate things recursively, things get very messy.","width":704},{"text":"Especially when you don't know the size of the recursive call.","width":384},{"text":"It's easy if you know the size of the recursive call is n-1, right. That makes it easy.","width":384},{"text":"But the problem setting up a recurrence here, is we don't really even know how big to make this.","width":512},{"text":"We don't know what the size of the recursive call is here. Because we don't know the size of the other one was.","width":512},{"text":"Another way of evaluating how this algorithm works is to look at what happens for each vertex.","width":576},{"text":"Similarly, if you had a vertex, and for every vertex, you travelled to the root and back. For each one, a good place to start the analysis, is woah, at every vertex I go all the way back up the tree. that would be one way of approaching it.","width":1600},{"text":"Alright, any questions about all that?","width":192},{"text":"The punch line is, traversals run in linear time.","width":384},{"text":"If they don't, something else is going on. And it's not good.","width":448},{"text":"Traversals should run in time proportional to the size of the data.","width":512},{"text":"It fits your instinct.","width":128},{"text":"And anything that smells really does smell for a reason.","width":256},{"text":"OK, I have one more question about this. So, all traversals should run in size proportional to the data.","width":512},{"text":"Is this piece of code which I believe was similar to what you wrote last Friday, is it public or private in the binary tree class?","width":640}]