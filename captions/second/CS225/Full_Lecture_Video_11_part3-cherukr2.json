[{"text":"You only use virtuals if there is a chance that it is a base class.","width":960},{"text":"Furthermore, if your class is available, you do not really know whether it is going to be a base class or not because that is a part of the design. ","width":768},{"text":"Where you can strongly argue that virtual is not necessary, you should eliminate it because it will make faster code.","width":640},{"text":"So use it judiciously. Anyway, so here is an example that I think is really cool. I am going to declare a farm, it is not unlike a garden, but it is a collection of animals. Notice what I can do here. I can use this pointer to represent an array. When I instantiate it I can declare it with square brackets to make a dynamic array.","width":2432},{"text":"And I can let every element be of type animal pointer, each of which can then be instantiated with a different derived animal. ","width":832},{"text":"So, when I actually fill in the value of farm sub k I say new animal sub whatever or animal whatever.","width":512},{"text":"So, new pig, new horse, new cow.","width":192},{"text":"Alright, notice what this is. It is an array where the things are not necessarily the same. So this is the way that you would implement what is called a heterogeneous array in C++","width":1024},{"text":"So this is a heterogeneous array.","width":384},{"text":"in C++","width":256},{"text":"Not all elements have the same type.","width":576},{"text":"But it gets cooler than that, because it means we can do things like this. The polymorphic behavio","width":832},{"text":"The polymorphic behavior and the ability to insist that that function be defined means that we can demand that each of those classes has a speak function and that they are instantiated in a class specific way. So what happens for this for loop? You get 'barf, oink, nay, moo, quack'.","width":1664},{"text":"Alright, so we already talked a little bit about the fact that inheritance gives you this polymorphic behavior at the significant cost to performance, because at compile time the system has to look at the code and see what kinds of things might require this polymorphic behavior, and it has to build the machine code for all of it. So that makes for bloated machine code. Now that is called dynamic polymorphism, where you might not know at the compilation of your code what kinds of things this will be instantiated with and you do not need to know it. So that comes at a performance cost.","width":4928},{"text":"There is another kind of polymorphism that because of this performance issue was introduced into the language a little bit later. It is implemented via this construct called templates.","width":1152},{"text":"And it is a kind of polymorphism where all of the type dependent information is known at compile time. So there is no ambiguity and there is no need to build in this flexibility at compile time.","width":1216},{"text":"So that is our next topic. Templates. I have some code. Here is my main. I am using some integers and some characters and I have got these two functions that swap them. There are my two functions. What do you notice about the code. There are 2 germane points to be made.","width":2048}]