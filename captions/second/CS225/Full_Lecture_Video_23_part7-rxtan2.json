[{"text":"65 ok let's try it and count.  We are going to go off on search node and this is going to require more.  I think he can handle more.  Can you handle being wring.  So we are going to go on a search for 65.  Now is 38 65?  That is one comparison.  This one is easy.  You can all say no.  We have not founf it yet and we all know where it must be.  To the right.,  Good.  Have we found it?  NO.  So that is another comparison.  Where must it be? To the right.  Good.  Have we found it? NO  That is another comparison. Where must it be?  To the left?  Have we found it?  No.  To the left?  Oh But there is nothing to the left.  So fine 65 is going to return  I dont know what the interface is but i will say that it is going to return null because it is not there.  All right.  So the same kind of reasoning that we apply to insert can be applied to find as well.  Now, here is the little foreshadowing for you.  I am going to spend the whole lecture on remove.  Ok, did you have a question?  ... Oh good question, you are two lectures ahead of the game.  So she is worried about the fact that it might not be the case that the tree is so beautiful.  This tree is beautiful.  Actually, it is not that beautiful.  What the heck is she talking about?  Because we have approximately the same structure on the right as the left and we are pretty lucky.  She is already thinking what will happen if they are not the same structure.  But we are not there yet.  We are going to do the same stuff first.  What is the running time for traversal?  Big on of N still.  Good. OK Let's write some code.  I want to return a tree node pointer and writing a function called find for the BST class and it takes as a two values the root of the tree and some key to find.  So here is the root and i am going to call this version of find like this.  Find on root and then whatever key I am trying to find.  Let's find for you this example wbatever.  I am not actually going to do that.  So if croot is equal.. We are going to think about this recursively and the way to do that is to break down the trees into two kinds.  The first kind is null.  Sp if it null, what should you return?  So return null. We could actually return croot here because it is null.  So otherwise, the tree is not empty so now we are now actually in the recursive case.  We are actually in the case where we are not null.  We are in the general case If we are in the general case, we still have things to consider.  Those things to consider if the root is equal to the key.. what should we do in that case?  Return the root. Otherwise, if croot key is wait.  I want to do it this way.  It is easier for me to think about it.  If our input key is less than croot's key, is that a safety reference?  Yes because we know that croot is not eqqual to null.  If it is less than croot's key, then return.. we are going to go looking for it in croot's left.  So we are going to return the find on croot's left.  ","width":20736}]