[{"text":"yeah","width":280},{"text":"right","width":248},{"text":"we have to return the value or grab this value for returning and then decrement the size, and that is it.","width":625},{"text":"","width":10},{"text":"so pop pieces of cake","width":142},{"text":"","width":7},{"text":"","width":0},{"text":"","width":1},{"text":"alright","width":26},{"text":"now let's talk about this issue of growing the array somehow","width":388},{"text":"okay","width":126},{"text":"so this discussion we are about to have apply not just for stack but also for queue","width":562},{"text":"any linear structure that uses dynamic array","width":270},{"text":"list 2 I just obfuscated it for list. ","width":164},{"text":"I said we are not gonna talk about it","width":142},{"text":"Umm, so here is the scheme","width":248},{"text":"suppose your array is full","width":206},{"text":"and another piece of data comes along","width":213},{"text":"okÂ ","width":247},{"text":"the idea is going to be","width":165},{"text":"that we are going to allocate some new spaces","width":326},{"text":"copy over the data","width":197},{"text":"from the old spaces","width":184},{"text":"yeah, copy the data the data from the old spaces","width":289},{"text":"and then insert the new spaces in its position in the larger array","width":385},{"text":"and then of course, you know, free up the old space and then rename the new spaces","width":425},{"text":"okay? do you like this","width":310},{"text":"ok","width":109},{"text":"that whole copy the data thing","width":185},{"text":"Laaaa","width":51},{"text":"that should make you crench","width":121},{"text":"right?","width":35},{"text":"copy the data ouch","width":117},{"text":"that hurts","width":50},{"text":"so our goal is to make the copy the data something that is rare","width":435},{"text":"our goal is to make it rare and somehow still make it so that we can accommodate flexible data size","width":585},{"text":"so how do we do this resizing?","width":224},{"text":"let's look at three different options, ok?","width":260},{"text":"so for simplexity, all of these resizing schemes are going to start with an array of array of size one","width":481},{"text":"then go build from there.","width":159},{"text":"so we are always gonna start with an array of size one, after it fills, we will do copying","width":355},{"text":"more over in analyzing these particular resizing schemes","width":387},{"text":"we only really gonna care about the copying that happens","width":332},{"text":"the inserting new data would have to happen anyways","width":212},{"text":"so it is sort of the extra work that we are gonna count for","width":241},{"text":"alright so","width":86},{"text":"lets say that our resizing scheme says well if new data comes along, if your array is full, and new data comes along","width":805},{"text":"it supposes to look like a person, did you get that, can you tell?","width":361},{"text":"so if your array is full and new data comes along","width":281},{"text":"then what you are gonna do is to make an array just big enough","width":280},{"text":"just big enough, then copy and insert","width":242},{"text":"that is the first scheme","width":132},{"text":"and the question is: how does this scheme do over a sequence of say n pushes to the structure","width":735},{"text":"so this bottom row is supposed to be, supposed to indicate n","width":400},{"text":"ok, alright, lets look at this","width":332},{"text":"in the first case, one thing gets copied","width":231},{"text":"in the second case, two things get copied.","width":226},{"text":"in the third case, three things get copied","width":269},{"text":"so we can write the expression that captures the amount of copying","width":465}]