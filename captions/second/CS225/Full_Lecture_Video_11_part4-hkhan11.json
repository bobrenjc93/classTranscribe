[{"text":"Yes? Yes very good so uh the code is identical except for type information. ok. what else do you notice about this code. yea. yea. you.  very good. yeup it actually doesn't do anything. neither function actually does anything. ok and how can I fix that. well fix that one first. How can I fix that. Pass by reference. very good. Don't say pointer to me. Alright good. so lets talk about the first point in a little bit more detail. so this is fine right to have these two functions that do pretty much the same thing. in fact if someone were asking you to include these two functions in an mp, you'd go. oh yay. They are about the same. I can cut and paste. I can cut and paste my solution from one and I've got the other one done. yes right. the problem is that then you have to go back through and kind of check and make sure that your type information is updated correctly. now the compiler is gonna help you mostly with those kinds of bugs but its still a pain in the neck and in fact if somebody came down and said there is new technology for swapping ok. unlikely to happen but it could. somebody came down and said theres new technology for swapping. A drawback of doing it this way is that you would have to go and find all of these little swap functions and change them right to take advantage of this new new fangled swap algorithm. ok. yes its artificial. alright so code reuse is important for maintainence and incremental improvement of code. ok. and we admit here that look . they are about the same. so how on earth are we going to unfiy those two functions into one thing but still allow for type information to be recorderd in the code. and the answer is that C++ provides syntax for passing as a parameter type information. type information into the function. ok. alright so how does this work. I have my same main except that i am writing a single swap function. the way we tell the system exactly how we want swap to work is we have this alternative syntax for parameterizing type and we put in between angle brackets. so first you have the type parameters and then you have the value parameters. similarly here we would do char and I'll tell you right now that if you forget to do this when the compiler can. it will infer it for you so sometimes its not the case that you'll see those angle brackets even for templated class ok so if the system can infer it. it will. ok. so now that's how you use these template functions. how do you define them. well you prepend the function's signature above the first line. it becomes the first line. um with this key word template this is a key word. class which is also a key word but it could be type name instead.","width":17152}]