[{"text":"Because this works. Because we setRight. Yes, we didn't do a dereference there. Yeah yeah, sorry.","width":576},{"text":"Yes we do!","width":512},{"text":"Yes we do","width":64},{"text":"Oh, no we don't","width":128},{"text":"No, cause it's while it's not empty and yes we do. We absolutely do.","width":384},{"text":"I am confusing my empties with my nulls","width":128},{"text":"We absolutely need it because what you're thinking and what I was thinking was that by putting the NULL there the tree's still empty but it's not. So on that. ","width":832},{"text":"On that first iteration. On that first iteration here, the Queue's not empty, right?","width":576},{"text":"It's not. It has a NULL on it. Because we put it there.","width":192},{"text":"croot, yeah that's true.","width":448},{"text":"Right.","width":256},{"text":"Right, right right.","width":128},{"text":"That's the right correction.","width":128},{"text":"We still need to do it It's just the wrong test case sorry","width":320},{"text":"okay, have I completely bungled it?","width":192},{"text":"You could stay for the first 10 minutes of the next hour and it'll be all smooth but there will be no jokes because when I like accidentally make a joke in here and try to tell it in the second hour, total flat.","width":832},{"text":"The whole algorithm's truck thing. I thought that was kind of cute right? Second hour totally fell flat.","width":512},{"text":"Totally.","width":64},{"text":"Alright.","width":256},{"text":"So the question is about how quickly these things evaluate. How do you know that enqueueing and dequeueing doesn't happened super quickly. Right, so we're talking about the difference between constant factors here and asymptotics analysis. The actual. The actual difference between empirical running time in this thing depends on you know, where you're running this in the cloud, whether you've implemented your queue as an array or linked list. It depends on a lot of different things. But what we're arguing over is constant factors and so I'm saying that the inherent value of the algorithm which we measure ignoring constant factors is not different one way or the other. It's always reasonable when you have two equivalent asymptotically equivalent algorithms. It's always reasonable to give them a head to head run. Simulated run in your context if it really matters how fast, how concretely fast they are. Okay, if you're. Yes, right.  But here we're mostly talking about asymptotic performance. Alright, any other questions about this? Did I clarify that first thing so","width":5504},{"text":"You do have to have a conditional and the conditional should be around whatever you put in the queue and I just moved on autopilot.","width":704},{"text":"Sorry.","width":64},{"text":"Alright, any questions about it?","width":128},{"text":"Okay, I don't remember what comes next. Oh, the conversation we just had about binary trees and about traversals was really more one of implementing an algorithm. We're gonna step back for a second and talk about an abstract data type. I think I am coming to believe or coming to feel perhaps that this ADT is the most important one that we use as sort of day-to-day programmers. And the genesis of my feeling about these dictionaries comes from my affection for python and getting things done. Okay?","width":2752},{"text":"So, I cannot say necessarily that it will be readily apparent how powerful these things are in the context of the applications we do. But there's classical understanding that will play into it that when you are programming in other languages, you'll go \"oh I'm so glad I know this stuff\".","width":1472},{"text":"Alright, so the ADT that we're going to be interested in is a dictionary.","width":384},{"text":"The interface to a dictionary is at the bottom. We're gonna insert remove and find by a unique identifier.","width":576},{"text":"That we commonly refer to as a key.","width":192},{"text":"Uh, so, the ADT itself. It consists of this. The data looks like key, value pairs and the interface. The functionality of the ADT is insert, remove, and find by the unique identifier. Okay, so I want to speculate for a second, just cause it's kind of fun to do so, on if I had the following data. If I had the following data, how it would seem reasonable to implement a dictionary.","width":2688},{"text":"Okay, so my data here is a locker number. This is my key.","width":768},{"text":"And the values that I'm going to put into the dictionary or attached to each identifier. I'm gonna refer to here as my data as it's commonly referred to as value.","width":896}]