[{"text":"Right... so when we try to copy this string array, when we try to copy this string array it just copies the pointer value that atts held and that ended up tingling our memory, right? Okay so one way of describing our use of the heap for this string array is that we used dynamic memory. Okay so that heap memory is dynamic memory and that's what makes it so that you have to declare and define a custom copy constructor. So why did we need one? The object uses heap or dynamic memory. And anytime you have an object that uses dynamic memory ,that is declares a new in the constructor is a good clue, then you need a custom copy constructor. Okay everyone good?","width":4800},{"text":"Any questions about this? Okay, alright. Sooooo, we're not done, because we've got these complex objects, we've got these complex objects now that may or may not be declared in the heap. If this is a sphere, if this is a sphere, say a then this part of it lives in the stack and the other part is instantiated via a new command and it lives in the heap, that's right, so we've got this object that kinda has pointers all over the place. I want to trace a little bit of the piece of code and show you where a problem occurs or let you see where a problem occurs. Okay.","width":3328},{"text":"So, my int main here declares a sphere its name is a, and we're going to pass a in as a parameter to this function. Now, you know at this point that a copy is made of, ","width":1216},{"text":"look, we've got a good copy constructor here, we've got a copy is made of a onstack (3.2, 3) and we've got this stuff pointing off into heap memory, okay, the copy constructor knows how to do that and I'm going to ignore this one for a minute because it doesn't help my point any. At this point, now we're going to do some computation and maybe ask its changed, you know maybe we just use it as an inout variable whatever and then the function stops execution","width":2688},{"text":"and control is passed back to you know, just after myFun, so control is passed back to main. Now the question is, what happens to s? When control is passed back, what happens to s? It goes out of scope is one way to describe it, and what happens behind the scenes when something goes out of scope? Yes? That's right, it is removed from the stack like this. Okay what do you think. Yeah there's a memory leak, that's right. That memory, that memory that we asked for from the heap right here, this memory is leaked. Okay by default. So, we're going to help out the system, we're going to provide what's called a destructor for the system to use when removing variables from the stack. Now, suppose that I had just asked for this memory via a new statement, actually that one up there. If I just asked for that up there via a new statement, how would I give it back, how would I let the system know I'm done with it? Delete, that's right","width":5760},{"text":"So my destructor or the code that I am going to write for the system to use when a variable goes out of stack is just delete [] atts. Okay. Any questions about that? So in mp2, hold on just a sec I will get you don't let me forget, in mp2 you are asked to write a destructor, but its for a more complex type. In mp2, instead of objects in the array, you have pointers in the array and memory has been allocated for each of them. So thats why differentiates what I just did here from mp2 so be aware of that","width":3584},{"text":"And that if in mp2 I just deleted this array, then all of that memory would be leaked. Okay so that, so that should be sort of some insight into what your destructor should look like for mp2. Okay there was a question, yes? ","width":1344}]