[{"text":"65 okay let's try it and count. Okay we are going to go off on search no that's going to require more.","width":453},{"text":"But we'll try, we'll prove him wrong","width":157},{"text":"I think he can handle it. Can you handle being wrong about 3? Alright, thank you.","width":307},{"text":"So, we're going to go on a search for 65.","width":354},{"text":"Now, is 38, 65, that's one comparison. Is 36, 65? This one's easy. You can all say no.","width":607},{"text":"Alright, so we haven't found it yet, but we know where it must be. Where must it be? To the right, good.","width":506},{"text":"Have we found it? No, so that's another comparison. Where must it be? To the right, good. Have we found it? No, that's another comparison. Where must if be? To the left.","width":930},{"text":"Have we found it? No, that's a comparison. Where must it be? To the left. oh, but there's nothing to the left. ","width":609},{"text":"So, Find of 65 is going to return. Well, I don't know what the interface looks like exactly. We'll say it returns null.","width":692},{"text":"okay, because it will return what's there the tree node pointer.","width":208},{"text":"Alright, because it's not there","width":236},{"text":"Any question about that","width":128},{"text":"So the same kind of reason we applied to insert can be applied to find as well","width":384},{"text":"Now, here is a little foreshadowing for you","width":159},{"text":"I'm going to spend a whole lecture on remove","width":179},{"text":"Did you have a question","width":217},{"text":"Good question you are two lectures ahead of the game. okay","width":714},{"text":"So, she's worried about the fact that it might not be the case that the tree is so beautiful.","width":600},{"text":"This tree is beautiful. It actually isn't quite beautiful. What the heck is she talking about, right?","width":417},{"text":"Because we have approximately the same substructure on the right as on the left.","width":554},{"text":"Do you see that? We have approximately the same and we're pretty lucky.","width":248},{"text":"She's already thinking about what happens if those are not approximately the same substructure.","width":379},{"text":"Does the world get ugly and it does. But we're not there yet. We're going to do the simple stuff first.","width":431},{"text":"Okay. What's the running time for traversal?","width":235},{"text":"Big O of n still, that's good that's a review question","width":363},{"text":"alright, so let's right some code. I want to return a tree node pointer and I'm writing a function called find for the bst class.","width":965},{"text":"and it takes as two values the root of the tree and some key to find","width":864},{"text":"Okay","width":106},{"text":"so, here's root and I'm going to call this version of find like this. Find on root and then whatever key I'm trying to find. Let's find forty in this example. I'm not actually going to do it","width":1232},{"text":"If cRoot is... we're going to think about this recursively and the way to do that is to break down the trees that you consider into two kinds.","width":821},{"text":"The first of which is Null. So, if your original tree is Null what should you return. okay so return null.","width":713},{"text":"we could actually return croot here it would hurt anything because it is null","width":367},{"text":"We just tested that it's null. Alright, find if so otherwise otherwise the tree is not empty.","width":538},{"text":"so now we are actually in the recursive case. We are actually in the case where we're not null. We're in the general case okay. If we're in the general case we still have some things to consider.","width":961},{"text":"Those three things to consider in this general case are if the root is equal to the key. What should we do in that case?","width":558},{"text":"return the root.","width":164},{"text":"otherwise, if croot's key wait I want to do it this way. If our input key is less than cRoot's key is that a safety reference? Yes because we know cRoot is not equal to null. That's the other case.","width":1747},{"text":"If key is less than cRoot's key then what? Return. What are we going to return? We are going to looking for it. Right? We're going to go look for it in cRoot's left. So we are going to return the find on cRoot's left.","width":1368}]