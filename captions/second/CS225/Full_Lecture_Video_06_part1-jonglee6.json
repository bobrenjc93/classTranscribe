[{"text":"Okay. They have a location. Chosen for you by the system. Location is always chosen for you by the system. ","width":703},{"text":"In the stack, it sort of next available space. And the name is there explicitly given. X zero , X (1) , x(2). Do I need to keep writing?","width":1269},{"text":"Upto X(4). Okay Of course, their values are garbage. ","width":755},{"text":"Alright, any question about that? ","width":233},{"text":"Okay, Now, again. That memory, the size of the memory cannot be changed.","width":615},{"text":"So, it must be known at compile time. If you do not specify a size.","width":821},{"text":"Or if your size isn't in the variable, system cannot figure out. Some big block will handed to you that is irresponsible request of the system for your stack.","width":1216},{"text":"So, you want, if you are using static memory, if you are intending to array on stack, you need to be able to specify how big it is. Don't let it be flexible because it will be too big and you won't know how big it is.","width":968},{"text":"So you won't know how to walk, how to avoid walking end of its iteration. ","width":589},{"text":"So, nice small arrays are perfectly reasonable to do only if you know how big it should be.","width":464},{"text":"Now, think of all situation where you don't know how big array should be.","width":448},{"text":"Any time the size of data is changing, can change, you don't necessarily know how much memory you are going to need, or contain needs.","width":1056},{"text":"So, we have this contrasting idea of a dynamic array one which you can resize to whatever size you need","width":816},{"text":"Here's how this works.","width":341},{"text":"You set up x as in integer pointer in the stack, so ops","width":469},{"text":"X is somewhere in the stack. It's an integer pointers so it has something that needs to be allocated and then","width":704},{"text":"when you ask the system for a memory. you say, YO, I need three integers from the heap","width":585},{"text":"And the system goes out define you just a right amount of space. Just right amount of space. Returns memory address","width":768},{"text":"which is then what stored in X.","width":320},{"text":"Now, Here is the cool thing","width":256},{"text":"Here is the cool thing: the syntax referring to the memory, is exactly what you expect any old array that is square brackets find the right element.","width":1050},{"text":"For example, I can execute for loop that says take i from zero upto size. ","width":640},{"text":"And put i + 3 in position in sub i. Now where is X sub of i in each case?","width":780},{"text":"This one is x zero, this one is x one, this one is x two.","width":483},{"text":"So we end up here, here is three and four and five.","width":385},{"text":"Any question about that?","width":250},{"text":"Alright, I want to give you another thing hang onto. Another thing to justify is to use of pointers, as the way creating things.","width":832},{"text":"Look at the syntax for second. Here is how to think of it. The square bracket is like a D-reference So X de-reference and then i steps forward","width":1280},{"text":"Okay, Got it? So it's x de-reference i steps foward and that binds you the memory location","width":866},{"text":"Wondering if pointer arithmetic applied here, Yes you can use pointer arithmetic to find your element of array. But code would be unreadable and go head and use square brackets.","width":1280}]