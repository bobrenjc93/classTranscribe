[{"text":"and we commonly refer to it as the IOP, OK","width":448},{"text":"we also have a notion of in-Order successorÂ which we refer to as the IOS","width":722},{"text":"and it is the min element in the right subtree","width":448},{"text":"now I have a very very subtle question for you","width":342},{"text":"OK, we're talking about removing, we're talking about the algorithm for removing a node with two children OK. We're talking about the algorithm for removing a node with two children.","width":992},{"text":"Do I have to worry that the in-Order predecessor does not exist?","width":384},{"text":"Do I have to worry that the in-Order predecessor does not exist","width":382},{"text":"No! Because I am always removing a node with two children, OK. So I don't have to be kinda crazy with my error checking, right?","width":538},{"text":"My task defines my tas..  my task as it is defined makes it so I don't have to worry about that they are not being an in-Order predecessor","width":640},{"text":"I wouldn't be doing a two-child remove if they weren't one","width":234},{"text":"OK. Alright, any question about that?","width":192},{"text":"OK. So what is this code going to look like, it's going to find the in-Order predecessor","width":548},{"text":"it's going to actually swap keys which we don't like very much, but we're gonna do it anyway. Keys aren't that expensive, they are not usually that huge of data items.","width":773},{"text":"So, we're going to swap keys. So one, find IOP.","width":448},{"text":"Two, swap keys. ","width":320},{"text":"Three, remove IOP","width":256},{"text":"OK, snip it off.","width":640},{"text":"Any question about it?","width":152},{"text":"Do you guys ready to write some code?","width":256},{"text":"Alght","width":192},{"text":"write some code","width":192},{"text":"OK, so notice that the function that I wanna write is doRemoval.","width":448},{"text":"OK, and that's what I refer to in a recursive skeleton","width":297},{"text":"Am..  and it assumes that I am passing in the node in the tree that I wish to remove and moreover, I handle on it that exists in the tree.","width":896},{"text":"So, for example , if I'm doing a two-child remove of 38, croot is not a copy of the pointer holding on to node 38. It is a name, another name for the node...","width":1120},{"text":"the pointer to the node containing 38, OK.","width":232},{"text":"Similarly, if I do a two-child remove of 13, and I make a change to croot, I am changing 38's left child. And that is accomplished because I am passing the whole thing by reference.","width":1024},{"text":"That's the intention here.","width":256},{"text":"OK. Ahh...","width":320},{"text":"one, no, one, two.","width":212},{"text":"The blanks contain the values no, one, two. You fill them in.","width":640},{"text":"Real quick, take a look at the code, you fill them in.","width":1024},{"text":"What you get? I would hand you my thing, but I want you to have sounds so I am not wireless today.","width":424},{"text":"What did you get? What's the first blank?","width":128},{"text":"No child remove, very good. Because that says both of the children are NULL","width":512},{"text":"What's the second one?","width":128},{"text":"Two, good!","width":256},{"text":"And the other one?","width":128},{"text":"One, good. OK, why did I do that?","width":320},{"text":"Why did I do that?","width":186},{"text":"It doesn't go one, two, zero, one, two. Ahhhh...","width":222},{"text":"Why would I do that?","width":105},{"text":"Yeah?","width":369}]