[{"text":"There we go","width":64},{"text":"okay, in this executable code ready to be linked with anybody who'd like to use it","width":384},{"text":"Alright fine. Well I know somebody who'd like to use it. This main would like to use this compiled code.","width":512},{"text":"All that has to be done is sphere.h has to be included...oops... #include sphere.h here and then these two effectively are compiled together","width":1600},{"text":"into main.o and how do we get sphere and main linked? ","width":640},{"text":"Yeah the linker does it for us. So it's the linker that creates the union between main and sphere","width":640},{"text":"alright","width":128},{"text":"And that's that serve... all of that process is orchestrated for you by your make file. That's the whole point of the make file so you can do all of that separately and put it all together and not have to type it out every time when your trying to compile your code","width":1024},{"text":"K","width":64},{"text":"Now, the world is a little bit different in the case of compiling templates. So again we've got sphere.h and sphere.cpp and main.cpp but you notice on the previous page the compiler detected...the compiler could detect that it didn't have a plus operator for integers and strings","width":1984},{"text":"and what's going on there  is that the compiler needs to know ahead of time exactly how and so and so you got a compiler error atom wasn't created the code for the atom function was not created. Now the reason that that happened is because the code for all of the use of your template function must be visible to the compiler all at the same time. That means that main cannot be compiled separately from sphere.cpp. ","width":3264},{"text":"And more importantly sphere.cpp cannot be compiled separately from main and more importantly sphere.cpp cannot be compiled separately from main because in order to make the sphere class you need to know how spheres are used. The type of thing that your passing in to spheres to use for its radius I don't know. But the parallel falls apart alittle bit here","width":1280},{"text":"Okay, so what do we do? The main principle is we do not expect different behavior from the clinet code. The client code is still going to say #include sphere,cpp. K?","width":1216},{"text":"","width":128},{"text":"H","width":64},{"text":"","width":192},{"text":"Geez","width":64},{"text":"Sphere.h . We don't want the client to have to change so the client is still going to say # include sphere.h. But it can't just be sphere.h it also has to be the implementation. So how're we going to do that? what are we going to do here? When we compile this we're going to compile it together and all the code has to be visible","width":1664},{"text":"","width":320},{"text":"And we don't want the client to change code, change behavior. Yeah","width":256},{"text":"","width":256},{"text":"Yeah","width":64},{"text":"","width":64},{"text":"look at this","width":128},{"text":"","width":64},{"text":"The only thing we're including is sphere.h so that is the only code we get. So the only way that that include statement can include all of the sphere class definition is if we say # include sphere.cpp at the bottom of sphere.h and now when you do this #include sphere.h you actually get all the code. And then you compile main.cpp and all the compilation happens at once. There's no use for the lnker in this case. Yes?","width":2368},{"text":"","width":128},{"text":"Because the declaration of the class has to come first. So the class declaration, the implementation, the member functions, and then the client code that uses them. K? All right. Yes?","width":768},{"text":"","width":320}]