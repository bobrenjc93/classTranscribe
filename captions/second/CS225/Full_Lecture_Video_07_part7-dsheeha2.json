[{"text":"Okay, now if you don't write an explicit copy constructor the system will provide you one, and I'm going to tell you a narrative about what the default one give you in just a second.","width":768},{"text":"Okay, so one location where the copy constructor is called is when you pass parameters in, that's how by value happens, that's how pass by value happens.","width":832},{"text":"Another case that it happens is like this. You are allowed to declare a sphere and then to declare another sphere to be a copy of that one.","width":1088},{"text":"Okay, so maybe in here you would change a somehow. And this b, the declaration  of b with another sphere as an argument is as close as we come to explicitly invoking the copy constructor.","width":1418},{"text":"Okay, any question about that?","width":496},{"text":"Okay, there is a third use that merits a complex discussion.","width":448},{"text":"That third use actually occurs in the first example perhaps. Ah I cannot change my pen color, I'm so sorry, things are kind of broken here.","width":704},{"text":"So the question is what happens when you say return s?","width":576},{"text":"We sort of implied that the execution is the same between passing a parameter and returning a parameter.","width":768},{"text":"But in this case, actually, that copy constructor may not be called, it may not be called.","width":614},{"text":"The system will decide whether or not it knows what you mean and in certain circumstances the copy constructor will not be called.","width":613},{"text":"So you cannot rely on the copy constructor being called upon returning by value.","width":448},{"text":"So let's see, where can I write that? This may or may not call the copy constructor.","width":704},{"text":"And the reason for it is simply that when you're returning a value, if you can maintain the data in memory some place, making another copy of it ends up being like an extra copy.","width":1024},{"text":"So you're code actually executes faster if it doesn't have to make extra copies all over the place and so where it can it will avoid invoking the copy constructor.","width":768},{"text":"Alright, any question about it? We'll talk about it more later. We say that the return copy is elided, if you wan't vocabulary associated with it.","width":896},{"text":"Okay, so we need a copy constructor and I said the system provides one for you. Let me show you what it does by default.","width":576},{"text":"Okay, so let's assume that we have an apple a set up in memory, a red, juicy, crunchy, and we pass a to a function.","width":960},{"text":"Here's what happens by default, the parameter gets a new version of a and a member wise copy is made.","width":896},{"text":"Now, that's fine, because doubles know how to copy themselves and it's fine because integers know how to copy themselves, they have valid copy constructors essentially.","width":1088},{"text":"And it's also fine because pointers know how to copy themselves, what does that mean?","width":1216}]