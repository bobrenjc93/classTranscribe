[{"text":"Yes we do, yes, we do. Oh we don't. No, because now, well, it's not empty. We didn't change. Oh, yes. We do. Absolutely we do. I am confusing my empties with my nulls. We absolutely do need it, because what you're thinking what I was thinking is by putting a null there, the tree's still empty but it's not. So, on that, oh darling. On that first iteration, on that first iteration here. The queues are not empty, right? It's not. It has null on it, cuz we put it there. Croot, yeah, that's true. Right. Right, right, right, right. That's, that's the right correction. You still need to do it. It's the wrong test case. Sorry. Ok, have I completely wrong go it? You can stay for like the first ten minutes of the next hour and it then will be like all smooth, but there will be no jokes, because when I like accidentally make a joke in here and then try to tell it in the second hour, total flat. The whole algorithm's truck thing, I thought that was kind of cute, right? Second hour, totally felt flat. Totally. Alright. So the question is about how quickly these things evaluate, how do you know that enqueuing and dequeuing doesn't happen super quickly. Right, so we're talking about the difference between constat factors here and asymptotic analysis. The actual, the actual difference between empirical running time on this thing depends on, you know, whether you're running this on the cloud, whether you're implementing the queues as an array or a linked list. It depends on lots of different things, but we are arguing over is constat factors. And so I'm saying that the inherit value of the algorithm whick we measure, ignoring constant factors, is not different one way or the other. It's always reasonable when you have two equivalent, asymptotically equivalent algorithms, it's always reasonable to give them a head-to-head run, simulated run in your context, if it really matters how fast, how concretely fast they are. If you're. Yes. Right. Here, we're mostly talking about asymptotic performance. Is that, is that good? OK. Alright, any other questions about this. Did I clarify that first thing, so you do have to have a conditional and the conditional should be around whatever you put in the queue. And I was just on autopilot. Sorry. Alright, any questions about it? Ok, I don't remember what comes to the next. Let's see. Oh. The conversation we just had about binary trees and about traversals was really more one of implementing an algorithm. We are gonna step back for a second and talk about an abstract data type. I think I'm coming to believe or coming to feel perhaps that this abstract data type is the most important one that we use at sort of day to day programmers. And the genesis of my feeling about this dictionary comes from my affection for python and getting things down. OK, so I cannot say, necessarilly, that it will be apparent how powerful these things are in the context to be applications we do, but there's classic understanding that we'll play into it that when you are programming in other languages, you'll go, oh, I'm so glad that I know this stuff. OK, alright, so the abstract data type we are gonna be interested in is the dictionary. The interface to a dictionary is the bottom, we are gonna insert, remove and find by a unique identifier called that we commonly refer to as a key. OK. So the abstract data type itself consists of this the data looks like, key, value pairs. And the interface, the functionality, of the ADT is insert, remove and find by the unique identifier. So I want to speculate for a second just cuz it's kind of fun to do so. If I have following data, if I have following data, how would it be, how would it seem reasonable to implement a dictionary. OK. So my data here is a locker number. This is my, ooops. This is my key, and the values that I'm going to put into the dictionary or attach to each identifier, I'm gonna refer to here as my data though it's commonly referred to its value. ","width":22784}]