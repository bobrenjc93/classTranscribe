[{"text":"This is kind of array. They are not different.One of them was treated as tree.","width":0},{"text":"One of them was treated as list.","width":3123},{"text":"So little bit different ","width":64},{"text":"The extra will make that even stronger","width":256},{"text":"They will be completely different.They have basically nothing to do with each other.","width":392},{"text":"Let's fill out the heap column of this table. First, dead .How long does it take me to push something on the heap?","width":786},{"text":"Those logarithmic.  Right? because they was added to the back. Then bubble up the heap. So that's logarithmic. ","width":1344},{"text":"Pop? remove something on the heap. ","width":64},{"text":"Again is logrithmic. Remove the back. Pop the back.Bubble the new root to its proper position.","width":448},{"text":"height, which we just proof was log n.","width":320},{"text":"What about peek?How fast is peek?","width":256},{"text":"Constant time just..root","width":320},{"text":"ignore.. just do the other one. So, what if we got a sorted...?","width":1088},{"text":"We shoudl","width":448},{"text":"what we should be doing here is ... welll","width":320},{"text":"The vector might filled out so we might do the resize.","width":384},{"text":"We did n pushes. One of those is..","width":320},{"text":"linear time. The other is log n.","width":320},{"text":"I should be doing .. now","width":64},{"text":"I just assuming we got room here","width":192},{"text":"It won't end up changing anything. When you actually advertise out","width":704},{"text":"Again, because there is only one linear operation","width":320},{"text":"insertions and everything else will be logarithmic. nlogn divided by n which is logn.","width":512},{"text":"sorted list. Let's say we got a sorted list.","width":448},{"text":"We were adding to the sorted list","width":320},{"text":"How long is that take","width":192},{"text":"i don't agree with O(1)","width":512},{"text":"It's sorted. We have to find the location for it.","width":128},{"text":"How long does it find the ..","width":192},{"text":"O(n)","width":64},{"text":"What about pop?","width":640},{"text":"That can be constant","width":192},{"text":"We know where the smallest thing is","width":192},{"text":"And we know we can pick the implementation and it is constant time","width":384},{"text":"What about peek?Still we don't know where it is","width":512},{"text":"So, that is fine","width":320},{"text":"Now Let's look at the last one which is build in","width":320},{"text":"place. in place meaning i am giving you already storage","width":448},{"text":"fill my priority queue","width":192},{"text":"So I am giving you a list of integers. For example","width":128},{"text":"How long is that take you?","width":512},{"text":"Nlogn","width":256},{"text":"that was mergesort from mplist","width":256},{"text":"sorted list by just swapping ","width":320},{"text":"node pointers stuff around","width":128},{"text":"And that didn't require your to allocate many spaces","width":320},{"text":"So you can do in place sort in nlogn time","width":512},{"text":"yes","width":256},{"text":"mergesor","width":192},{"text":"I give you a list","width":320},{"text":"doublely linklist","width":64},{"text":"and i say make a sorted list","width":64},{"text":"you wrote that function? it's mergesort","width":512},{"text":"or hw0","width":384},{"text":"So i can sort the list in nlogn time without making allocations","width":192},{"text":"we did in place","width":512},{"text":"what about unsorted list?","width":64},{"text":"if we want to do something for list","width":64},{"text":"how long is that take?","width":448},{"text":"constant. because i can just place wherever i want","width":64},{"text":"what about pop now","width":192},{"text":"now i don't know the smallest things is","width":192},{"text":"i don't know the largest things is. So it's gonna be linear time","width":256},{"text":"What about peel","width":576},{"text":"You gotta be clever be. If you are clever, it is constant time","width":192},{"text":"by maintaining either you have the smallest thing or the largest thing.","width":512},{"text":"or index of the smallest or the largest things","width":192},{"text":"if you do that","width":192},{"text":"note that the implementation for pop is still linear","width":256},{"text":"image for a second. I have got a list","width":256},{"text":"and i know the smallest thing is here","width":960},{"text":"i got a node start for my priority queue implementation","width":256},{"text":"tell me exactly where the smallest thing is and i want to do a pop","width":256},{"text":"why i have already got a pointer to it","width":192},{"text":"that should be constant time right?","width":320},{"text":"why is that linear","width":64},{"text":"shouldn't i delete that node in constant","width":448},{"text":"where is my smallest pointer point at","width":192},{"text":"i have to locate this smallest thing again.","width":128},{"text":"now it's linear for different reaons","width":192},{"text":"there is no way to avoid linear time if you pop got an unsorted list","width":384},{"text":"however, you can't get a constant time peek","width":256},{"text":"if you maintaining that pointer or index","width":256},{"text":"to the smallest thing","width":128},{"text":"every pop is gonna make sure that","width":448},{"text":"your push implementation is also gonna change","width":192},{"text":"if it is empty just set it to the smallest thing","width":256},{"text":"if it is not empty, compare it to the element you added","width":128},{"text":"if you added element is smaller. Update the pointe","width":256},{"text":"Otherwise, leave it alone","width":128},{"text":"That's just couple comparisons","width":192},{"text":"if you are clever, that can be constant time","width":256},{"text":"So I give you a integers list","width":320},{"text":"I ask you to build me an unsorted list. How long does that take you?","width":128}]