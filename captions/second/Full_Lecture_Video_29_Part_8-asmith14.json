[{"text":"marked the vertex as visited, we marked the edge as discovery","width":512},{"text":"we pushed that vertex onto whatever that is, otherwise if the edge was unexplored..","width":512},{"text":"this is the else if case, so i know that that vertex must have been visited so then i know it must be, back, instead of cross","width":768},{"text":"but other than that this looks like bfs right","width":256},{"text":"so what is this ordering structure that im using, is it a queue? its a stack thats all it is, thats the only difference, is that its a stack","width":576},{"text":"this is a stack of vertices, ","width":448},{"text":"meaning that i call .top if its a standard stack","width":256},{"text":"but thats it, i mean thats the only fundmental difference","width":448},{"text":"so the difference between a bfs and dfs is purely in the order that you're visiting the vertices in","width":576},{"text":"so if you use a queue, you get a breadth first search, where you've visiting everything that's sort of adjacent to a vertex before you go and see things that are further out","width":576},{"text":"so you see things in increasing order of distance from the root","width":128},{"text":"where as in a dfs you use a stack, so the most recent vertex that you've seen is the next one that you'll visit","width":768},{"text":"both of these are traversals, its just changing the order that  you visit the vertices in","width":512},{"text":"[question asked]","width":384},{"text":"[no audio]","width":448},{"text":"it gets a little fuzzy, when you talk about height, because its not, just having a spanning tree has not told you what the root is","width":1024},{"text":"its just a collect of vertices and edges, so maybe from the start point and then probably, i dont have a proof on me but that seems intuitive","width":576},{"text":"in general when we're talking about the spanning trees,w ere not really defining a root so theres nto really a notion of height","width":704},{"text":"but yes, in general the good observation is the tree that you're going to get from a dfs is going to be vastly different from the tree that you get from a bfs","width":384},{"text":"the way it's exploring is totally different","width":448},{"text":"[question being asked]","width":512},{"text":"these are not, you do not use these together, these are two different ways of writing dfs","width":640},{"text":"one way is to write it using an explicit std::stack and the other is this one, which doesn't use any stack at all, just the programming stack, you dont use those together, those are alternatives","width":512},{"text":"the top function is one way, the bottom is another way","width":256},{"text":"yes","width":128},{"text":"[[question]]","width":192},{"text":"so this is an interesting question, it sort of depends on what you're putting on the stack frames, and here i mean the stack frams are really small so it probably doesn't matter a whole lot, my gut tells me that probably the iterative verision is a little bit better because it doesnt keep around the vertex labels on the stack frame. because here whenever we're recusing were keeping that temp label before recusing","width":2112},{"text":"on the other one, the only state we need to represent a stack frame is just a vertex id and thats probably pretty cheap, we have to keep that no matter what, because thats the argument, and here every stack frame for this recursive call going to have the pointer to maintain the reference, the vertex id, the vertex label inside the forloop, so it's maybe slightly bigger, but probably not by much","width":1536},{"text":"[no audio]","width":512},{"text":"sure","width":192},{"text":"wouldn't change anything though","width":320},{"text":"[question]","width":256},{"text":"ok yea, so the vertex is, depending on the storage maybe it's better to pass it by reference, and then you have just the size of a vertex on there","width":640},{"text":"in the mp the vertex is just an int anyway","width":192},{"text":"but yeah, if you're vertex is maybe bigger, then maybe this does matter","width":256},{"text":"oh yeah","width":512},{"text":"[question being asked]","width":256},{"text":"[no audio]","width":768},{"text":"no, so the vertex, its going to depend on your implementation, if you're using an adjacency matrix, the vertex is just an int","width":576},{"text":"and that uniquely identifies the vertex in the graph as long as you're not modifying it. if you modify it, then all of your vertex id's change and you have to aware of that","width":704},{"text":"if you're not modifying it, a vertex in an adjacency matrix is just and int that tells you the row and the column, so that's simple enough","width":448},{"text":"for an adjacency list, the vertex was like this struct that had a pointer in it, so if you wanted to kick this off and start somewhere, you've halve to have some way of asking the graph to give you some vertex, or store a vertex","width":1152},{"text":"if you kept the result of add vertex or somethign around the first vertex you could start there. if you wanted to visit all the vertices you would probaly have to have some way of getting the vertices out of the graph","width":896},{"text":"once you have a vertex you have vertex, you have an easy way of getting exactly where that is, because the vertex itself is a pointer","width":576},{"text":"yeah the mp they're just numbers","width":384},{"text":"if they had a lot of data in them, if you're store the data associated with the vertex in the vertex, then yeah that would be bad, but in our case everythign is stored externally in hashtables from vertex id to whatever you wanted and then you just pass around numbers and its fine","width":1408},{"text":"and thats sort of by design to make passing the vertices easy and thinking about how do you get from a co-ordinate to a vertex easily","width":384},{"text":"so","width":576},{"text":"whats the running time of this then?","width":256},{"text":"is the next question","width":128},{"text":"so what is, and again were goign to think of the two cases of the halfway decent graph implementations that we talked about.","width":448},{"text":"which are the adjacentcy matrix and the adjacency list","width":320},{"text":"so if we're looking at this we can look at either the recursive version or the iterative version, because they're equivalent and their running times are going to be exactly the same","width":640}]