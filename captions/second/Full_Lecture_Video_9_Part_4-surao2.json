[{"text":"Not a member function. If you were a member function,yeah, but this is just a free-standing function so I don't have to scope it to anything. Alright? So then I'm inside this function so I'm going to make a triple. ","width":1536},{"text":"Okay ret from, okay, and then how am I going to pass arguments from my constructor?","width":704},{"text":"Am I just gonna say first middle last, or should I say something else?","width":576},{"text":"Pretend for a moment that T1, T2, and T3 are like, collages. So these are big objects they've got all kinds of dynamic memory flying aroung, right?","width":1088},{"text":"I've taken them in by value, which means that if I were passed in a collage l-value, I'm gonna make a deep copy, and if I was passed in a collage r-value, I'm gonna move construct. ","width":768},{"text":"Now I've got these 3 collages sitting on my stack frame that have the values that I want to be put in the triple.","width":768},{"text":"So how am I gonna pass these off to the triple constructor? Am I gonna pass them by value or am I gonna try and do something else with that? ","width":512},{"text":"I'm gonna move them. I've already got these 3 collages inside of my stack frame that have got everything I need in them. They're also temporary values that no one will ever refer to ever again.","width":768},{"text":"So I'm going to say to the triple constructor--hey! Take these, these are r-values, I'm gonna force these to be r-values, go ahead and steal from them because I'm not gonna use them anymore.","width":576},{"text":"If I pass them by value, I'm forcing it to make a copy of all 3 arguments. Which I have already done if I needed to. ","width":704},{"text":"So I'm going to move these all explicitly. So this is actually going to say move first, move middle, and move last.","width":1344},{"text":"Since I've passed these things in by value and I've got local temporary values sitting on my stackframe, that are perfectly good whatever T1, T2, and T3 are, and if they're big I would rather move them out of my temporary variables into the triple as opposed to forcing them to be a copy. So I'm going to be moving them here.","width":1984},{"text":"I don't want to copy if I don't have to. I could, yes. I could. I could pass these in by reference. If I pass them in by construct I'm forced to copy them again.","width":1216},{"text":"If I pass them in by r-value reference I can move from them. ","width":256},{"text":"But then what if the first one is an rvalue reference and the other two are const references. And what if the first and middle are r-value references but the last one is an l-value?","width":768},{"text":"What if the middle one is an l-value? Now I have 8 difference overloads that I've got to write for this function. I wanna overload specifically for the case where I've got an r-value for some of them and an l-value for the rest, or all r-values, or all l-values--that I have to write a function for all of those.","width":1024},{"text":"I'm gonna take by value here so that the compiler will do the appropriate thing for me when it constructs my temporary arguments.","width":512},{"text":"If the first argument is an l-value we make a deep copy. If the first argument is an rvalue it will use a move construct. When you're constructing a value passed into a function by value, the compiler looks for a constructor of that type taking whatever the argument was that you passed into the function.","width":1280},{"text":"So if I've passed in an lvalue into this function it looks for constructor for T1 taking an lvalue of another T1. ","width":448},{"text":"So it invokes the copy constructor. If however I pass in an rvalue, either by std::move or it's a temporary value or whatever, but if I pass in an rvalue as the first argument to the function, the compiler looks for a constructor for T1, constructing a T1 from a rvalue to another T1. So then it invokes a move constructor.  ","width":1216},{"text":"So this does what I want it to do. It's either gonna make a deep copy if it has to or its gonna move if it can.","width":384},{"text":"I do that by passing in these things by value. The assumption I'm making is that these things have got valid move constructors. Which is fine.","width":576},{"text":"Maybe not fine if you're dealing with legacy systems, but we're not dealing with a legacy system here.","width":384},{"text":"Regardless of, so now I can write one function that overloads for all of the 8 different cases for which things are rvalues and which things are lvalues. I don't have to care. I just have to trust that the compiler will find the appropriate constructor for me and invoke that. And then when I'm inside this function now I know that I have these temporary values that exist only when I'm inside my function. And now I'm free to move them wherever I please, because I am the only one who has access to the variable","width":1472},{"text":"Alright now what am I gonna do? I've made my triple I've moved my values into that triple, I've got it sitting in my stackframe, I've just got to return it. So, return ret.","width":1024},{"text":"I made my triple, I moved my values into it, I returned the triple.","width":832},{"text":"I'm returning it by value.","width":640},{"text":"So this is a good point. Why is it ok that this is a local variable and I'm returning it. We remembered that there was a case for which this was bad, that was when we were returning a reference to a local variable. That was bad because we had a reference that was referring to stack memory that was gone. We had a pointer to stack memory that was gone. So why is it ok here?","width":1472},{"text":"Here I'm returning by value, so I'm returning the value out of this function it's gotta be constructed into the stack frame of the caller. That's what returning by value means. If I return by reference, it's going to construct a reference into the stack frame of the caller. Here I'm returning by value it's gonna construct a triple ABC into the stackframe of whoever called this function.","width":1472},{"text":"In this case, since this is just a temporary return value of a function, it's gonna be move constructed into the stack frame for the caller,because it's just a value that was sitting in the stackframe that's going away, its a temporary value. This is where we were set when we called functions we asked whats the return value--is it an rvalue or an lvalue? That's where this is happening. I'm returning a value out of a function","width":1600},{"text":"which means that that value needs to make it into the stack frame of whoever called this function.","width":512},{"text":"That value has to be constructed into the stack frame of the caller. So I've constructed triple here inside of the stackframe for make triple. Then when I return back to whoever called this,like main, it's going to give me a triple object to construct from.","width":960},{"text":"I'm going to move construct from the triple I'm returning here. This is OK. Because I'm returning by value. That's the key difference. If I was returning by reference this would be bad. But I'm not returning by reference I'm returning by value so this is fine.","width":1216}]