[{"text":"Now, we get \"mono\", don't wish that upon anybody, okay?","width":704.3999999761581},{"text":"So, the point of this is that it goes base classes, data members, yourself, in the terms of ordering of for these.","width":598.3999999761581},{"text":"What about destruction? ","width":192.39999997615814},{"text":"What order are the destructors run?","width":512.3999999761581},{"text":"Which one goes first? Let me put it this way? which destructor is going to be invoked by the system here? when main() returns? the one from monolith. Cause monolith is the thing that's expiring.","width":896.3999999761581},{"text":"It turns out, that the monolith's constructor is actually going to run first too? why? because you don't want your data members destroyed before you have a chance to access their internals inside of your destructor.","width":832.3999999761581},{"text":"Imagine that a basilisk had dynamic memory and you wanted to call some functions on it, as you are destroying it. ","width":448.39999997615814},{"text":"If it's destructor ran before the monolith's destructor, then you couldn't do that, because who knows the state of your data member is, if it's destructor has already run?","width":512.3999999761581},{"text":"So in general the ordering for the destructors is going to be the exact opposite of the order that they ran in. ","width":384.39999997615814},{"text":"So, it sort of looks like, a data structure we haven't talked about yet, so I won't make that analogy. ","width":512.3999999761581},{"text":"So the first thing that's actually going to run is the monolith's destructor, so we going to get: \"combo\".","width":576.3999999761581},{"text":"After that, which one goes? Basilisk's destructor or obelisk's destructor? Basilisk! cause the order that I constructed these in was: obelisk, basilisk, monolith. So it's going to go the exact opposite order, which will be: monolith, basilisk, obelisk. ","width":1408.3999999761581},{"text":"Okay? So, now we are going to invoke basilisk destructor, which we are going to get \"snake\", and then finally we invoke the obelisk destructor and get \"pillar\", okay?","width":1152.3999999761581},{"text":"Yes?.....can you go over the memory diagram? Draw a memory diagram for this? Sure... So, when you make a monolith,... This is a monolith, it has space up here for an obelisk, whatever is contained inside the obelisk goes at the top of the structure for this class. And then we have our data members, which happens to be a basilisk.","width":2368.399999976158},{"text":"With template parameter int called b.","width":512.3999999761581},{"text":"Okay, so the top of the structure is whatever your base class is, which it may have more base classes too, so whatever is contained inside of that class is sort of recursive.","width":640.3999999761581},{"text":"right? And then after that is where your data members are going.","width":384.39999997615814},{"text":"This is sort of initialised top to bottom. So, you initialise the obelisk part first. Then you initialise your data elements then you run the constructor for the whole monolith itself. And then the destructors run in the reverse order.","width":1024.3999999761581},{"text":"Good. Yes? Question?","width":847.3999999761581},{"text":"If there's a basilisk inside of obelisk? okay... So, inside of the obelisk, then we'd have a basilisk b for itself, or whatever you want to call it.","width":1408.3999999761581},{"text":"Then what would the order of the destructor should that be?","width":192.39999997615814},{"text":"First we are going to invoke monolith destructor. ","width":210.39999997615814},{"text":"And then we need to destroy the data members. ","width":192.39999997615814},{"text":"Sorry? the constructors? okay sure...","width":256.39999997615814},{"text":"What happens first then? If a monolith is an obelisk, when you construct a new monolith, what has to happen first?","width":588.3999999761581},{"text":"You'd have to construct the obelisk class. To construct the obelisk class, what happens first, the obelisk or the basilisk? Basilisk! you have to initialise your data elements first inside of the obelisk.","width":712.3999999761581},{"text":"So, if you have this setup, you'd get: \"hisss\", and then you would get the obelisk's constructor, \"stone\", and then we are going to initialise the data elements of the monolith, so we get another basilisk constructor, \"hisss\".","width":1344.3999999761581},{"text":"Then the monolith: \" mono\". ","width":220.39999997615814},{"text":"Now we've the whole... now we've initialised the whole structure and so the reverse order is going to happen on the destruction. So, the first thing we are going to get again is: \"combo\". And then when you destroy the basilisk members, we get \"snake\".","width":1024.3999999761581},{"text":"And then we are going to destroy the obelisk, which is  \"pillar\",.","width":1180.3999999761581},{"text":"Which then itself has a data member so then that's destructor is invoked: \"snake\".","width":512.3999999761581},{"text":"And then we've finally gotten rid of everything.","width":256.39999997615814},{"text":"So, basically this process of base initialise the base classes, initialise your data members, initialise yourself is true recursively. So, if you're inheriting from something that also has data members or also has a base class, that's base class goes first, then it's data members, then it's constructor, and then it falls back to your data elements.","width":1536.3999999761581},{"text":"Let's move on...","width":384.39999997615814},{"text":"I have a mystery structure here, so we are going start talking about our first real data structure, today. But first I have sort of this, nifty little struct here. First of all, what is a struct in C++, we have seen that before, so what does that mean?","width":1244.3999999761581},{"text":"The way to think about structs in C++ is not the way you think about structs in C , cause they are not the same. A struct in C++ is just a class that by default has all of it's members public.","width":768.3999999761581},{"text":"Okay, this the same thing as saying class node public: and then all the stuff inside of a node and then curly semicolon.","width":456.39999997615814},{"text":"This is just a class that has default access set to public, okay?","width":360.39999997615814},{"text":"By contrast if you said class here, all of the elements by default in a class are private.","width":332.39999997615814},{"text":"Unless we explicitly specify with the access qualifiers.","width":246.39999997615814},{"text":"So, this is just a class a with public elements.","width":192.39999997615814},{"text":"Okay? But it still can have methods, constructors, destructors, that kinda thing.  Which is unlike structs in C.","width":448.39999997615814}]