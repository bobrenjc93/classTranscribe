[{"text":"Okay? Good. So that's how i declare the copy constructor. Right. So if I've got a copy constructor, that pretty much means most of the time at least for the classes we're dealing with that I've got dynamic memory around.","width":899.6666666269302},{"text":"If I've got dynamic memory flying around, that means I'm going to have new operators happening in constructors. So what do I then need? I need a destructor. Why do I need a destructor? That's where the deletes go. That's where I free all the memory that I've allocated in my constructors. This is RAII. This is resource acquisition is initialization.","width":1296.6666666269302},{"text":"So when i create an object, it allocates memory using new, and so then when that object goes away, its destructor should make sure it's doing the thing to get rid of the memory that it's made.","width":608.6666666269302},{"text":"This is a way of making sure I'm not going to leak any memory if I've got all my classes nicely composed like this so when they're made they allocate. When they're destroyed, they deallocate. Then I'm not going to leak any memory. When I make a PNG object, it allocates memory for that image. When it goes away, it frees all the memory for that image, and I don't have to worry about having heap memory. Do I need to call a clear function on the PNG before I return? It just happens automatically.","width":1562.6666666269302},{"text":"And this happens in two cases. One is when you have a variable on the stack frame that's going out of scope. That will invoke the destructor as the stack frame is being released. Another is when you call delete on a pointer to an object in the heap because you're saying get rid of that memory. Deallocate that memory over there in the heap which that object in the heap might itself have heap memory so then it needs to run some clean up routine to make sure it cleans up its stuff.","width":1642.6666666269302},{"text":"The destructor is changing what it means to destroy the object. You do get a default destructor provided by the system which just does nothing because default objects don't have anything in them so you don't have to worry about anything.","width":807.6666666269302},{"text":"When we are defining a destructor we're changing what the behavior is when of destroying objects of our type. So we're going to change what it means to destroy a book. What's the signature? Tilda! Why? Because reasons. I don't know. Bjarna said so.","width":1215.6666666269302},{"text":"Tilda book. That's just the name. It's alway tilda name of class. It always takes no arguments. It can't be const because it's deleting stuff. Always this signature.","width":1268.6666666269302},{"text":"Quickly, before we go, let's right an implementation of the destructor for this class. Remember, I've got this thing set up. String star star lines is going to be an array of arrays of strings. Now when i have the string itself, I don't have to worry about it because the string is a class and the class has a well-defined constructor and well-defined destructor. I don't have to worry about the string itself. I just need to worry about the arrays. Those are the things that I made. The string objects are going to take care of themselves.","width":2137.6666666269302},{"text":"So when I'm deleting my arrays, the string objects' destructors will be invoked so I don't have to worry about how the strings are working.","width":360.66666662693024},{"text":"I do need to worry about my own stuff. I've allocated a two dimensional array here. My book destructor is just going to invoke my helper function for clear. It just empties all the values in this book. That means I'm going to have to declare that helper function up here somewhere, so I'll put it in the private section.","width":1663.6666666269302},{"text":"Maybe if you wanted other people to be able to call this you'd put it in the public section, but I don't care for other people to be able to clear books so I'm just going to (leave it in the private section).","width":423.66666662693024},{"text":"That means only I as the implementer of this class can call this function. So what should the implementation of the clear function be? How do I free a two dimensional array? I've got to have a for loop. Size gives us the number of chapters. Remember the first thing is the chapter. The second thing is the lines. I'm going to go over the chapters. So now I'm going over each chapter. ","width":3135.6666666269302},{"text":"What am I going to do inside this loop? My dynamic memory picture is going to look like this. So what am I going to do?","width":1380.6666666269302},{"text":"Delete brackets. I'm going over this array, so I'm going to call delete brackets on this thing which will get rid of this array. And then I'm going to call delete brackets on this thing which will get rid of this array. So that's wat this for loop is doing. It's getting rid of all my arrays. I don't have to worry about the string. When I'm going delete brackets on an array of strings, the destructor will be invoked for each single string in that array. So I don't have to worry about that part. I just have to worry about getting rid of my stuff. The things that I said new on. I said new for an array at every slot in this position and I said new for that array itself. So I need to worry about those two things. My for loop is done, so now what? Delete brackets lines.","width":3651.6666666269302},{"text":"That will follow the lines pointer and delete this array. So now all this stuff has been freed. Next time we will start off with talking about how we write a proper copy constructor and then we'll start talking about assignment operators.","width":1919.6666666269302}]