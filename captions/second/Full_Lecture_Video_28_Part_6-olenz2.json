[{"text":"What about for an adjacency matrix?","width":320},{"text":"O(1) and why?","width":256},{"text":"Set two bits to 0","width":256},{"text":"Not decrement the bit, set it to 0","width":256},{"text":"So, how long does it take me to remove an edge in an adjacency list representation?","width":512},{"text":"the minimum of the degrees, so this would be big O of min degree of U, degree of V","width":704},{"text":"Why is that, that's sort of a weird running time right? why is it the minimum of the degree of those two vertices, yeah?","width":640},{"text":"Right, right, so I'm just looking for one of those two, I know I have two nodes to represent that edge, I just want to find one of them, so I can pick the shorter of the two lists to go down, until I find one of the nodes that represents that edge and then once I'm there I have an immediate jump to where the other node was.","width":1280},{"text":"So I can just pick which of the two vertices has the fewest number of adjacents and go down that list instead, so this would be the minimum of the degree of those two vertices","width":768},{"text":"So how long does it take me to get all of the adjacent vertices of a vertex V in an edge list representation?","width":640},{"text":"O(m), because I have to sort of scan the edge list and look for anything that has one of the endpoints as being V and add that to something and return that to me","width":768},{"text":"What about an adjacency matrix?","width":192},{"text":"O(N)","width":320},{"text":"Why is it N instead of M?","width":256},{"text":"Right, I'm scanning either a row or a column in my matrix, and I know that this matrix has side length N, so I'm only going down an array of length N","width":1070},{"text":"And if it's set to 1 I put the other endpoint into a list or set or something and continue doing something and return that set to you so it takes me O(N) time to do that","width":768},{"text":"alright what about an adjacency list? how long does it take me to build you a set of all the adjacent vertices of a particular vertex?","width":576},{"text":"Yeah O of degree of V","width":256},{"text":"Because I'm sort of storing for that vertex only the things that are already adjacent to it, so if it's adjacent to nothing I can just immediately return, if it's adjacent to one thing I only put one thing in the container I'm giving you and return that","width":832},{"text":"So it take time proportional to the number of adjacent vertices to that node","width":256},{"text":"Finally, how long does it take me to detect whether an edge between U and V exists in an edge list, O(m) I have to scan again","width":896},{"text":"How about for the matrix? constant, look and see if the bit is set, what about the adjacency list? yeah sort of the same story as above where it was min of degree of U , degree of V","width":1216},{"text":"I can just pick which list is smaller and go down that and see if one of those two nodes exists in that adjacency list and if it does I know that edge exists. Yes?","width":768},{"text":"Adding an edge for an adjacency list, sure","width":576},{"text":"okay, so we're gonna do an add edge and we're adding this edge here. Between U and Z. So, my input to this add edge function when the user is giving me U and giving me Z is going to be effectively something that contains an iterator to those two nodes in the vertex list, so this is my starting point, I've got a pointer there I've got a pointer there, how in the world am I going to do this?","width":1728},{"text":"So I know that U, I'm adding the vertex Z to the adjacency list for U, because U is now going to be adjacent to Z after I add this edge.","width":896},{"text":"So what I'm going to do is create a new node","width":320},{"text":"Holding Z","width":640},{"text":"and I'm going to add it to this list","width":448},{"text":"So now my list at U has got this new node that has Z in it just at the front, I could put it at the back it doesn't matter, I just put it at the front because reasons","width":832},{"text":"So, I'm gonna do a similar thing at Z, I'm gonna make my new node.","width":384},{"text":"I'm gonna put U in it","width":384},{"text":"Going to, I guess this should also be... so.. I'm going to set it up to point here, I'm going to set this up to point back, and I'm going to set this up to point there, and then the last thing I have to do is set up those two other pointers, so this has to point down to here and this has to point up to here.","width":1600},{"text":"Just a bunch of pointer assignments","width":576},{"text":"that make sense?","width":192},{"text":"Alright, so I want to go on to talking about graph algorithms now, so we're just going to at this point assume that we're being given a representation.. sorry, yes?","width":1344},{"text":"[Long student question]","width":512},{"text":"You're going to have to check sort of every m of the cells to see if there's something there or not, regardless of what collision strategy you're using, and you're also necessarily going to find all N elements in the hash table so it would be O(N + m)","width":1472},{"text":"That's what the graph class is doing in the MP, and it's worthwhile thinking about what the running times would be if you did that, I will not do that here.","width":832},{"text":"Okay, so I want to start talking about graph algorithms now, so we're going to assume we're being given a graph, an existing implementation of a graph, that has sort of those ADT functions that we can use on it, and we're going to do thing with these graphs.","width":768},{"text":"So the very first thing we're gonna do is try and traverse a graph, and so I've got two pictures of graph there that we might wanna traverse, and the things that were true of tree traversal are sort of also going to be true of graph traversal, graph traversal is just gonna be a little bit more general.","width":1216},{"text":"So, when we're doing a traversal of the tree, we followed the connectivity of the tree.","width":576}]