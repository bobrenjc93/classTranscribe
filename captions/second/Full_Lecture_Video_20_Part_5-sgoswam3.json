[{"text":"Just like in the normal the other two cases of this remove function the no child and one child I wanted a reference to the pointer so that I could change it so here when I want to remove the iop after I am done I still want to have a reference to it","width":1232},{"text":"So let's write these","width":256},{"text":"So first. We are gonna write remove node which is going to delegate to one of these three helper functions that handle those 3 cases of removal right.","width":917},{"text":"There is either the really easy case where there are no children, there is the slightly more hard but not that bad case where there is one child and then there is a difficult case where there is 2 children.","width":768},{"text":"I'm gonna write this function","width":214},{"text":"Keep in mind that you are using the helper functions so you don't have to do any of the hard stuff. You just have to diagnose, basically what this functions is doing is diagnose which condition it is. ","width":518},{"text":"Is it a no child remove or one child remove or two child remove.","width":1208},{"text":"Remember this remove node function is what I am calling when I find the node that I want to remove. So now I know for example removing the 9. Now I gotta figure out how I am gonna do that, which one of the removal cases is this? That is the goal of this function.","width":1222},{"text":"If there is not a left or/and not a right child that's the same thing as saying there are no children so this is the no child remove.","width":1697},{"text":"so if there is a left child and a right child then I know this must be a two child remove.","width":819},{"text":"Then there is only one case if both of those are false there must be a one non-null pointer, it's either the left or the right, I don't know which one it is and that's fine.","width":768},{"text":"I'll just call one-child remove and let that function handle it. Excellent thank you.","width":459},{"text":"Any questions on this?","width":128},{"text":"This is perfect, this is exactly what I am looking for. The goal of this remove node function is to figure out which of the 3 cases it is.","width":512},{"text":"So if you don't have a left child and you don't have a right child you know that the node that you are removing is a leaf in which case is a no child remove.","width":554},{"text":"That's the first statement.","width":151},{"text":"The second if statement is is if I have a left child and a right child.","width":391},{"text":"Then I know that I have two children so it is a 2 child remove on the subroot and then the only other case there could be is if it is not having no children and not having both children, it must have one child","width":984},{"text":"There is only 3 cases.","width":256},{"text":"Yeah.","width":555},{"text":"They'll have to.","width":55},{"text":"","width":602},{"text":"Let's write those helper functions now. So now we have got we know okay our remove we we have broken down remove into a lot of pieces, which is something I recommend you do if you're encountering a hard problem, just break it down into small steps. So the first step of our remove is find the node that I want to remove, the second step is if it exists. Is actually do the removal of that node, which itself has 3 different cases , so the first step of doing the removal is figure out if it is a no child, a two child or a one child remove.","width":2199},{"text":"So now we can write each one of those functions in isolation. sooo we are gonna start with the easy one.","width":668},{"text":"Which is no child remove.","width":287},{"text":"Simple one liner does anybody know what this one liner is?","width":426},{"text":"subroot=null pointer.","width":758},{"text":"what just happened?","width":320},{"text":"So subroot is a unique pointer...so what what function did this operation call?","width":624},{"text":"It invoked the assignment operator for the unique pointer.","width":242},{"text":"Left hand side was a unique pointer, right hand side is a null pointer T. So it invoked the assignment operator for the unique pointer taking something","width":500},{"text":" ","width":226},{"text":"First thing that happens when you are doing an assignment to a unique pointer.","width":294},{"text":"Â it has the argument now. So it has to clear whatever it is pointing at right now and take ownership of it's argument okay. So this unique pointer ","width":615},{"text":"And this is addressing what was pointed out earlier when we wanted to remove the 9.","width":719},{"text":"12 if we are removing the 9.","width":147},{"text":"We want that pointer to be null and we also want to make sure that we didn't leak the 9. right","width":376},{"text":"Why is it that when I assign null pointer into the left pointer of 12 that we don't leak memory?","width":426},{"text":"Why is that fine?","width":55},{"text":"","width":236},{"text":"Cause it's a unique pointer and the reason why it's fine because it's a unique pointer because in the assignment statement.","width":448},{"text":"The assignment operator for a unique pointer or for a scoped pointer the very first thing you did was check-","width":337},{"text":"Do I own memory right now?","width":192},{"text":"If I do delete that memory and then take ownership of the thing that I have been asked to be responsible for.","width":508},{"text":"So the very first thing which happens when I say subroot equals null pointer is it calls delete on the pointer the raw pointer inside of the unique pointer to the 9. And then the 9 is released.","width":679},{"text":"And then it assigns the internal pointer of that to be a null pointer.","width":291},{"text":"","width":176},{"text":"Makes sense?","width":84},{"text":"It's the same story if I had said unique pointer int braces new int 5","width":340},{"text":"","width":146},{"text":"Right and then you know said ptr = null pointer, the same thing happens there. It releases the memory associated with whatever is in the pointer right now and then takes ownership of what you have given it","width":739},{"text":"So that one line does 2 things. It releases the node and it sets the pointer to null.","width":460},{"text":"","width":806},{"text":"Yeah The assignment into a unique pointer will always first release whatever it is pointing at and then take ownership of the argument.","width":576},{"text":"SO if I have an existing unique pointer pointing at something else and let's call it pointer A.","width":384},{"text":"Then I've have got another unique pointer B, that's pointing at something else maybe null pointer maybe not.","width":287},{"text":"If I say A=std::move(B) the very first thing that happens is A releases whatever it was owning.","width":320},{"text":"And then it steals whatever was in B which could be null pointer, could be some other pointer whatever it is.","width":384}]