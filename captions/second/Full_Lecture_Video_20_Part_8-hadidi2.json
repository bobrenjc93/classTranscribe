[{"text":"Now we've got a helper function that I can call on a subroot at any point in this tree, and it'll give me the rightmost node in that subtree.","width":832},{"text":"So then what is the implementation of the in order predecessor function look like? I don't know why I gave you two lines, it only needs one.","width":384},{"text":"Return rightmost of subroot left.","width":1024},{"text":"So I ask the left subtree of subroot for it's rightmost element. The rightmost element to the left subtree. ","width":1088},{"text":"Questions on how this is working?","width":192},{"text":"(question is asked)","width":128},{"text":"If I didn't have a left subtree, we might be in trouble here. So I could handle that case explicitly. It turns out if this is a private helper function and I'm only calling it for the purposes of two child remove, I know that I always have a left subtree.","width":1216},{"text":"If I wanted this to work for any node in the tree, any arbitrary node, and it wasn't just a helper function inside of some other function, then I would have to care about that case. And then the IOP of something that doesn't have a left subtree should just be the root itself. So I could say if not subroot left, if there is no left subtree, then I am my own predecessor. There's nothing I could do in that case. So maybe I do that.","width":2432},{"text":"It turns out for us, this case doesn't matter at all because we will only ask for the IOP of nodes that have two children. So there will always be a left subtree.","width":640},{"text":"(question is asked)","width":1216},{"text":"So this is just handling the case where I don't have a left subtree. ","width":576},{"text":"Subroot is the parameter.","width":128},{"text":"(inaudible)","width":1152},{"text":"You guys are like wizards, do that more often!","width":448},{"text":"(question is asked)","width":576},{"text":"So this is just a trailing return type. So we've done this before, I think I did it with the iterators because saying the actual type, if I said it in front, gets really nasty. If I say it like this, at the end of the function, with auto in the front and arrow the return type, when I'm saying the return type, it's as though I'm already scoped to the class. So then I can just say node instead of BST k, v, node.","width":2112},{"text":"And furthermore, if I put it in the front, I'd have to say something nasty like \"std::unique_ptr<typename BST k, v:: node> &. which is way longer than just putting it at the tail.","width":1280},{"text":"You could do it either way. This is just simpler .","width":320},{"text":"yeah, you can always do this. You can do this for any function if you wanted to. It's just normally, I only do it when it really saves me something. Like when I've got some type that's really hard to say and it's easier to say if I'm already scoped to the class.","width":1056},{"text":"Yeah, this can be used on any kind of function.","width":229},{"text":"This is a C++ 11 feature.","width":192},{"text":"(question is asked)","width":192},{"text":"You could say auto BST something arrow void if you wanted to. But then you said auto and void, so might as well just say void.","width":576},{"text":"So normally I only do this in the case where saying that type is very orneriss if I put it in the front.","width":640},{"text":"Let's write the two child remove now. ","width":832},{"text":"So now we're dealing with the case that the node we've been asked to remove in the BST has two children. If I scroll back up to our picture, ","width":960},{"text":"all the way up here, that was like the case where we're asked to remove the 50.","width":512},{"text":"The 50 has got a child to its left and right. So we're going to call two child remove on the 50.","width":768},{"text":"When I say that, what do I actually mean?","width":320},{"text":"What is the parameter to two child remove in this case where I'm asking you to remove the 50?","width":448},{"text":"The root pointer inside of the tree.","width":192},{"text":"I'm always calling this function on the pointer to the node, so the pointer to the node here at the top of the tree must be the root inside of the tree class.","width":640},{"text":"There's some unique pointer here then I'm calling it on a reference to that.","width":512},{"text":"In this case, I've got two children, so I have to be careful.","width":256},{"text":"The first thing I'm going to do is locate the in order","width":128},{"text":"predecessor.","width":101},{"text":"And since I know that after I'm done here, I want to remove that node, I'm going to have a reference to it.","width":512},{"text":"So I'm creating a reference variable here, IOP.","width":274},{"text":"Which is going to be a unique pointer node reference. I said auto, but it's going to be a unique pointer node reference. ","width":384},{"text":"The reference is important here because I want to change the actual pointer to the IOP when I'm done.","width":384},{"text":"So how do I get the IOP of subroot?","width":640},{"text":"In order predecessor subroot. We have a function now that, given any node in the tree that has two children, can give me the IOP. So I know I have a node that has two children, so I'm going to call in order predecessor subroot.","width":1472},{"text":"That gives me my IOP. Now that I know where the IOP is, what do I do to swap with it?","width":768}]