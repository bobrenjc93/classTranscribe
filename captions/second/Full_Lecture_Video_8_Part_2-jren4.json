[{"text":"ok there's another way to initialize them","width":393},{"text":"which is to actually set an equal to this magic macro pthread_mutex_initializer","width":784},{"text":"ok, so, if I do that then I've got an initialized mutex and now I've got this object not in a c++ cense, but in terms of something conceptually I can think of as an object","width":904},{"text":"that I can lock","width":56},{"text":"and remember, the lock means that no other thread can lock the mutex","width":399},{"text":"so I'm using it as a way to serialize who gets access to my sum variable","width":507},{"text":"if your thread comes a long and tries to lock this mutex one then it has to wait until I've finished with that mutex","width":414},{"text":"and similariliy if you've locked mutex then I have to wait","width":353},{"text":"yes?","width":334},{"text":"then we go back to the original problem we have arbitrary values","width":521},{"text":"ok, so yeah, we could do that, we could have another little loop down here for example","width":1139},{"text":"yes","width":64},{"text":"and we're back to our same problem that the CPUs are now stepping over each other in trying to read and write to this memory location","width":566},{"text":"pthread_mutex doesn't give you any magic, it's a very low level way just to stop two or more threads form continuing","width":560},{"text":"it's up to us to do some code analysis and say 'yeah, actually I've got a problem with this code'","width":331},{"text":"I forgot to put a pthread lock around that other loop","width":242},{"text":"[student question]","width":593},{"text":"correct, yes, you can just think of it as a very simple little busy loop","width":258},{"text":"the lock thing says 'hey whilst it's mutex is locked by someone else I'm going to wait'","width":385},{"text":"that's all it does","width":87},{"text":"it doesn't magically say and the code in here is amazing and bug free","width":289},{"text":"it doesn't say that other pieces of memory are especially locked, it's just a loop","width":524},{"text":"it just happens to be a clever loop to be sure that there can only be one ","width":276},{"text":"if two threads called mutex lock at the same time","width":242},{"text":"only one of them wins","width":117},{"text":"only one of them gets to go to into the bathroom","width":218},{"text":"the other one has to wait","width":55},{"text":"a bit","width":316},{"text":"but eventaully that first thread will presumably unlock the mutex at which point the waiting thread can say 'oh great, it's my turn to lock it' and continue","width":692},{"text":"so it's a busy loop, it tries to be efficient in the case that the lock is unlocked","width":473},{"text":"because most of the time there isn't a conflict","width":134},{"text":"most of the time it's pretty unlikley that two threads are reading the same data structure","width":343},{"text":"it's just that one percent of the time or .1 percent of the time we're lucky and our CPU, or two or more CPUs are trying to read the same memory when we don't want them to","width":708},{"text":"yes? [student question]","width":309},{"text":"yes, in this tiny example we would actually get a better performance if we did that","width":596},{"text":"if we just locked the whole thing for the entire time","width":281},{"text":"in other words for this silly little tiny example","width":301},{"text":"there's absolutely no point running two threads","width":162},{"text":"yes","width":62},{"text":"trying to have two threads accessing the same memory we might as well of just had a single thread that weant up to two million","width":601},{"text":"ok, so the parallelism in this case or the speed of it just isn't worth it","width":396},{"text":"the reason I've chosen this example is because it's trivial to show a problem with two threads incrementing the same piece of memory","width":811},{"text":"it would not be a problem if sum was the local variable because local variables are stored in the stack","width":395},{"text":"and the stack is per thread","width":137},{"text":"and so presumably they'd be updateding their own variables","width":612},{"text":"what happens if you forget to unlock?","width":117},{"text":"ok, imagine this, imagine the person in front of you goes into the bathroom and never comes out","width":788},{"text":"what we've discovered ladies and gentlemen","width":132},{"text":"is something called dreadlocks - nah - no, actually deadlock","width":302},{"text":"nothing to do with dreadlocks or bad hair","width":150},{"text":"or goodhair if you like dreadlocks","width":116},{"text":"so we've got a problem of deadlock","width":137},{"text":"we've got one thread waiting for another thread to unlock a mutex and it never happens","width":377},{"text":"right, our poor thread is stuck","width":560},{"text":"alright, so let's do that to our poor little program","width":619},{"text":"and you can tell me how quickly my program will finish","width":746},{"text":"three years later we're still waiting","width":356},{"text":"what happened? well I had one thread that locked the mutex and a second thread that said 'ok, i'm going to wait because i need to lock this mutex' ","width":677},{"text":"so it never proceeds, it never gets into the for loop","width":187},{"text":"meanwhile our main thread is waiting for both threads to finish","width":313},{"text":"when does that happen? never","width":318},{"text":"so if you think C code and programs have been hard to debug so far","width":390},{"text":"you ain't seen nothing yet. baby no because","width":230},{"text":"our program stalls, it gets stuck if we were to debug this we'd discover that the main thread is here, it's waiting","width":519},{"text":"it's waiting for soemthing that never happens","width":130},{"text":"we have to say while why is it waiting? what happened to that other thread?","width":185},{"text":"so like sherlock holmes you have to say look this thread ever unlocked a mutex","width":623},{"text":"yes?","width":1139},{"text":"are you taking about the mutex or the sum variable?","width":253},{"text":"so in the - we had the code before","width":398},{"text":"ok, so the code, the code as written right now allows one thread to work through the whole for loop","width":447},{"text":"and the other thread is just spinning there waiting for the mutex to be unlocked before it can lock it","width":317},{"text":"so it doesn't do anything","width":458},{"text":"now you've got the case where each thread before they can increment the sum had to lock the mutex","width":382},{"text":"has to own that mutex","width":108}]