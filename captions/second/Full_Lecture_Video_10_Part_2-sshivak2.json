[{"text":"It's not virtual thank you. right? ","width":640.3999999761581},{"text":"When you don't have a virtual function and you just call a function on an object, it's looked up statically.","width":320.39999997615814},{"text":"There's no extra steps involved, it's just what is the type of the thing that I'm calling this function on .","width":481.39999997615814},{"text":"Look there, look for the function in the header file for that particular object, and then invoke that function, if it exists. If it doesn't, it's a compiler error.","width":512.3999999761581},{"text":"So, resolving what function to invoked was done at compile time.","width":290.39999997615814},{"text":"The compiler looked at what's the type and figured that out, at compile time.","width":340.39999997615814},{"text":"There's no over headed runtime. After it compiles the code, it knows exactly which function is being invoked, that's why it's called static.","width":468.39999997615814},{"text":"Things that done at compile time are often called static.","width":256.39999997615814},{"text":"Static polymorphism, is polymorphism that happens at compile time. And we achieve that with templates. ","width":407.39999997615814},{"text":"So, static typically means: at compile time. And so static binding or static method look-up is when you call just a method- a normal method- on an object; there's no virtual involved.","width":704.3999999761581},{"text":"So, what about, dynamic binding? Well, dynamic binding, then by converse would be when there's a virtual. ","width":576.3999999761581},{"text":"What is a good example of dynamic binding? So, suppose that I have a class hierarchy A and B, and B is an A and they both have a virtual void foo(). How could I get dynamic lookup? ","width":1024.3999999761581},{"text":"For foo()? I have class A{ public: virtual void foo(); };  class B: public A{ public: void foo() override;}; ","width":2560.399999976158},{"text":"Given this set up, how could I cause dynamic binding to happen for foo? What kind of set up would I need?","width":896.3999999761581},{"text":"A obj = B{}; and then call foo on B. Wait, on obj? yeah... on obj; obj.foo(); ","width":1600.3999999761581},{"text":"Which method does that call?","width":256.39999997615814},{"text":"A. This is slicing, right? Remember slicing?","width":512.3999999761581},{"text":"There's not enough space in A for all of B, because B has A and more. So when we assign into A, we call A's function.","width":576.3999999761581},{"text":"Sorry. After we assign into A, we can only take the A part of this new B that we have created. And so after this point, obj is an A and it does static look up.","width":704.3999999761581},{"text":"This is close to right. How can make it right? ","width":256.39999997615814},{"text":"Pointers! I have to go through a pointer.","width":178.39999997615814},{"text":"So, I could say A* obj  = new B{}; and say obj->foo();","width":576.3999999761581},{"text":"Now, we have dynamic lookup. So, now it's going to say: I have an A* to some B, I'm calling foo() through a pointer to A. So, it's going to go look up in class A, look for function called foo(), finds one. But sees that it's virtual.","width":1344.3999999761581},{"text":"When it sees that it is virtual, because we are calling this through a pointer or a reference technically. Going through a pointer here, and it found that the function is virtual. This means that it has to do dynamic look up. So, it has to say: what is actually the runtime type of the thing at the end of the end of the obj pointer.","width":1258.3999999761581},{"text":"Well it turns out it's a B. So, then you go into class B and you look for a function called foo() returning void. find one and you invoked that one. So, this code will invoke B's foo(), instead of A's.","width":832.3999999761581},{"text":"The dynamic part came from looking in a base class's header file, seeing that it was virtual, and then going and looking at the derived class header file for that particular object: that's the dynamic part. Why can't that be done at runtime, or sorry, why can't that be done at compile time? Why is that not static?","width":1408.3999999761581},{"text":"Right. We may or may not know what the actual runtime type of this obj pointer is. It could be B, but somebody could extend from A and make a D and it could be a D. We have no idea.","width":1472.3999999761581},{"text":"Somebody could change what this pointer points to and have it point to some other derived class instance and we don't know what that is and that could be determined by runtime constraints.","width":656.3999999761581},{"text":"If the counter is above a 100, start making D's instead of B's. Or, if the command line arguments said this instead of that, make a B instead of a D or make a D instead of B.","width":576.3999999761581},{"text":"So, we may or may not know what the actual type at the end of this pointer is until runtime. So, the compiler can't make this static, it has to look it up at runtime; which is a little bit slower. So, there's some overhead here, it's not completely negligible, but it has to happen at runtime not at compile time.","width":1280.3999999761581},{"text":"What about this: if I do B obj2; obj2.foo(); that static or dynamic lookup? Static!","width":1024.3999999761581},{"text":"The easiest way to tell there's not a pointer, I don't have a pointer to base pointing at the derived. ","width":384.39999997615814},{"text":"It can't do dynamic dispatch. In order to do dynamic dispatch, you either have to have a base class pointer to a derived or base class reference to a derived. Either one of those cases will work. But in this case I just have a B, so I know at compile time, exactly what the type of B is and so I know what function to call, okay?","width":1321.3999999761581},{"text":"There's example of each. Why is dynamic binding important for polymorphism?","width":576.3999999761581},{"text":"Why do I need dynamic binding in order to get runtime polymorphism?","width":320.39999997615814},{"text":"First of all, what is polymorphism?","width":768.3999999761581},{"text":"...","width":256.39999997615814}]