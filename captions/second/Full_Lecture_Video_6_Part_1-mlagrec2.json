[{"text":"Okay, let's get started.  So last time, we were ending off, with doing the assignment operator and I didn't get as far as I wanted to.","width":896},{"text":"So I'm going to quickly rap up the conversation we were having about operator equal.","width":320},{"text":"But first, why?  Let's answer this first question here.  So as a warmup, if you look inside this book class, I've two different definitions of operator(). ","width":640},{"text":"Right?  I've got one that returns a const string reference, and is itself a const member function.  Right?","width":448},{"text":"This meaning the const applies to the return type, and this meaning that the const applies to the object to which this function was called.  Right?","width":640},{"text":"And then here I have one that doesn't have either const, right?  The return value isn't const; it's just a reference AND the member function itself is not marked const.  ","width":640},{"text":"Why did the author of the book class choose to do this?  Why are there two?","width":384},{"text":"Right.  So the second one is there, so that I can change a particular line in this book right?  I can give it a chapter, and I can give it a line, and that gives me a non const reference to the string at that position in the array.","width":1024},{"text":"Right?  So I can use the second one to say something like, \"b of 3,4 is, you know, \"see spot run\"\"","width":960},{"text":"And that's going to invoke the nonconst version, right?  Cause I'm allowed to assign into the reference that is being returned out of this function, right?  ","width":896},{"text":"The second overload, is for this case, where I want to assign into the value there.  Okay?","width":320},{"text":"Note that if b, was a const reference, like if I'm in a function and I'm taking a book by const reference, and I'd try to do something like this, it won't work.","width":704},{"text":"Right?  Cause I'm trying to call a member function that's nonconst, so it","width":512},{"text":"won't let me.  Right?  So then if I've got this one, then why do I need the second one that returns a const reference and is const?  Why do I need that one then?","width":384},{"text":"Right!  If I have a const reference, and I wanna just look at the line in that position, I still need a function that I can call.","width":640},{"text":"It can't be the one that's nonconst and returns a nonconst reference cause I could change the class through that.","width":320},{"text":"Right?  So that just having the second one isn't sufficient, because if I am dealing with a book that is constant, I can't even invoke the second function.","width":512},{"text":"So just having the second one won't be enough.  If I have a const book and I want to look at the things inside of it, I'm going to need an overload for operator parenthesis, that is marked const.","width":640},{"text":"Okay?  So bare minimum, I'm going to need another overload that has the const there.  It returns a const reference, cause I'm returning a reference to a member variable, which will be flagged const because the member function is itself const.","width":832},{"text":"Remember:  const is a promise to the compiler, that in this function, I'm going to treat my object as though it was const, it's not mutable.","width":512},{"text":"That means that every single member variable is const.  So if I'm returning a reference to inside of some member variable somewhere, that reference better be const because it's const inside of the nonmutating operator parenthesis.","width":896},{"text":"Right?  So I have two of them here, to handle the case where I want to use it to modify, and when I don't want to use it to modify.  Right?  Does that make sense?","width":576},{"text":"For the one that doesn't modify it, why am I not returning by value?","width":640},{"text":"Return by value right? And then we know return by value means that a copy will be made of the thing that I am returning.","width":448},{"text":"So then, I'm giving somebody a copy of the line, so now they can't modify the line, so it accomplishes that goal right?  Why do I choose to return by const reference here?  Yes.","width":704},{"text":"Why would I not want to make the copy?","width":512},{"text":"It's more expensive.  Right?  If I don't need to make the copy, if all I'm doing is just looking at the string.  ","width":512},{"text":"Like let's say I want to add up the lengths of all the lines in the 4th chapter, or something.  Right?","width":320},{"text":"If I'm just looking at the string, there's no point in copying it.  I don't need to copy it.","width":384},{"text":"Right?  Copying it is expensive.  I'm gonna have to copy the whole line, and I'm going to do that for every single line if I'm just adding up the sizes.","width":384},{"text":"I really don't need an independent copy of that string, so I return it by reference, and then I don't have to make that copy so then it's gonna be faster.  Right?","width":576},{"text":"I could return by value here, and the semantics would be fine and the class would work.  It's not like it's not going to compile or it's going to cause runtime errors or anything.","width":640},{"text":"It'd be fine; it's just not efficient.  Right?  You're forcing the users to make a copy whenever they've got a read-only book.","width":448},{"text":"When they probably don't need to right?  If I'm just adding up the lengths, so I'm just gonna have a for loop and I'm gonna say, ya know","width":384},{"text":"\"Line of 3,1 dot length, b of 3,2 dot length, b of 3,4 dot length\"  Right?  I don't need to copy the line every time I just call \"dot length\".  I'm just going to ask for the length of the string, I don't want to copy it.  Right?  Does that make sense? ","width":960},{"text":"Ya.  Both.  Right?  Copying is going to take time, because I'm going to have to make memory for the string that I'm copying, like the copy that I'm making.  Right?  That takes some time.","width":960},{"text":"Then I have to copy over every character of the string, and it's going to take a while to do that.","width":384},{"text":"Right?  So that's going to take time.  It's also gonna take memory because I'm making a string and destroying a string, making a string and destroying a string, making a string and destroying a string every line.","width":576},{"text":"Right?  So it's expensive both in terms of memory, because I'm allocating, deallocating, allocating, deallocating.  So it's not like, I guess your memory usage isn't increase throughout the whole function, because they are all going to be destroyed.","width":768},{"text":"You're thrashing that memory allocator, it's has to go \"put something in the heap, delete something in the heap, put something in the heap, delete something in the heap, put something in the heap, delete something in the heap\"","width":448},{"text":"Right?  And all of those are expensive, because it has to locate a position that's satisfactory, that has enough room in it for that string.  Make that spot, fill it up. ","width":576},{"text":"Get rid of it again. Find the next string, find the spot that's open in the heap that has enough room for that.  Put it there, copy it over.  So that's going to be very expensive, both in terms of running time.  Mostly in terms of running time, but may also in terms of memory as well because you'll fragment your heap","width":1088},{"text":"Good question.  So when is a good example of when I might just want to return something, out of my class that's a reference to a member variable.  When would I actually want to copy it?","width":832},{"text":"Most of the time, probably not.  If the user wants a copy, they can always make a copy.  Right?  If you give them a const reference, they can always copy construct from the const reference.","width":640},{"text":"So it's almost always better to be returning out of your class by const reference if you can.  If you've got a primitive type that's like a size, or like a bool, or a float, or a character, returning a reference to it is kind of silly.","width":1152},{"text":"Because the reference is going to take up at least as much room as a pointer type does, cause it has to internally know what it is referring to.","width":448},{"text":"So if you're referring a reference to like an integer, which is like going to be same size anyway.  Eh","width":448}]