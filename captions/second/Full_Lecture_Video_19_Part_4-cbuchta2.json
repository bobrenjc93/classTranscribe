[{"text":"What about a 77? ","width":512},{"text":"The 77 right is going to be, so it cant be in the left subtree of the 50 now since its bigger. So it has to be somewhere in this subtree. ","width":704},{"text":"Well its still bigger than the 72 so it better be in this subtree. And its still bigger than 76 so it had better be over here.","width":1088},{"text":"Does that sort of feel familiar?","width":320},{"text":"The way this is working? This is basically a find. Were doing the same thing as we would do in a find. Except we have no intent of actually finding the element. We want to stick it somewhere instead.","width":704},{"text":"So what i want to insert a 51? ","width":384},{"text":"Well again i sort of start at the root, 51 well okay it cant be in the left subtree of the 50 so im gonna go to this side. It has to be in this subtree. Well 51 is smaller than 72 so it had better be in this subtree. And the 51 is smaller than the 54 so it had better be in this subtree so im going to put it there.","width":1664},{"text":"Does this sort of make sense? So youre kinda doing what you would do to locate that element if it existed. And then when you find that it doesnt, instead of throwing the exception saying oh no i couldnt find it, you put it there. [student question] ","width":1792},{"text":"This is the same problem as the height is bad. His point was it doesnt look like the root will ever  really change so it we pick a really bad number for the root, like 1 and then i insert everything bigger than 1 its all going to be in the right subtree of the 1 and ive sort of increased my height for no real gain.","width":1280},{"text":"Id rather pick something in the middle of the range and make that be the root and then im fine.","width":256},{"text":"So well get to that in a bit and this is going to be called height balancing. For now were just going to think about how would you do these things if we ignore the height balancing stuff so that you know how that works. And then i can throw the height balancing wrench into the mix.","width":960},{"text":"Because you have to understand whats happening first. And then make it more complicated. I dont want to start with the super complicated part.","width":384},{"text":"But were definitely getting there. And that is absolutely the way you should be thinking when youre looking at any new data structure: how can i break it?","width":512},{"text":"This is trivially breakable but well fix it in a bit. Okay so lets actually write the code that does an insert.","width":576},{"text":"Okay again were gonna have this sort of public private duality going on. So we have a public function that then calls a recursive private function.","width":832},{"text":"This is kinda gonna be true of all the operations that we do on the trees.","width":192},{"text":"Youre gonna have some public version that people can call and then youve got some private recursive helper function thats actually doing the work.","width":576},{"text":"So before i fill in the public part lets think about what that argument should be. So before we had that being a const node* subroot. ","width":1024},{"text":"And we didnt have to really care about any unique pointers or anything because we were just looking at stuff.","width":448},{"text":"When were doing an insert thats now different. We want to change one of those pointers in the tree somehow. When we get to that base case where weve found an empty tree we want to change that pointer itself to point at a new node. Instead of just being an empty tree. If you think about what we did when we inserted the 51 here.","width":1600},{"text":"What were really doing is recursing down parts of this subtree and when we get to this point where the left pointer of the 54 is null. ","width":768},{"text":"We want to change the left pointer of the 54 to now point at a new node that weve allocated in the heap.","width":640},{"text":"Since you want to change that pointer im probably going to pass something here by reference just like we did in the reverse function. We pass things by reference to modify them.","width":640},{"text":"So here im going to pass something in by reference. What is the type of the thing that im going to pass in by reference? Ignore the reference part what is the type im going to pass down?","width":704},{"text":"Is it going to be a node*?","width":320},{"text":"What is the type of the left and the right in our node struct?","width":192},{"text":"Unique pointer. So if we wanna change one of those what should this type be?","width":320},{"text":"Unique pointer. So its going to be a unique pointer node reference. ","width":1216},{"text":"Non const because we want to modify it. Its unique pointer because thats the type of the thing we want to change and its by reference because we want to change it. ","width":640},{"text":"Notice that since were passing it by reference here were no changing any ownership at all. We just have a reference to a unique pointer. Its not like when were passing it down were giving off ownership to the recursive function. Were just passing it by reference so theres no ownership changes here at all. All im doing is just giving another name to an existing pointer.","width":1152},{"text":"Im saying that pointer, that one right there. Call that subroot for the purposes of this stackframe call that pointer subroot. And then the next recursive call, that pointer subroot.","width":640},{"text":"But im not actually moving ownership at all. Im not creating any new unique pointers here im just looking at an existing one through a reference to it.","width":640},{"text":"If i had passed this by value that would be a different story. if youre getting a unique pointer by value that means there must be a unique pointer being created as a local variable for your function for that parameter.","width":832},{"text":"So then you know that somebody has given you ownership of something.","width":192},{"text":"So if you look at a function and its taking a unique pointer you can sort of look  at the qualifiers on that type to understand what the semantics mean. I","width":512},{"text":"If its unique pointer by value someone has given you ownership of something. if i had a function and it took a unique pointer node by value then somebody gave my ownership of a subroot. Theyll probably want the new root of the subroot back or something.","width":960},{"text":"If however i pass by reference no ownership changes have happened at all theyre just giving me a way to change the pointer they have given me.","width":448},{"text":"Heres a handle on it. Go ahead an modify it however you like.","width":256},{"text":"But its not changed ownership yet. Now we will change ownership if we modify that pointer to point at something else for sure. But just the act of passing it doesnt do any ownership changes.","width":768}]