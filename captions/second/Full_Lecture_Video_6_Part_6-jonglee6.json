[{"text":"Let's move on. In the prelecture, we talked a lot about move constructors and r values and l values. I want to drill you on making sure you have intuitive feel about r value and l value.","width":1088},{"text":"I've given two definitions: L value and R value. These are very loose definition. There will be specific definition if you look up.","width":640},{"text":"The point of these definitions is to help you have a good move that is right almost every time. For whether something is in L or R value. ","width":640},{"text":"Alright","width":64},{"text":"So, my rule of thumb for L-value is that L value refers to persistent object. i.e. one that has name.","width":512},{"text":"Now, L value is something that can appear on the L, or Left side of assignment. L value is something you can pretentially assign into. Got a name of variable of some kind","width":832},{"text":"And R value is everything else. So, 2 is R value. I can't assign into 2. 2 = 4 No? What? Doesn't make sense. Two does not have memory location. It is just literal. Not a variable, doesn't have name. 2 is R value. ","width":1408},{"text":"Int X: X is an L-value, X could appear in left-side of assignment, x got a name, it's got memory location, i can refer to it. That's an L value.","width":768},{"text":"That's kind of rough rule of thumb we are going to be using to sort of trying tease this thing down.","width":448},{"text":"Let's go through some of these","width":64},{"text":"Five: L or R value?","width":128},{"text":"R value, I can't assign into 5","width":320},{"text":"Int foo, I am gonna call foo","width":320},{"text":"Is that L value or R value?","width":192},{"text":"R value, Right, I can't say food() = 4. Right that is no. That does not make sense. Return value here is not gonna name its temporary value to R value","width":832},{"text":"Does that make sense? I could not assign into that. It 's like saying 12 = something else","width":320},{"text":"alright, what about this one?","width":256},{"text":"More complicated, about class, returning int, value inside of it, implementation is literally value member variable. So T.values that is result of function. R or L value","width":1088},{"text":"Okay. Could it appear on Left - hand side of assignment state","width":640},{"text":"Yes, It's a reference. ","width":192},{"text":"Alright, this is same thing as we are returning by reference to modify the line. ","width":512},{"text":"Here, we return string reference which we then validly appear on left hand side of assignment state. Actually, because we are returning refeence","width":960},{"text":"This is actually L value. It can appear left hand side of assignment state. It can have memory location","width":768},{"text":"It can take address of it. Go to the place where that memory exists. It is L value.","width":576},{"text":"Can I take it to address?","width":448},{"text":"That's another rule of thumb you can use: Can I take the address and return value of it?","width":704},{"text":"Trying to give you rule of thumb you can think about R or L value.","width":640},{"text":"Alright","width":64},{"text":"What about this one? Same thing as before. Except for now returning integer by value","width":576},{"text":"So then is return value by the function L or R value?","width":448},{"text":"R value! I can't take it address, just a value. It has not been placed yet.  ","width":384},{"text":"Does it refer to existing value? It is referring to return value. Temporal return value. Not got a name, it does not have memory location. It is R value, thus.","width":1024},{"text":"Does that subtle make the difference? ","width":128},{"text":"One of them is a reference to existing variable. Other one is just a value that returns. Does not yet been assigned yet. Temporally floating around","width":960},{"text":"What about this one?","width":384},{"text":"Int x: X is a ?","width":192},{"text":"L Value, I can assign into it X got a name and memory location; i can refer to it. X is L value","width":448},{"text":"Const int a, a is a.. ","width":256},{"text":"Okay, using my rules of R value, Can I take it to memory location. It is actually L value. I know it's weird","width":640},{"text":"Okay. it lives somewhere, not a temporary value. It has a name I can refer to it by its name. It is an L value. Even I can't assign it. ","width":704},{"text":"However, it could syntactically appear left hand side of assignment statement. ","width":448},{"text":"You can use other one. Can I take it other memory location. Yes L value. ","width":512},{"text":"Rules are loose.","width":384},{"text":"You should be starting to get intuition about this. What about this one?","width":448},{"text":"Array is stack, allocated array of size 2. Just say an array","width":640},{"text":"This is actually a R value","width":256},{"text":"Because in order to get L value, you have to say array at a position, array, cannot assign into that. ","width":768},{"text":"It is R value","width":128},{"text":"However, this one is an L value. Referring to the position of the array; it is fine, i can assign it. Array itself is R value","width":640},{"text":"Again, just ..","width":192},{"text":"Yea, it's.","width":640},{"text":"Yes, So the problem is that the array itself, this is totally off. ","width":768},{"text":"Array itself is just a memory location. Particularly, for stack allocated array, it is not like memory location you can change. it is something burned into the stack frame . Array itself is hardcoded memory location","width":1152},{"text":"It is elements of that variable","width":256},{"text":"It is weird, specifically for stack allocated array","width":384}]