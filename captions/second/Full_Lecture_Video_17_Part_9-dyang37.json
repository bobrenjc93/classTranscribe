[{"text":"We're gonna write a recurrence that tells me the sum of all the heights of all the subtrees in some tree of height h.","width":589},{"text":"","width":173},{"text":"","width":57},{"text":"Some heap of height h","width":1094},{"text":"So our base case, we're just gonna use 0 this time because it's simpler to use 0. So what is the sum of the heigtrh of all the subtree in a binary tree of heigth 0? 0! There's only one subtree which is rooted at height 0. So this is just gonna be 0, right?","width":1731},{"text":"what about the general case? S(h)?","width":476},{"text":"In general, what is the sum f the height of all the subtrees in some binary tree of height h? Hint: You'll use recurrsion here. So in the worst case, again we are thinking what is the worst it could be.  The worst case it could be is that I got two children, both of which are h-1, cause I have to add up their total sums for h-1, right? So the worst case here is that I got two children that are in fact h-1. So it's gonna be 2*S(h-1).","width":3904},{"text":"So I've taken care of my children. What contribution does the current node add?","width":640},{"text":"The sum of all the heights of all of its subtrees. It's just gonna add an h. That the tree, like, we've taken care of the sum of the height of all of the subtrees below me. So what is the height of the current subtree? h, right? by definition. So this is our recurrence. This is a recursive function that tells me for a given height, what is the sum of the height of all the subtrees in height h. This is equvialent to the worst case for our build heap algorithm.  The best case is a little better. Cause you don't have, not all the trees are 'h-1's. So you don't have quite as much height work to do. But this is modeling the worst case. So this is as bad as it could be. Then I did unrolling with some crazy form which you don't need to remember, and derived as some close form that looks like this. That ends up being the formular for the sum of the height of all the subtrees in a tree with height h. We then proved this closed form summation. This closed form summation is actually correct, by using induction. And we got recurrence. You find the close form, you proved the induction. This should start to feel formulaic ","width":5504},{"text":"So prove by indutrion on the h. Our base case is gonna be h = 0, since we only care about non-empty things. So S(0) is 0 by definition, and if we apply our formula for h is 0, we get 2^1-0-2, this is 0. ","width":2560},{"text":"So our formula matches our base case, so our formula is correct for h(0), so we now show that this is correct for general h. So our inductive case is gonna be when h >0, right? Cause otherrwise it's base case. So h is bigger than 0, so what is our  inductive hypothesis going to say?","width":2496},{"text":"For all k < h, s(k) is 2^(k+1) - k -2, right?","width":1024},{"text":"My inductive hypothesis makes a claim about all the things that are smaller than h.","width":768},{"text":"I'm gonna use taht assumtipn to prove that it works for h.","width":512},{"text":"Well, we have S(h) = 2*S(h-1) + h, by definition","width":768},{"text":"So, then by the inductive hypothesis, we see that this is equal to S(h) = 2(2^h - h + 1 - 2) + h","width":2880},{"text":"So all I did was substitute in the formula for the case of S(h-1), because h-1 satisfies the codition of being a k ","width":832},{"text":"So this is equal to @^(h+1) - 2h - 2 +h","width":1280},{"text":"Which is just 2^(h+1) -h -2","width":448},{"text":"So now we got that S(h) is equal to our closed form. So we are done. We've shown that this is the closed form for our summation","width":1152},{"text":"So you got this crazy summation. Again this summation is in terms of h.","width":640}]