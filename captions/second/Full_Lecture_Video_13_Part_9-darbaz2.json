[{"text":"if I push a whole bunch of stuff on the array and then pop a whole bunch of stuff, getting the next element is going to be very easy. If I push a whole bunch of stuff for the list and pop a whole bunch of stuff, I'll have to traverse pointers all over the room if the room is my heap memory. It's not all contiguous, it takes much much longer so the array is not so bad. what's the bad one here? doubly linked list, yes! why?","width":1856},{"text":"it's got an extra pointer in that I didn't really need. so here's a case you would use a singly linked list over a doubly linked list, if you're going to use a linked list at all.","width":1024},{"text":"Why not use a singly linked list? it's easy, it's just as easy as doubly linked list, it uses order n less memory because you're using one less pointer per node. so in this case I probably wouldn't pick a doubly linked list","width":1152},{"text":"we're not even talking about disk at this point, we're talking about memory","width":1024},{"text":"this doesn't have to do with the disk on the machine yet, the seek time is still faster because of the caching layers inside the cpu itself, regardless of what your drive is this will be faster","width":1280},{"text":"this isn't even touching the disk yet, this is all in memory and contiguous memory is still faster than non contiguous memory, which is a little weird because it's random access right? but it's not","width":768},{"text":"in practice, it's really not","width":192},{"text":"if you are in CS, you will discover that as you take computer architecture courses, if you're in ECE you probably already know that","width":448},{"text":"or you're going to know that pretty quickly because you do a lot more with the hardware than I do","width":576},{"text":"it's not part of the ADT so I don't care. if the purpose is to implement this particular ADT then you can add extra functionality and that changes what you do but just to do the ADT it's not necessary","width":2368},{"text":"any more questions?","width":256},{"text":"let's implement another data structure","width":512},{"text":"dejavu! implement a data structure identical to the one above, it has the following adt functions, push pop and peek, the same definitions as before with the exception that the first element to be removed is now the least recently inserted element. before it was the most recently inserted, now it's the least","width":1728},{"text":"it's the exact opposite of what we had before","width":320},{"text":"what physical process does this remind you of, where the first thing that goes in is the first thing that's going to come out","width":768},{"text":"yes, the queue of the shows that you're watching, right? exactly! what else, what is a really boring one? grocery shopping or the dmv, right? here's your number, sit down and you have to wait until your numer is called. this is any queueing system is going to be ling this. so this ADT is the queue ADT","width":2304},{"text":"first thing that's in the queue is the first thing that's going to come out. first in first out","width":512},{"text":"what about the stack? what was that one? first in last out or last in first out? last in first out.","width":1088},{"text":"the last thing you put in is the first thing that came out","width":320},{"text":"these two things are really similar but that subtle difference makes all the difference","width":512},{"text":"and our queue would ensue if in grocery shopping the last person to enter the store is the first person to check out","width":512},{"text":"or the last person that shows up at the DMV is the first one that gets their license, that would be awful. so a subtle difference, it looks exactly the same in terms of what the ADT is but the actual functionality is vastly different because the ordering that it gives you is completely different. so the stack ADT and the queue ADT often called ordering structures, they are different from containers.","width":1792},{"text":"containers give you an order, the order you put things in and you can iterate through the container, you can get to everything in there, you sort of know where things are relative to other things, you know 3 comes before the 4","width":832},{"text":"in an ordering structure, you have no idea. conceptually, you can think about what's currently in there if you think about the implementation details","width":512},{"text":"but for the ADT you have no idea what the order of the things are, you just know that the next thing that's going to come out is either the last thing put in for the stack or the first thing put in for the queue","width":640},{"text":"so these are often called ordering structures and we use these in several different algorithms to provide ordering for the operations that you want to be doing","width":704},{"text":"a stack can be used to simulate recursion","width":448},{"text":"and the queues are often used for buffers, queues in general, so queuing up a whole bunch of network transfers if you're downloading like 8 files, there is only one network interface right, somehow those packets are being queued up. something is holding those in the order that you're receiving them if you're using TCP so there's queues all over the place and that sort of stuff","width":1856},{"text":"so these two structures are really important. okay so","width":512},{"text":"let's quickly go through what this is going to look like, I'm going to draw a picture and the way I draw queues is always like this","width":576},{"text":"where this is where I'm putting them in and this is where they're coming out","width":320},{"text":"so push 1, the 1 is going to go here, push 2, the 2 is going to go here, push 3, the 3 will go here","width":576},{"text":"pop, means the 1, so this is 1","width":256},{"text":"push 4,","width":192},{"text":"put the 4 in the back, I'm putting things at the back and I'm taking things off the front, so pop is going to give me the 2, pop again will give me the 3, push 5","width":704},{"text":"pop 4, pop 5.","width":320},{"text":"okay so these things came off in the same order that I put them in","width":256}]