[{"text":"and then I , you know, update the rate base on that picture","width":640},{"text":"And then I run again, and again, and again, and again","width":192},{"text":" right, so make sense","width":128},{"text":" what's happening there? Yeah","width":192},{"text":"right, this is why, this is why we maintaining that size index","width":704},{"text":" so instead of using the size of the array as our termination","width":384},{"text":"we use our size variable","width":64},{"text":"so we don't keep going","width":192},{"text":"so instead of checking the actual size of our array","width":128},{"text":"we check what is our heap size","width":192},{"text":"we start that out with the size of the array and we decremented every time when we do a pop","width":192},{"text":"that's a key point","width":128},{"text":"but there still stuff in the array below this out of need but they were pretending they are isn't","width":256},{"text":"but we stopped, because we are not, we're pretending that array stopped wherever our size of index is","width":448},{"text":"and there is nothing have to do that","width":128},{"text":"even though","width":128},{"text":"there totally is","width":64},{"text":"that is the point","width":64},{"text":"make sense? how are we doing?","width":320},{"text":"this is pop of whole bunch of times except if you don't actually have to move your element to the back of your index","width":384},{"text":"you just decrement the index","width":64},{"text":"that is all of this","width":64},{"text":" really nothing complicated","width":192},{"text":"this is just pop","width":64},{"text":"pop pop pop","width":64},{"text":"except you are not actually moving the last item","width":256},{"text":"so we are going to build the heap, we are gonna repeated the call pop","width":3264},{"text":"without actually removing any of the elements","width":256},{"text":" instead, we are just gonna shrink, the part of the array that we pretend is the heap","width":192},{"text":"ok, the part of the array we are treating as our heap is shrinking everytime we call pop","width":320},{"text":"and we are leaving those elements in our arrays, that we end up with this array being completely sort of","width":256},{"text":"alright","width":128},{"text":" so one of this array sorted in","width":192},{"text":"upscending order, that is smallest to largest, how is the algorithm going to change","width":320},{"text":"using a max heap instead","width":192},{"text":"and the only difference is in what kind of heap if I build in the preprocessing step","width":640},{"text":"if I want it in","width":128},{"text":"descending order","width":64},{"text":"I use a min heap","width":128},{"text":"but if I wnat a upscending order, I use a max heap","width":192},{"text":" because what I am filling in the array is actually the last element","width":320},{"text":"first,so if I am going from back to front, I use the reverse of what I actually want the elements","width":448},{"text":"How long is our actuall sorting process take then","width":576},{"text":" oh, we know it's basically calling pop again, and again and again... ...","width":256},{"text":"how many time do we called pop?","width":192},{"text":"N times?","width":192},{"text":" how long does each one of those pops take","width":192},{"text":"log I where I is the current size of the heap","width":192},{"text":" right, not every one of them is log n","width":256},{"text":"the first one is log n","width":128},{"text":"the second one is log n-1","width":256},{"text":"the third one is log n-2","width":64},{"text":"the fourth one is log n-3, right?","width":64},{"text":" so what you really have is","width":128},{"text":"a summation for i because log n is log I","width":320},{"text":" right, because you can think of that the other way around,is log1+ log2+Log3+Log4...to log n","width":448},{"text":" but we know from homework zero and this is n log n","width":512},{"text":" you can use this as alternative","width":1152},{"text":"so the whole algorithm is going to take big O, our free process step, plus sorting step which was just","width":832},{"text":" right because the n was dominate by nlogn","width":128},{"text":"so this give you the same running time as most of the other sorts that you probably know about","width":128},{"text":"that are good","width":128},{"text":" right, it's like the best case for quick sork, just like the worst case for merge sort","width":512},{"text":"this gives us same theorical running time as merg sort. you could use this","width":512},{"text":"alternatively, instead of using a merge sort","width":256},{"text":"when I even want to do that","width":256},{"text":" want to use this instead of merge sort","width":192},{"text":"yes","width":192},{"text":"space","width":64},{"text":"right, this is in place, this has a really nice property","width":192},{"text":"which shares would quick sort","width":128},{"text":"that is in place","width":128},{"text":"ut we don't have to allocate any new arrays, we don't have any temporary storage, nothing at all","width":384},{"text":"we are using excatly this array and only this array","width":64},{"text":"so if you're worried about the space consumption","width":256},{"text":"if your array is really, really really big","width":128},{"text":"and you stiil need to guarantee that your sort is n log n","width":256},{"text":"which quick sort doesn't give you","width":128},{"text":"and you also concerned about your space","width":192},{"text":" using a heap sort resonable","width":192},{"text":"this algorithm is called heap sort","width":192},{"text":"questions on that","width":768}]