[{"text":"Or we have two children.","width":384},{"text":"Those are all of the edge cases we've got, OK? If it's a one child removal, that's as simple as setting the pointer to null because there is no subtree below that, you don't have to care about anything else. So one child remove, fine.","width":1472},{"text":"One child remove, if there's only one child, you pick that to be the new root, and you get rid of the current root.","width":960},{"text":"There's only one possible subtree that could be the new root.","width":384},{"text":"If we've got two children, things get a little bit more interesting.","width":448},{"text":"If I actually want to remove the fifty, and I'm using the in-order predecessor, I need to swap the twenty-three with the fifty, and again I'd probably be doing this with node pointer manipulation rather than manipulating the data.","width":1536},{"text":"Now I need to remove the fifty. Well removing the fifty is again another removal case, which in this case is a one-child remove, OK? So doing the two child remove is actually going to have two removal steps. The first is swapping it with the in-order predecessor, and then calling the removal on the root itself.","width":1984},{"text":"So there's three steps: One, get the IOP, then swap, then delete the node where the IOP was.","width":896},{"text":"Removing that position could also be a more complicated removal.","width":384},{"text":"So think about this carefully for a second.","width":256},{"text":"Which cases could apply for when we're removing the node here?","width":448},{"text":"So after we've swapped with the IOP, we wanna remove that location in the tree. Which removal case could apply for that removal?","width":768},{"text":"It could be node child, if this doesn't have a child there, then we know it's a node child remove. We know it could be a one child, because there it is.","width":960},{"text":"Why can't it be a two child? By definition, if it's a two child remove, by definition you didn't find the IOP.","width":704},{"text":"The in-order predecessor of the fifty, had aught to be the twenty-five, not the twenty-three.","width":1856},{"text":"So only this case or this case could be called from the two-child remove case.","width":512},{"text":"So it's not like a two-child could cause a two child could cause a two child and a recursive case.","width":704},{"text":"A no child just does a null set, a one child is just going to move the root pointer up, and the two child remove is going to locate the IOP, swap with it, then call the remove node on the IOP's old location, which itself is just going to be a one child or no child removal.","width":1792},{"text":"So you're saying you want to remove the twenty-three. So what we need to do is, remember when I'm saying we're removing the twenty-three, we're really calling it on this node here, which is the seventeen pointing to the twenty-three. We have access to the twenty-three's left child. So we could say the subroot is std::move(subroot->left), so that just says this pointer should take ownership of this, this goes down here, this is going to be null, there's nothing pointing at the twenty-three, so it better be going out of scope.","width":5568},{"text":"If you have a unique pointer and you assign a new pointer to it, it has to grab the pointer you care about and calls a delete on its own pointer, and is then reassigned.","width":2560},{"text":"So let's write the remove node helper function, now. So remember, our remove function just walks the tree, finds the key we want to remove, and then calls this remove node function on that pointer.","width":1792},{"text":"So this is being called on the unique pointer to the node that we want to get rid of.","width":448},{"text":"So now we have to diagnos which of these cases it is.","width":384},{"text":"So I'm going to write all of the cases as a separate helper function","width":320},{"text":"So i'm going to have a no child remove, a one child remove, and a two child remove.","width":512},{"text":"So the most complicated one is certainly going to be this guy, because that as to locate the IOP, swap, and then call the remove again.","width":896},{"text":"So, if I'm asked to remove a node, how do I check which one of these to call?","width":640},{"text":"There's three helper functions, and three if statements.","width":320},{"text":"When am I going to call a no child remove?","width":128}]