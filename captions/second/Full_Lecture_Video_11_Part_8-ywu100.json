[{"text":"This is a pointer to the current iterator, *this is the iterator itself.","width":411},{"text":"And now we're invoking ++ on the iterator itself, which is going to do this line of code for us.","width":500},{"text":"Doesn't really save us a whole lot here, but you could imagine a very complicated iterator over some graphical structure where there's a whole bunch of triangles that represent the face of somebody and you're working at pixar, right?","width":816},{"text":"And moving forward in this structure involves figuring out which polygon you need to go to next and maybe doing some calculations and stuff, and they don't want to rewrite that for doing postfix increment.","width":578},{"text":"So this is an easy way to just reuse the exact same code that you already wrote.","width":213},{"text":"But it would be equivalent if I just copied this line down here. That's also fine.","width":399},{"text":"And then finally, what do I return?","width":245},{"text":"Ret.","width":128},{"text":"Because I want to return what this used to be, and when I say ++*this, I'm changing what this is pointing at.","width":333},{"text":"So this return the old state. The old iteration state.","width":621},{"text":"I am not going to finish implementing this iterator, but you could imagine how to do the rest. I believe you are completely capable of doing the rest.","width":455},{"text":"How would I write, umm, this one, the dereference operator? What would that return?","width":610},{"text":"If I have an iterator that has a node pointer to the current element, how do I return the actual value of that node?","width":539},{"text":"I need to dereference my current pointer and return what?","width":340},{"text":"I don't want to return a node, what do I want to return?","width":179},{"text":"The data. So I say what, return curr_->data. Right?","width":461},{"text":"I know how to do these. How would I compare them for equality?","width":173},{"text":"What would == look like?","width":367},{"text":"How do you know if these two iterators are pointing at the same thing?","width":256},{"text":"Compare their pointers. Check if the currs are the same. And if they are, these two iterators are the same. ","width":310},{"text":"!= is just the negation of ==, right, so then you've implemented basically this whole thing. Member access is just dereference, but you're returning a pointer to that thing instead of returning the thing itself.","width":640},{"text":"Very basic.","width":110},{"text":"I believe you are capable of doing the rest there.","width":256},{"text":"So let's switch gears again.","width":256},{"text":"And talk about lists.","width":130},{"text":"List implementations.","width":152},{"text":"So I've mentioned doubly-linked-list before, but I haven't shown you what the node class looks like.","width":420},{"text":"What would the declaration of a node class for a doubly-linked-list look like?","width":410},{"text":"Well, I'm going to do the same thing I did before...","width":228},{"text":"I could just say class here, doesn't really matter.","width":393},{"text":"But I'm going to make some class that has some things in it. What are the data elements of this node class? If it's a doubly-linked-list. First of all, what does a doubly-linked-list mean again?","width":682},{"text":"Yeah, you have next and previous. So you have a- every node is going to store the next guy and also a pointer to the previous guy.","width":512},{"text":"So I'm going to have two pointer data elements, and I'm also going to have the data.","width":344},{"text":"Just like a singly-linked list.","width":171},{"text":"So let's start with the stuff that was in the singly-linked list, which is...","width":394},{"text":"Data, and then...","width":920},{"text":"Pointer to the rest of the list that's rooted- that starts at this current node.","width":335},{"text":"But now I need the previous thing, right? What is the type of my previous?","width":384},{"text":"Raw pointer. Woah, wait what? Why is it a raw pointer? That's exactly right, but why is it a raw pointer?","width":554},{"text":"Right, I'm not sharing the ownership. So if I had my previous pointer also being an owning pointer, what does that means about... so if I had a structure that looked like this...","width":1181},{"text":"Okay, and this points there, this points there, this points there, this points there, this is null, this is null, 1, 2, okay?","width":627},{"text":"If I had this structure and those previous pointers were owning pointers, what's true about this \"2\" node?","width":470},{"text":"Who owns the \"2\" node?","width":256},{"text":"1 and 3.","width":145},{"text":"Wait, but we said unique pointer.","width":179},{"text":"The unique part of unique pointer means that there is only ever one owner.","width":390},{"text":"If you have two unique pointers to the same thing, that's undefined behavior.","width":251},{"text":"Because when they're going away, they're going to both call delete on the pointer, which is bad.","width":383},{"text":"So, when we want to refer to the previous element here, we're going to use a raw pointer. Because we know that that node before us is already owned by something.","width":640},{"text":"Someone else has taken ownership of that. This previous pointer is just a way- it's just referring to the thing that came before us.","width":498},{"text":"It's just a way of us getting there.","width":93},{"text":"So it's going to actually be a node* prev.","width":401},{"text":"Not a unique pointer.","width":236},{"text":"And the way of detangling that is to remember who owns what in this list structure.","width":332},{"text":"And so an easy way of doing this is to say, each node owns the next node in the list, but that node only has a reference to the previous one. a pointer to the previous one.","width":620},{"text":"And so now I have a structure like this, where each one of these is a owning pointer instead of a raw pointer.","width":565},{"text":"Previous pointers are just raw pointers.","width":174},{"text":"Okay does that make sense?","width":157},{"text":"Unique means there's only one owner. Can't have 2 owners. That would be bad.","width":303},{"text":"Okay.","width":219},{"text":"Implementation showdown. So now we're going to look at different implementations for our list structure and figure out what is the best one for each function. So we've got push front and pop front...","width":781},{"text":"Push back and pop back.","width":151},{"text":"We're going to have how long does it take to get an iterator to a current position i in the list, so say, give me an iteration to position 5. How long does that take?","width":587},{"text":"Insert before, taking an iterator and a T, because this is now client code, they can call this because they can have iterators, and so this is saying please put a new element before the current thing that this iterator is pointing to.","width":816},{"text":"Insert after, stick it after the iterator.","width":167},{"text":"And erase, taking an iterator, which means remove this element form the list.","width":333},{"text":"I couldn't specify these before, or if I did, they would be a little awkward with indexes and stuff, when I said add I'd give an index, which is a little weird.","width":451},{"text":"Now that I have iterators, I can say these much more nicely. Say please, give me access to the ith element is get an iterator at that position.","width":565},{"text":"Erase element 4 is erase element that's pointed to by this iterator.","width":298},{"text":"So now I can say this more generically, so that's the motivation of even introducing these iterators in the first place.","width":484},{"text":"I don't know how far we're going to get, but we'll see and we'll continue this discussion tomorrow, depending on how far we get.","width":360},{"text":"So let's start with this one. Push front and pop front. ","width":247},{"text":"So...","width":128},{"text":"As usual, let's draw some pictures, so let's talk about the singularly linked-list first.","width":422},{"text":"So for a singly-linked list we're going to have something that looks like this... where we have head...","width":407},{"text":"And just for notational simplicity, when I'm talking about an owning pointer, I'm going to put it with a little box, and when I'm talking about just a normal pointer, I'm just going to make it an arrow.","width":576}]