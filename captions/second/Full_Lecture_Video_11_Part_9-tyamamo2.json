[{"text":"so, we have an owning pointer head that points at a node","width":320},{"text":"1","width":128},{"text":"and then the next","width":128},{"text":"node 2","width":256},{"text":"next node 3","width":256},{"text":"and that last pointer is set to null","width":384},{"text":"push front what should push front do?","width":192},{"text":"well, this is a list adt function that says add something to the front of the list","width":320},{"text":"so how do I implement that for SLL?","width":320},{"text":"so I need to make a node first","width":320},{"text":"make some node","width":128},{"text":"let's say it has data 0","width":128},{"text":"I need to set it's next pointer to what?","width":384},{"text":"the current value head which means that I'm going to move it because these are unique pointers","width":256},{"text":"so this is going to move here presumably i have curr","width":384},{"text":"or something that points to this node that I made","width":256},{"text":"and now what?","width":64},{"text":"move current into head","width":256},{"text":"now say curr you actually don't own that piece of memory, head does","width":256},{"text":"fairly basic","width":320},{"text":"how long did that take?","width":64},{"text":"in terms of n the number of elements in the list","width":256},{"text":"constant","width":64},{"text":"I just did some pointer assignments","width":128},{"text":"I didn't depend on the list length","width":192},{"text":"this list could have gone into iowa","width":320},{"text":"and it wouldn't have changed how long it takes to add something to front of it","width":320},{"text":"it was constant time","width":128},{"text":"so for a SLL push front is O(1)","width":256},{"text":"push front is O(1)","width":640},{"text":"now, what do you want to do next?","width":192},{"text":"popfront on a SLL or do you want to do DLL push front?","width":320},{"text":"I'm going to follow that pattern","width":128},{"text":"do you want to go this way or this way on the table?","width":256},{"text":"so DLL","width":256},{"text":"so what does that look like?","width":320},{"text":"I'm going to still have a head","width":128},{"text":"and it's going to point at a node which is going to be a little bit longer now","width":384},{"text":"each one of this is a unique ptr","width":832},{"text":"these are just raw pointers","width":64},{"text":"how do I add a node to a DLL at the front?","width":640},{"text":"does it look any different?","width":320},{"text":"no","width":128},{"text":"I need to do one more additional step","width":256},{"text":"but functionally doesn't look a whole lot different","width":128},{"text":"so i'm going to make","width":128},{"text":"a node","width":64},{"text":"of right size","width":128},{"text":"right data in it","width":128},{"text":"set it's previous to null","width":128},{"text":"i'm going to having an owning pointer that curr","width":192},{"text":"then what?","width":192},{"text":"same step as last time","width":64},{"text":"i'm going to set it's next to point at the current head","width":192},{"text":"head doesn't point there anymore","width":128},{"text":"then what?","width":64},{"text":"am I done?","width":64},{"text":"i need to fix the previous, so I'm going to say curr-> next->previous","width":384},{"text":"to point curr.get()","width":192},{"text":"and then i'm going to do the same thing as I did before please move curr into head","width":448},{"text":"so there was a little bit more work but it still didnt't depend on the number of elements in this right?","width":320},{"text":"the length of this DLL has no effect on how long this function took","width":320},{"text":"and so, for a DLL push front is also constant time","width":320},{"text":"making sense","width":192},{"text":"doing some elementary algorithm analysis","width":256},{"text":"so what about a vector?","width":192},{"text":"so, this is saying a vector based list ","width":192},{"text":"this is a list whose implementation is with a std vector","width":192},{"text":"and remember std vector is implemented with an array where all of the elements always start at index 0 and go ","width":576},{"text":"incrementally through this array","width":192},{"text":"so that means that our list that would correspond what these two looked like would be something like undefined","width":384},{"text":"it says to assume there is always enough room for this","width":320},{"text":"so it's going to be like 1 2 3 and then a whole bunch of elements set to whatever","width":384},{"text":"this vector","width":320},{"text":"how would I push front on to this?","width":192},{"text":"I gotta make space first, so I need to move the 3 over to here, move the 2 over to here, move the 1 over to here","width":768},{"text":"so I would get something like","width":64},{"text":"like that","width":448},{"text":"makes space and then place the elements just in this first set","width":384},{"text":"how long does that take in terms of the number of things that were in the list?","width":384},{"text":"n order N O(N)","width":64},{"text":"i had to do a linear shift everything had to move over one element and i had to start at the back and move that one over so I had space to move the next one over","width":512},{"text":"and then this one over ...","width":192},{"text":"and that's going to matter depending on how many elements we have on this list","width":320},{"text":"so this is going to be O(N)","width":256},{"text":"what about the reverse operations?","width":384},{"text":"so now i want to remove the first elements on the list","width":192},{"text":"how can I do that?","width":128},{"text":"so I want to go back where I was","width":128},{"text":"on a SLL","width":192},{"text":"I need to get rid of the first node and have head point at the next one","width":1088},{"text":"so I could just say","width":128},{"text":"say that","width":960},{"text":"what will that do?","width":128},{"text":"temp head","width":192},{"text":"head is = std::move head_next","width":192},{"text":"so this is going to become null","width":128},{"text":"and head is going to point to what that was","width":192},{"text":"and are there any owning pointers to that first node now?","width":384},{"text":"no","width":64},{"text":"there are no owning pointers to that node","width":384},{"text":"which means that when we did this move assignment head was going to delete what it pointed at","width":320},{"text":"i virtual using the move semantics of the unique ptr","width":448},{"text":"that node automatically got deleted when we're saying head please point at something else","width":192},{"text":"when we did that with scoped ptr you had to delete your pointer first and then reassign it to look at some other location","width":384},{"text":"so same thing happens in unique ptr","width":128},{"text":"same class","width":64},{"text":"with some different function names","width":192},{"text":"how long did that take?","width":192}]