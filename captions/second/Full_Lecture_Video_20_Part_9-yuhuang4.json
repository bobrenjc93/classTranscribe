[{"text":"Yeah, swap the keys and the values, I am lazy here and not doing the pointer manipulations cause it gets a little hairy","width":704},{"text":"So I'm just gonna swap the keys and swap the values.","width":218},{"text":"So swap iop arrow key.","width":664},{"text":"Swap iop's key and subroot's key, swap iop's value and subroot's value.","width":1175},{"text":"Um, the alternative here is sufficiently nasty that I won't ask you to do this without modifying the data.","width":832},{"text":"So auto doesn't give you references.","width":1200},{"text":"So if you see auto x equal something that return to your references, it actually make you a value with that type.","width":384},{"text":"It's just a weird rule about auto ","width":128},{"text":"That's why when I had range based for loops, I'd say const auto ref cause I actually need to say I need a reference.","width":404},{"text":"I also have to say const if I want const.","width":150},{"text":"So it only figures out what the actual type was, but it doesn't include any reference or const modifiers. ","width":576},{"text":"It will include pointer modifiers, but not references or consts","width":320},{"text":"Because the standard says so.","width":128},{"text":"So I could have write the type here, I was just lazy.","width":387},{"text":"If you are not sure on a exam, write out the type. ","width":664},{"text":"Remember that we were implementing a dictionary ADT, ","width":252},{"text":"Right? And the point of the dictionary ADT is mapping keys to values","width":242},{"text":"So I want be able to say something like for this key, maybe the key is like a string student name.","width":256},{"text":"What's the value associated with that student may be the grade.","width":256},{"text":"So we are implementing the dictionary ADT so our nodes have keys and values.","width":256},{"text":"Refer back to last lecture.","width":278},{"text":"Yes, there is a key and a value.","width":209},{"text":"So I swap the key and the value","width":399},{"text":"Now what's the very last thing I have to do?","width":126},{"text":"So I moved the iops, key and values up onto the subroot that I was trying to remove.","width":384},{"text":"I've move the subroot down where the iop was. So now what's left?","width":279},{"text":"Remove node iop.","width":140},{"text":"So I want to remove the node that is sitting at the position that the iop was.","width":384},{"text":"And I do that importantly through reference to the pointer to the iop.","width":287},{"text":"So I actually remove that thing.","width":124},{"text":"So this will just be a call to remove.","width":384},{"text":"Remove_node(iop)","width":470},{"text":"Remember there is only two cases now for that remove node if I am removing the node that used to be iop's position.","width":554},{"text":"It can only be a no child or one child remove.","width":239},{"text":"So it's not I am going to call two child remove in a loop or something.","width":282},{"text":"It definitely gonna have one of those two simple cases to be done.","width":320},{"text":"Um, no, if iop had a left child, ","width":512},{"text":"What's the iop of the root node?","width":698},{"text":"Oh sorry wrong way around. What's the iop of the root node here?","width":576},{"text":"This guy, it's got a left child.","width":245},{"text":"So I do have to be careful.","width":76},{"text":"Like I can, in the case where it doesn't have any children I can't just set it to null. That's what node child remove will do.","width":427},{"text":"But in the case where it's got a child I have to make sure I am moving that child.","width":384},{"text":"So let's do that.","width":1112},{"text":"So if we were actually going to remove the fifty in this tree.","width":256},{"text":"I first do my remove call and it immediately hit the base case that fifty is at the root.","width":320},{"text":"Then I call remove node on the pointer to the fifty which was the unique pointer we were talking about.","width":320},{"text":"For the root ,","width":128},{"text":"Then I call iop on subroots that finds me the iop and gives me a reference to the pointer to the iop.","width":435},{"text":"So my iop is actually gonna be this pointer here, the one inside seventeen points at twenty three.","width":448},{"text":"Cause the twenty three is the right most node of the left subtree.","width":273},{"text":"Note here that it dose have a child again this is that the case we do care about.","width":295},{"text":"We swap the keys and the values.","width":320},{"text":"So fifty's key and value will be down there and twenty three's key and value will be up there.","width":312},{"text":"And then we say remove node on that iop reference variable which is exactly saying remove node on this pointer here.","width":640},{"text":"Which then we will say subroot now is going to be the right pointer of the seventeen ","width":494},{"text":"Does that node have children? It has one child. So we call one child remove.","width":384},{"text":"And now we do the which side of the tree dose that child exists","width":226},{"text":"Left so we jump the pointer so we would get something like this when we are done.","width":594},{"text":"Property still satisfied, everything works out.","width":175},{"text":"Important parts for finding the iop cause iop or ios are the thing could be the new root.","width":610},{"text":"Of the subtree.","width":64},{"text":"Of the subtree.","width":16},{"text":"And then doing the correct removal for the iop after we swap the thing.","width":256},{"text":"You just told me exactly what it does.","width":1648},{"text":"That's exactly how this is work.","width":113},{"text":"So when I call remove node","width":153},{"text":"It could make another call to remove node only in the case when it's a two child remove.","width":309},{"text":"And that second call will only be a one child or a no child remove.","width":284},{"text":"It won't be a two child remove twice.","width":128}]