[{"text":"Alright, so we call heapify-down on the index, either 0 or 1, depending on whether you've chosen to have 0-based or 1-based heaps.","width":731},{"text":"So we'd call heapify-down on the root index.","width":423},{"text":"We need to figure out where we should move the 20. Now, that's sort of equivalent to saying \"what should the new root of this subtree be?\", the subtree rooted at 20.","width":1017},{"text":"Wasn't rhetorical.","width":176},{"text":"What should the new root be for the tree that's rooted at 20? 3. Why should it be the 3?","width":475},{"text":"It's the smallest element, i.e. it has the highest priority.","width":256},{"text":"right?","width":45},{"text":"So, we leverage the fact that we know that our two children, our two subtrees, are definitely heaps, to be figure out what's the most promising-looking element right now.","width":782},{"text":"So we can just look at the root of both of those subtrees and figure out which one's smaller.","width":373},{"text":"And then we know that that one aught to be the new root.","width":256},{"text":"So in this case, we notice that 3 is the smaller child, so we swap 3 up to the root and 20 down here.","width":631},{"text":"Couldn't swap with the 4 because then we would have the 3 being on the right hand side, still being smaller than the root, so that's no good. So we have to make sure we're swapping with the right child- the correct child, not always the right. The CORRECT child, when we're heapifying down.","width":1164},{"text":"And i'm not done here, I need to call heapify down again, on where I move the 20, because the 20, right, this tree here, can still be messed up, and in fact it is.","width":614},{"text":"I know that pretty much everything over here is now fixed.","width":348},{"text":"I move the smaller of the two children up to the root, so i know that the left subtree, or the right subtree, without loss of generality, is happy because I moved something smaller than it's root above it, so it doesn't care","width":715},{"text":"The only part of the tree that I have to worry about now is the tree rooted at 20. So I call heapify-down again on the index where I moved the 20.","width":577},{"text":"So again, I compare with the small- I see which of my children is smallest, in this case it's the 4, and I say \"is that smaller than me?\" Yes.","width":620},{"text":"So now I need to swap again, with the smaller of the two children, which is the 4.","width":384},{"text":"And now the 20's back where it started.","width":444},{"text":"Notice now that the heap property is satisfied.","width":359},{"text":"And then also notice, like, what's the farthest we could possibly moved that 20 down? Like how many swaps are there in the worst case for this?","width":740},{"text":"O(h), right? The number of levels in this structure.","width":350},{"text":"Because every time I recurse, I'm moving down to the next level, so I only care about the height. So this is also O(h).","width":824},{"text":"Okay, so I want to remove one more element, so again, same process, I'm going to swap the 3 down here, and I think that was a 7.","width":621},{"text":"Then I can pop back, easy to remove the 3, and now it's just a matter of putting 7 in it's appropriate place.","width":448},{"text":"So I heapify-down on the root here, I look for the smallest child, which is the 4,","width":448},{"text":"So now the 4 is back where it went, and now there's a 7 here. Again, I have to heapify-down on the place where I moved that element so I heapify-down on the element where 7 resides, ","width":768},{"text":"And now I look at the smaller of the two children, which is 6, so now the 6 is swapped with the 7 and we're back looking like this. Convenient.","width":704},{"text":"Now it looks like I've done nothing at all.","width":384},{"text":"I've actually done a whole bunch. ","width":69},{"text":"Okay? Any questions on what that pop operation looked like?","width":424},{"text":"Again, the intuition here is sort of, move the element to where it's convenient, and then fix the heap property that you may have violated in the process of doing that, so we swap the root down with the back, and then fixed the root to go into the appropriate position.","width":1178},{"text":"Yeah?","width":192},{"text":"[Student asks question]","width":434},{"text":"Some people find starting at 1 easier for doing the left and right and parent calculations, I don't.","width":450},{"text":"Because it's easy to do it either way.","width":217},{"text":"If you're doing a 1-based heap, you're wasting 1 element of space. I always put it at 0 because that's easier for me.","width":608},{"text":"There's not really any convention.","width":193},{"text":"The reason why at all somebody might want to start from 1 is purely just for convenience in calculating what your left and right should be.","width":384},{"text":"[Student asks question]","width":1679},{"text":"So the problem is that if you're moving it...","width":256},{"text":"You're going to, like, if you're moving the 20 down, you're not replacing the value where the 20 used to be.","width":761},{"text":"Right if I've got, 30 here, and I want to do a pop.","width":544},{"text":"I can move the 30 up to here, and then remove this.","width":624},{"text":"And that's fine, but now when I'm moving it down, I need to actually swap it, it has to be a swap.","width":384},{"text":"If I just try to move the 30 to the smaller position, which would be 5 here, all that's doing is moving the 30 here. It's not doing anything about correcting the root. Right I've now lost the 5.","width":819},{"text":"It has to be a swap.","width":192},{"text":"I'm not just moving the 30 down, I'm moving other elements up as well. It has to be a swap.","width":626},{"text":"If I just move elements down, I lose the 5.","width":448},{"text":"[Question]","width":448}]