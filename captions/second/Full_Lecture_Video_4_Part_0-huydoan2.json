[{"text":"","width":1535.6666666269302},{"text":"","width":447.66666662693024},{"text":"","width":3903.6666666269302},{"text":"So somebody asked why we do things like g{5} instead of g(5) when we are trying to construct a variable or trying to set value.","width":703.6666666269302},{"text":"","width":127.66666662693024},{"text":"So you can you parentheses and they will work most of the time. There are certain cases where parentheses won't work and you will get weird compiler error because of the way it's parsing it. So typically I use the braces because the braces will always means to be invoking the constructor. Parentheses will sometimes mean defining a function . So it's not super important but if you're curious about the distinction, go look up the most .... part and you will understand why I'd like to use braces instead of parentheses.","width":1855.6666666269302},{"text":"","width":127.66666662693024},{"text":"","width":575.6666666269302},{"text":"","width":4607.66666662693},{"text":"There's some confusion about uint64_t. That's just a way of saying what kind of integer. So I'm paranoid and I'd like to be clear about the signess and the sign of my integer. But you could have said unsigned int and that would have been okay. ","width":996.6666666269302},{"text":"","width":220.66666662693024},{"text":"very explicit about this is unsigned and it is 64 bit. So it's completely unambiguous, exactly what this type is. But think of it as an integer. There's nothing really different here.","width":803.6666666269302},{"text":"","width":341.66666662693024},{"text":"Somebody has a challenge problem: I want to see if somebody can do this one cause this is a really good question, could be a very reasonable exam prep question.","width":792.6666666269302},{"text":"So somebody asked: \"Can you make a pointer to a pointer in the heap to an int in the stack?\"","width":561.6666666269302},{"text":"","width":127.66666662693024},{"text":"Can I make a pointer to a pointer on the heap to an int on the stack. What is the type of that variable? The answer is yes but what would be the type of the variable: pointer to a pointer on a heap to an integer on the stack?","width":748.6666666269302},{"text":"int **. So it's going to be int** ptr.","width":511.66666662693024},{"text":"","width":319.66666662693024},{"text":"initialize it somehow. We want the memory diagram to look like this. Ptr and then maybe I guess I'll make the int ","width":575.6666666269302},{"text":"","width":191.66666662693024},{"text":"int x =5. There's my int on the stack. I know I want a pointer in the heap to point to that variable on the stack. If I do it correctly, x is actually is define first.","width":575.6666666269302},{"text":"","width":191.66666662693024},{"text":"And then ptr is a pointer to something","width":319.66666662693024},{"text":"","width":127.66666662693024},{"text":"Does anybody want to take a stab at writing a code to do that. it's a pointer to a pointer in the heap to an integer on the stack. Does anybody want to take a shot at filling in the rest of this?","width":703.6666666269302},{"text":"The point of this is to exercise your brain in translating an English explanation of a type and what it's doing to actual code. A pointer to a pointer in the heap to an integer on the stack. We're trying to see if we can figure out to initialize.","width":1983.6666666269302},{"text":"","width":319.66666662693024},{"text":"It said heap, so there's something on the heap.","width":319.66666662693024},{"text":"Allocating anything on the heap, you're going to use new expression.","width":255.66666662693024},{"text":"","width":63.66666662693024},{"text":"* is correct because it's said a pointer to a pointer in the heap.","width":319.66666662693024},{"text":"","width":63.66666662693024},{"text":"So to allocate a pointer in the heap, we're going to have a new type *. So we are making a pointer to x in the heap. So we know we are going to say new int*. That's going to give us an int* in the heap and give us a pointer to that. So that would be an int **. Type matched, it makes sense. ","width":1279.6666666269302},{"text":"","width":447.66666662693024},{"text":"So we've got ptr is being initialized so that new int* in the heap. We are trying to initialized it with x.","width":511.66666662693024},{"text":"I see one tiny error can be fixed with a single character. Does anybody else see it.","width":447.66666662693024},{"text":"&","width":63.66666662693024},{"text":"","width":63.66666662693024},{"text":"You're going to stick an & in front of x. If we just initialize a pointer to an integer, that's a type mismatched. Because we're not giving an pointer type, we are giving an integer.","width":639.6666666269302},{"text":"So we give &x, now we give a pointer to the integer on the stack and now we've done what the question was. This is how you would do that. So this is ptr to a pointer to a pointer in the heap that self points back to an integer on the stack.","width":959.6666666269302},{"text":"","width":63.66666662693024},{"text":"You wouldn't probably do this.","width":127.66666662693024},{"text":"","width":63.66666662693024},{"text":"But this is worth thinking about in term of understanding how you would declare things in term of pointer and stuff.","width":447.66666662693024}]