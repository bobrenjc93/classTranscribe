[{"text":"and actually dictionary","width":960},{"text":"ok, what's the key","width":512},{"text":"a word and what's the value","width":384},{"text":"definition pronouation and knowledge depends on what's kind of dictionary you got","width":256},{"text":"right, but some kind of record that represent about that particular word","width":384},{"text":"yeah","width":128},{"text":"right, so you got to review about it carefully, right, so, so maybe the data elements for a word","width":512},{"text":"contains different definition or all of different pronouation","width":384},{"text":"yeah, you should be careful cuz you can have again ,  you got to have  unique keys to deal with","width":384},{"text":"you want to have a unique key value pair with multiple values for specific key","width":256},{"text":"you got to represent your value as a list of value rather than a single value","width":640},{"text":"not really say anything about what your value has to be, so your value could be ","width":64},{"text":"itself a array of value, or something, could be a class of bunches of fields in it","width":704},{"text":"ok, so what's you implement for this ADT","width":448},{"text":"in so bunches of ways, first, as usual, figure out how to make it better,so","width":192},{"text":"supposed you implement the about ADT with a binary tree","width":256},{"text":"right, the decoration for the binary tree, kv node class, so node we got two temporary parameters","width":512},{"text":"one is the key, and one is the value, so we say the key can be pretty much anything, and the value could also be pretty much anything","width":512},{"text":"so what our node class look like now,well, we got to find the elements and we know the finded and the add operation given in this dictionary takes the key","width":896},{"text":"and gives me the value, so we'd better to  both store the key and value pair together inside my node, so my node class may look like","width":960},{"text":"not T now, it could be K key, V value","width":640},{"text":"so now I have  my key, my value, and my left and right pointers, and again  use the unique pointers here then we have a clear chain of ownership","width":1920},{"text":"right, all the way tree, the really different from the binary tree we'd been talking so far is now I storing two different information elements setting","width":576},{"text":"right, it could be effectively the same thing as we have a binary tree of T, or tree is a pair object with key value, that store","width":896},{"text":"temporary arguments, just like T","width":384},{"text":"so my binary tree is now can be template class k , class v, So we got two template class, this's what about","width":896},{"text":"the node is private, so it doesn't matter , good thinking, normally you don't want public member valuable","width":704},{"text":"this's private implement detail anyway, so the only people who can access would be binary class, so that's fine","width":640},{"text":"so let's try to implement this thing, it seems like a useful thing I have, since it has a lot of real world application for something like this","width":384},{"text":"so let's see how to implement use what we already know now","width":256},{"text":"so i have got four different choices to make here, so let's focus on ","width":576},{"text":"i don't know let's first focus on inserting first","width":256},{"text":"so i insert a key value pair into my implement for this dictionary ADT, and i'm gonna choose the implement this dictionary adt with a sorted array","width":832},{"text":"actually i will focus on one implement first ,and add an example to finish, so I'll do the entire row first","width":384},{"text":"cuz I think it more helps you to think about what's it, what it looks like, done, and think about it as exercise","width":448},{"text":"so, a sorted array, I'm gonna maintain a sorted array for this ADT, when I say a sorted array,what","width":384},{"text":"on what, sorted by, how we sorted by the key, right that's what's I want to look stuffs by","width":448},{"text":"so I should probably sort the array by K, ok, so it could be a sorted array of maybe a key value  pair struct for","width":512},{"text":"that's got the K,k key, V value, or something, so like the data part of that node struct of something","width":448},{"text":"or std::pair Key Value, how do you think about it","width":384},{"text":"ok, I am inserting into the sorted array, so I have already had a sorted array , sorted by key ","width":320},{"text":"and I'm giving a new key value, a pair, to insert, how long it will take me","width":256},{"text":"o(N),right, I can locate where i will going to insert in log(n) time, like I can do a binary search , but I still have to shift stuff all of that way","width":704},{"text":"right, it can be the worse case that shift all the thing over, right, the sorted array will take linear time to insert ","width":704},{"text":"how about remove, by asking you to remove a certain key in this structure, O(n), again I can find it in log(n) time, ","width":576},{"text":"but then I need to get rid of it, and shift all the elements over the copency of the blank that I am just add, so that could be linear time for the shift, ","width":448},{"text":"and the find is finally where we are happy that we can look up in log(n ) time","width":640},{"text":"that's just your, your standard application of binary search, where you're searching for K, and when you are done, you'll return the value associated with the key","width":576},{"text":"but it still your box standard binary search for sorted array ","width":320},{"text":"you could do that, but it's not kind of, you could do that, but it couldn't help you , cuz you still have ","width":1088},{"text":"some like, if, if, so if your bucketing is some fixed constant, say you have twenty six buckets, ","width":448},{"text":"it ends of twenty, the worse case is like n over twenty-six, and even I give you things among the buckets.. So it's still n, but divided by some fixed constant","width":704}]