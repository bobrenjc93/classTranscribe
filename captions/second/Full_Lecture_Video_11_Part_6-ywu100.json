[{"text":"So what must it have?","width":377},{"text":"In other words, what does the compiler translate this into?","width":704},{"text":"What code does the compiler generate for that?","width":381},{"text":"With the iterator, it generates iterator code. This is just a shorthand to tell the compiler to generate the same code that's on the right for the iterator case.","width":671},{"text":"So it requires that the class have a .begin() and a .end() to get iterators.","width":438},{"text":"So you need to have 2 functions here. Begin() and End().","width":537},{"text":"And if you have those, and they return iterators, and the iterator class behaves like an iterator, then you can use this range-based for loop for any container that has those, which is pretty much everything in the standard library.","width":970},{"text":"Why is this range-based for nice?","width":249},{"text":"What can I not do with a range-based for loop, that I might be able to do with these other ones? What mistakes is it impossible to make? Let me put it that way.","width":716},{"text":"So let me say that again. What mistakes is it impossible to make if I'm using a range-based for loop?","width":340},{"text":"Index out of bounds. I can't accidentally go one over, I can't have it off by one in my iteration statement, I can't accidentally set i to 0 somehow in the body of the loop, it's not possible.","width":872},{"text":"With both the for loop with an index and the for loop with an iterator, I could do those things. I could accidentally screw up the iterator it, I could increment it twice, or set it back to begin, or set it to end, or do something, set it to be an iterator into another vector, or something.","width":947},{"text":"I could do weird accidental things in the body of that for loop.","width":217},{"text":"I can't do that with a range-based for loop. It's not possible for me to screw up the iteration state, because that iteration state is handled by the compiler; I don't even have access to it.","width":694},{"text":"Which is nice, because that means that all those errors, you can't make. It's not possible.","width":292},{"text":"You can still terminate early, you can break and do all the same things you can do in normal for loops, it's just that the iteration state is now encapsulated for you, which is very nice.","width":539},{"text":"It also allows the compiler to generate very very efficient code for this kind of loop.","width":289},{"text":"This range-based for loop is as good as the operator[] loop, in terms of the compiled code; there's no fundamental difference.","width":1024},{"text":"yeah?","width":71},{"text":"If you wanted to start from anywhere other than the beginning, you can't do a range-based for loop.","width":256},{"text":"So then you're prescribing what the iteration state is. The iteration state should start here. Then you'd have to use iterators, or indexes, depending on your structure.","width":680},{"text":"Lists, you can't use indexes because they don't have an indexing operator, so it's not possible to do it that way. ","width":310},{"text":"But, they do have iterators, so it's possible to do it with iterators. So all of these structures provide these, so that there's this same consistent interface across all of them.","width":657},{"text":"Motivation for those make sense? Does that ring- is that hitting home? Why we even have these?","width":466},{"text":"Because we can write code that doesn't care about what the container is?","width":256},{"text":"Okay.","width":320},{"text":"Let's look at this.","width":163},{"text":"Here I've given you a declaration for an iterator class. Okay?","width":450},{"text":"","width":10},{"text":"","width":128},{"text":"So what does this thing have? Well, it's got a default constructor, which we don't know what it does, it has a constructor that takes a pointer to a node, it's got two flavors of operator ++. Oops.","width":1092},{"text":"And they return different things, and one of them has an int for as an argument. This is just the way that you have to specify prefix and postfix increment. The first one is prefix, so this is what happens if you do ++it...","width":998},{"text":"And this one is post-fix, so this is it++.","width":335},{"text":"That int in the argument, you just ignore, it just has to be part of the function signature, that's just how the compiler differentiates between the two.","width":528},{"text":"There's another difference in the signature here. ++it, the prefix increment, returns a reference to an iterator.","width":591},{"text":"So this will typically be the current iterator. ","width":365},{"text":"The postfix increment, if you've ever looked at what's the return value of i++, it's the old value of i. And then it increments i.","width":666},{"text":"Whereas ++i returns you the new incremented value of i.","width":279},{"text":"So postfix increment on an iterator needs to return to you the old state of the iterator, and also increment the current one.","width":462},{"text":"So it has to return by value, because it can't return to you a reference to itself, because itself has moved forward.","width":418},{"text":"So it needs to make a copy of itself, then increment itself and return the copy/","width":287},{"text":"We'll actually write this, but it's a subtle difference but it is an important difference.","width":279},{"text":"Okay and then I have comparison operators, these I've made member functions of the iterator class because it's easier to implement them that way. I need to be able to compare what the state of these iterators are, and if I don't have a public way of getting that state, which I shouldn't, it's easier to have these be members.","width":1017},{"text":"And then I have my dereference and member access operators.","width":201},{"text":"I haven't provided the non-const versions but I could do so as well.","width":261},{"text":"And then I have this private iteration state, which is a pointer to a node.","width":512},{"text":"So where would this class declaration appear?","width":259},{"text":"Where would I put this?","width":229},{"text":"In a header file, which header file?","width":288},{"text":"First of all, what is this iterator over?","width":154},{"text":"And how do you know that?","width":296},{"text":"Over a list, how did you know? Nodes. Right?","width":139},{"text":"It has node pointers in it.","width":173},{"text":"So this is an iterator that's for a list, so where will it go?","width":302},{"text":"In the list's header file. Where within the list's header file will this go?","width":414},{"text":"Public section.","width":192},{"text":"The iterator is a public type, outside people can refer to this. Okay?","width":517},{"text":"This will go in the public section of the list.h file.","width":1117},{"text":"Does that make sense, why it's in the public section?","width":202},{"text":"I eventually will want to write a function begin() and a function end() on my list that returns one of these, and if I'm returning it, it needs to be a type that somebody else can refer to.","width":563},{"text":"So it has to be, it's a nested type, kind of like the node is a nested type, except for it's not in the private section, it's in the public section.","width":423},{"text":"and that means that other people can refer to these iterators.","width":539},{"text":"You can't really meaningfully construct them themselves.","width":212},{"text":"Because to do so, one of them requires, excuse me, a node pointer, which means they can never, they don't have node pointers so they can never call that constructor.","width":497},{"text":"Our list class is going to be responsible for making these iterators, but the type itself is public.","width":385},{"text":"And that's important.","width":219},{"text":"Alright, good.","width":161},{"text":"So, let's write some code for doing increment of these iterators...","width":304},{"text":"And I want to point out 1 weird thing first, is that these functions look really bizarre.","width":405},{"text":"What looks bizarre about these functions? What surprises you about these function declarations?","width":320}]