[{"text":"Okay","width":128},{"text":"Soooo what about 72?","width":402},{"text":"So which nodes are visited if I ask you to remove 72?","width":195},{"text":"The 50 is visited, 72 is larger than 50, the 72 is visited 72=72. so i hit my base case here and I call remove node on the 72 and again what I mean by that is I am calling it on the right child pointer of the 50 so that I can change what that pointer points to so I am really calling this function on that pointer okay","width":2063},{"text":"So now this is neither a no child remove, nor a one child remove this has 2 children What do I have to do in the case that I have 2 children?","width":952},{"text":"Yeah","width":361},{"text":"Okay so I have to locate, so so I have to locate a node that could occupy the position of 72 and we saw 2 ways of doing that, the one that we are arbitrarily going to use here is going to be the in-order-predecessor and it is exactly what you said. ","width":997},{"text":"It's the rightmost child of the left subtree","width":320},{"text":"Okay so the rightmost child of the left subtree of 72 is what?","width":410},{"text":"67","width":63},{"text":"SO this is the iop for 72","width":360},{"text":"IOP is always for any node the rightmost node in the left subtree.","width":656},{"text":"SO what is the iop of of 17?","width":441},{"text":"14 is the rightmost node in the left subtree. So I go left to the 12 and I am gonna go right to the ","width":294},{"text":"14","width":60},{"text":"What's the iop of 50?","width":363},{"text":"23","width":65},{"text":"So the rightmost node in the left subtree","width":128},{"text":"SO I go to the rightmost node in the 17","width":215},{"text":"which is the 23 I cannot go any farther right than 23. Yes.","width":1225},{"text":"Umm the same story is true for the in order successor so you can arbitrarily pick either one.","width":654},{"text":"It will still be the same case as the predecessor, it can have at most one child.","width":458},{"text":"If it had two children then it wouldn't be the left most node in the right subtree.","width":360},{"text":"SO there would be another if there is a node to its left I would use that as a successor so it's the same story just mirrored","width":511},{"text":"Right so when I say the in order predecessor it is the right most node in the left subtree when I say in order successor it's the left most node in the right subtree. So it's just the mirror image. Instead of going left and then right I go right and then left. It's really hard to do cause it's backwards.","width":1921},{"text":"So you could sorta pick either one of these and the code is essentially exactly the same except you replace all instances of in order predecessor with in order successor and it it does the same thing.","width":683},{"text":"So I am just gonna arbitrarily pick the in order predecessor cause there is no real reason to cover it twice.","width":500},{"text":"So I locate the in order predecessor. Again I am removing the 72.","width":312},{"text":"I locate the in-order-predecessor then I swap with it. ","width":443},{"text":"So I am gonna swap these two nodes around so I am gonna get that the 67 and whatever value was also with 67 is gonna be moved into that node and the 72 and whatever value was in the 72 is gonna be put into that node.","width":1134},{"text":"And now I will remove the in-order-predecessor node itself.","width":469},{"text":"Which now it is the simpler case- it can't be a 2 child remove right. It can only be in this case it's a no child remove which is easy.","width":741},{"text":"Or it could be a 1 child remove which is also fairly easy. Why can't it be a 2 child remove?","width":494},{"text":"When I am removing the iop after I do this swapping of the key and the value, why can't it be a 2 child remove when I remove the iop?","width":672},{"text":"By contradiction it would no longer be the iop","width":350},{"text":"Suppose that removing the iop was a two child remove then there exists a right node of the iop, therefore the iop is not the iop contradiction.","width":882},{"text":"So it must be either a no-child remove or a one-child remove. There could be a left child of the iop. Cause all it says is that there are no more nodes to the right. So you could have a left child or you could have no children. But those are the only two cases","width":1312},{"text":"I could ummm it gets a little bit tricky so I am just gonna cheat and swap the key and the values.","width":670},{"text":"And in general that's less of a hack for us than it is for c++ 03 people because we have move semantics so swapping is very easy. If you don't have move semantics swapping","width":722},{"text":"entails making a copy of the value and the key which might be nasty but here we can just move them around so it's really not that bad.","width":490},{"text":"You can do it with pointer manips. It's just a little bit harder, you'll have to think there is a nasty edge case that you have to handle. I was doing this yesterday to verify to myself that I could still do it and there is one nasty edge case we would have to deal with.","width":916},{"text":"We are not gonna do it that way.","width":243},{"text":"So then I call remove node on the iop and when I say that what do I actually mean?","width":456},{"text":"I say I am gonna call remove node that contains the node 72 right now what do I really mean?","width":614},{"text":"I am calling remove node on the pointer to that node so on this thing.","width":630},{"text":"So when I go to find the iop ","width":329},{"text":"I want to get a reference to that pointer so my helper function that I am gonna right which will define the in-order-predecessor.","width":473},{"text":"It's gonna return to me a unique pointer reference to a node so that I actually have the handle that points at that iop so that I can remove it later ok.","width":640}]