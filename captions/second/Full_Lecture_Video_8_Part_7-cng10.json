[{"text":"Real quick. What's going on here? Why do I have virtual tilde animal = default?","width":448},{"text":"so, part 1. Why do I have virtual tilde animal?","width":256},{"text":"why do I have a virtual destructor?","width":192},{"text":"so right. So when I delete a pointer to an animal that does the appropriate thing by invoking the destructor of the actual type of the end of the pointer","width":768},{"text":"So this is gonna do a dynamic look up of the appropriate destructor to run, which will then bubble up and do all","width":384},{"text":"when I expect to be calling delete on a pointer to a base class","width":384},{"text":"and it's always good practice if you ever have a virtual function to have a virtual destructor","width":256},{"text":"second part, what is = default?","width":256},{"text":"","width":128},{"text":"","width":128},{"text":"it's not mean I'm lazy. It means please give me whatever the system would've given me as the implementation of this function","width":704},{"text":"I said I needed to  provide the decoration for this thing so I can declare this virtual, but I don't want to implement it. It's gonna do nothing. There's is nothing in here that I need to... there's no dynamic memory in animal that I care about","width":768},{"text":"so = default is just giving me the default of the implementation of the destructor so I don't have to write it in my cpp file. ","width":512},{"text":"could admit be equals default, but then you are forced to provide the implementation for the destructor in the cpp file","width":512},{"text":"which is gonna be open brace, end brace","width":128},{"text":"and then if it's a template class, it's gonna be even worse. template a,b,c,d...","width":576},{"text":"so the animal a,b,c,d, animal colon colon. tilde animal a,b,c,d (){}. So there's like a lot of ceremony to say don't do anything. This is just a quick way to say don't do anything.","width":960},{"text":"I have flagged the destructor being virtual, and then I have said the default implementation of  the destructor of what it used to be is fine","width":576},{"text":"","width":320},{"text":"OK. What about bird? So bird is a public animal. It provides the public function void fly(). It provides a public function void speak() const override. So what does the override mean?","width":896},{"text":"","width":128},{"text":"","width":256},{"text":"It says it's a signal to say that this speak() function is redefining what it means to speak() from the base class","width":704},{"text":"so I'm implementing a virtual function from my base class. I'm overriding a virtual function from my base class","width":448},{"text":"you do not have to provide the override key word for this to work. You don't need it. it's very good to put it. Because the compiler will then check that you are actually overloading a real virtual function. You are actually overriding your real virtual function","width":1088},{"text":"It I said override here and I forgot to make speak virtual, the compiler will not compile and says the override only works for virtual functions and that function is not a virtual function","width":704},{"text":"so it's always a good idea to have override there just to protect yourself from accidentally ","width":320},{"text":"like, oh, I am gonna change the behavior of this and then it wasn't actually virtual so you can't","width":256},{"text":"and the compiler will complain, but you don't actually need the override. It's the new feature in C++ 11","width":320},{"text":"","width":384},{"text":"","width":192},{"text":"So all the override saying is, compiler, please make sure that I'm actually overriding a virtual function here","width":448},{"text":"If I don't have the override, everything still works. So it does actually override the function appropriately. It is still a virtual function. The override is just a way of having the compiler make sure that your assumption is correct, that you are overriding a function","width":832},{"text":"","width":256},{"text":"practice, but it's not required.","width":128},{"text":"so given all that, is bird an abstract class?","width":768},{"text":"","width":128},{"text":"No? yes. it's. it is providing an implementation of speak(). now I have no pure virtual functions,right? all of my virtual functions now have an implementation, so bird is a concrete or not an abstract class","width":1152},{"text":"","width":320},{"text":"implemented that guy","width":128},{"text":"that was the only pure virtual function that I was inheriting, so now i'm not an abstract class anymore","width":384},{"text":"what about mammal?","width":256},{"text":"mammal is an animal, virtual double hair_thickness() const = 0","width":256},{"text":"abstract, right? for two reasons, right? this guy and then also it didn't provide speak(). It is inheriting speak() from animal, it still doesn't provide that, so it still an abstract for like couple different reasons. So this is an abstract","width":960},{"text":"what about this guy? bear is an mammal. I have provided hair_thickness()","width":320},{"text":"so I've got rid of that pure virtual function. So I'm not abstract now, right?","width":320},{"text":"yeah. It still got speak(). I'm still inheriting a pure virtual function all the way up from animal, because it was inherited by mammal. so bear is a public mammal. Mammal is a public animal, so bear has got that virtual void speak() const = 0 still. So this is still abstract","width":1600},{"text":"so the abstractness continues to carry on down to the inheritance higher key as long as you still have at least one pure virtual member function, whether that something you have declared right there or whether something you inherited. the same thing applies ","width":1024},{"text":"","width":320},{"text":"you can only override virtual functions.","width":384},{"text":"","width":320},{"text":"so you are saying if I were providing like a derived class, a virtual function with the same name? yeah, that doesn't... that will work only for your type and below, it won't apply if you've got a base pointer to your class and that function isn't virtual. It won't. ","width":1216},{"text":"it won't call your virtual method. but if your class is the rule of some other inheritance higher key. And if you've got a pointer to your class that... your class points to some derived  class, then it wouldn't work","width":768},{"text":"but it only applies from there down. So if you wanted to apply the whole higher key, it's gotta be all the way up to the base","width":448},{"text":"","width":128},{"text":"","width":128},{"text":"any questions of how you identify whether a class is abstract or not ?","width":320},{"text":"the rules is always, and will always be: if a class has at lease one pure virtual function, then it's abstract. And any other cases it's not","width":704},{"text":"","width":256},{"text":"so I've got class tier key. Here, I've got bird.","width":320},{"text":"it's got a weight. It knows how to fly. Note that this fly() function is not a pure virtual function. How do I know that? there's no equals 0. That means the bird class is providing an implementation for what it means to fly. So the bird class does provide a default implementation for fly()","width":1408},{"text":"Since I've got a virtual function, I ought to make my destructor marked as virtual but I don't have anything interesting to do there, so I've just = defaulted it ","width":576},{"text":"and then I've got a weight that is a private member variable. OK, fine","width":256},{"text":"a swallow is a bird. It's got a weight and a bool indicating whether it's carrying with the coconut","width":512},{"text":"it knows how to eat. it provided new implementation of fly()","width":256},{"text":"I know this because it's got an override here and I will tell you the code does compile","width":256},{"text":"so virtual double fly() override. So i'm overriding the fly() function from bird. So swallow has a different way of flying than the default bird","width":576},{"text":"and it also have got an airspeed, so I can calculate the airspeed velocity ","width":320},{"text":"but I don't know if it's African or European yet, so i'm making sure it's a pure virtual function cause I don't know the answer yet","width":576},{"text":"I only know the airspeed velocity of a lay in African or lay in European swallow ","width":576},{"text":"so then I have African swallow is a swallow. It is providing the implementation of airspeed, so is European swallow. Same case there","width":512}]