[{"text":"The only things this supports are find and merge. That's it.","width":768},{"text":"So this is in addition to doing the other thing.","width":128},{"text":"We still when we're doing a merge we still wanna make sure that we're increasing the depth of the fewest number of things for example for doing union by size.","width":481},{"text":"For doing union by height we can this doesn't mean that all the time we don't we have trees that don't have any height to them.","width":628},{"text":"Yes. So we have to fix the heights when find is updating stuff.","width":556},{"text":"So we have to be a little bit careful.","width":226},{"text":"It's easier to do path compression with union by size.","width":280},{"text":"That's sort of why we do it.","width":565},{"text":"If we're using the union by size, which is what we did the code before we're fine.","width":320},{"text":"Cause this the number of elements doesn't change.","width":490},{"text":"Okay. So what what is the this is a good question so what's what are we actually storing?","width":448},{"text":"like a vector or an array. So what will the destructor do?","width":576},{"text":"If we've got a vector as our as our private member variable the destructor for the vector will invoke a delete [] on whatever internal array the vectors got?","width":550},{"text":"If we're doing it the hard way and we have our own internal you know int * we would be responsible for calling delete [] on that int *.","width":768},{"text":"But despite the fact that this looks like a tree that's got nodes and pointers in it there are no nodes and there are no pointers.","width":422},{"text":"So this is an array like our heap.","width":120},{"text":"Like the destructor for the heap didn't have to do anything cause it was just a it was just a vector","width":312},{"text":"Same story here","width":231},{"text":"Good question","width":251},{"text":"Right okay so ","width":384},{"text":"quite a bit ago","width":244},{"text":"Hopcroft and Ullman two very sort of brillant computer scientists who I think Hopcroft is it or is it Hopcroft is it Ullman?","width":872},{"text":"I forget. I get the two mixed up. One of them has like written a text book for like basically every single area of computer science","width":348},{"text":"despite the fact that he that's not what he like that's not the area that he does research in?","width":371},{"text":"He's like he just knows enough about it to be better at writing text books than anybody else so it's sort of amazing?","width":343},{"text":"So these two brilliant men proved that any sequence of m greater than n find and m-1 merge operations on a disjoint sets data structure with path compression and union by size equivalently union by rank if you do it carefully takes big-O of m log* n time.","width":1563},{"text":"So what the heck?","width":169},{"text":"So first of all ignoring what log* is for a second what does that tell us about the amortized cost of our find operations?","width":995},{"text":"So we did m find operations and also some union operations and the whole thing took m log* n.","width":704},{"text":"So what would aggregated analysis tell us about the running time of a find operation?","width":448},{"text":"Log* n right? We did m find things. We also did some union stuff.","width":320},{"text":"Even if we include that stuff in our sum so it's not exactly completely accurate anymore?","width":278},{"text":"It's still gonna be log* n.","width":163},{"text":"Right cause we did m things and it's like m log* n time so we get log* n as the running time of our find.","width":704},{"text":"Why did I not ask about how long it takes to do a merge?","width":320},{"text":"How long does it take to do a merge?","width":256},{"text":"Constant time okay merge is just constant time. It doesn't matter if you're doing union by size or not. It's still constant time.","width":361},{"text":"So the merge stuff just doesn't matter at all.","width":176},{"text":"So if you're using this structure and you do m find operations and you're doing n-1 merge operations to make things you know like the merge operation is basically throwing in there to trying make things bad.","width":777},{"text":"Like path compression like if you just did a whole bunch of finds you know immediately it's just gonna converge on like the best tree.","width":354},{"text":"So they're throwing in some merge operations to make this kinda look bad as much as they possibly can.","width":384},{"text":"And it turns out as long as you're doing more finds than you are doing merges the overall cost of doing m finds after doing some inner leaves merges is gonna be m log* n which tells us that the amortized cost of doing a find operation is gonna be log* n.","width":1393},{"text":"What the heck is log*?","width":251},{"text":"Log* is also referred to as the iterated the iterated logarithm.","width":1083},{"text":"Okay and what this function does is it tells you the it it it it given any value returns to an integer.","width":512},{"text":"Okay so it's not a real valued function it's an integer valued function.","width":239},{"text":"And this function tells you the number of times you can apply the log function until your result","width":1856},{"text":"can't speak and write at the same time apparently","width":320},{"text":"is less than or equal to 1. Okay?","width":384},{"text":"So in other words this gives you the integer that tells you the number of times you can the number of times you can log your number and then log the result of that and then log the result of that before you get something that's smaller than 1.","width":923},{"text":"So you take log n you look at that value. If that value is ","width":287},{"text":"not smaller not smaller than 1 you add 1 to your counter and take log of that number.","width":307},{"text":"And you get that number back to that number is not smaller than 1 you add 1 to your counter and take log again.","width":384},{"text":"And you do it again and you do it again until you get something that's smaller than or equal to 1.","width":256},{"text":"Okay so it's a playing you know log log log log log log log of n.","width":256},{"text":"Okay tells you how many logs did you have to get before you hit 1 or less than 1.","width":512},{"text":"So I don't have any good intuition about that.","width":256},{"text":"So what's let's trying let's try and get a not get a handle on kinda what is this what does this mean in terms of growth.","width":448},{"text":"So just for a thought exercise I'm gonna give you an example value of the iterated log okay?","width":896},{"text":"It's estimated that the number of atoms in the universe","width":320}]