[{"text":"Then if we're not in that base case we know we can compare our key with the subroot and go left or right.","width":640},{"text":"So if our key is smaller than subroots key we go...","width":128},{"text":"We would do and insert to our left and again I'm moving just for efficiency.","width":1984},{"text":"And the other case we go to the right okay?","width":1600},{"text":"At this point that part of the function to start to feel automatic.","width":320},{"text":"Empty tree, insert the node.","width":256},{"text":"Key is smaller go left, key is greater go right.","width":256},{"text":"And the last thing we need to do is to keep track of two things now.","width":640},{"text":"One we've added this height variable to all of our nodes in this tree.","width":384},{"text":"So we better be sure that we're updating that height.","width":128},{"text":"And two we better be making sure that all of the subtrees are balance because we're arguing that this tree is always a balanced tree.","width":512},{"text":"So that we can argue about the height of it and say that our functions are nice.","width":320},{"text":"So we had better have a helper function that is responsible for two things.","width":256},{"text":"One its going to update the height properly.","width":256},{"text":"And two it's going to do any rebalancing that is necessary.","width":128},{"text":"And if after you rebalance it may have to adjust the height so it's always going to adjust the height and it may do a rebalance if necessary.","width":448},{"text":"So here I'm just going to call the rebalance function and that function is also going to do my height update.","width":448},{"text":"Last time I got confused as to what the responsibilities of the rebalance function were.","width":256},{"text":"So for this exercise I'm assuming that the rebalance function will always update the height and it may do a rotation if necessary.","width":512},{"text":"So all I need to do here is invoke the rebalance function, which is going to take care of all of the extra stuff that comes with the AVL trees.","width":448},{"text":"So I'm just going to invoke this function here.","width":320},{"text":"Okay you've either come back from recursing left or come back from recursing right, or you've just finished inserting a node, rebalance that subtree.","width":960},{"text":"And if the balance factor is fine then it's just not going to do anything and set the height.","width":384},{"text":"If the balance factor's screwed up it's going to do some sort of rotation and then update the heights and then return back out.","width":192},{"text":"So let's actually write this rebalance function.","width":1024},{"text":"And again we're going to operate under the assumption that we've decomposed this into lots of smaller sub problems.","width":256},{"text":"This is in general a good way of sort of organizing your thoughts when you're approaching a problem.","width":448},{"text":"If you don't know how to solve the larger problem break it in to smaller parts okay?","width":256},{"text":"I know how to insert into a binary search tree so I'm going to write that first.","width":320},{"text":"And then I'm just going to have some function that fixes the AVL stuff and I'm not quite sure how that's going to work yet but I'm going to have a function that does that.","width":320},{"text":"And in that function I know that it must update the height and it's gotta do a rebalance.","width":320},{"text":"Either to fix something on the left or to fix something on the right.","width":192},{"text":"I'm just going to write this high level function that is going to fix my heights and diagnose wether a rebalance has to occur because of heaviness in the left subtree or heaviness in the right subtree and I don't know how those are going to be written yet but I'll write them later.","width":832},{"text":"So that's where I'm at at this point.","width":256},{"text":"So I'm assuming that we've got a height function that takes a const node start and tells me the height of that node.","width":320},{"text":"Why do I need that helper function?","width":64},{"text":"Why am I not just accessing the height of the nodes?","width":128},{"text":"It's stored in the node right?","width":192},{"text":"Yea in the back.","width":64},{"text":"So I don't want it to return an exception, leaf nodes are fine.","width":704},{"text":"Leaf nodes will still have a height variable in them.","width":128},{"text":"Yes?","width":128},{"text":"So that's true only of the node that I'm at, everything below me is fine because I've already recursed and done this on the way back out.","width":960},{"text":"So everything below me if fine.","width":64},{"text":"My height might be screwy but everything below me is fine.","width":256},{"text":"It could be null right?","width":320},{"text":"So I'm storing the height in nodes right? Which is fine as long as those nodes exist.","width":192},{"text":"And we know if we have no node the height should be -1.","width":320},{"text":"If I have no node there's nowhere to put that -1.","width":128},{"text":"I'm not going to put a whole bunch of dummy nodes at the bottom of the tree to hold -1 because that just gets confusing.","width":512},{"text":"So I'm just going to have this height function which is super simple.","width":256},{"text":"If it's null, -1, otherwise subroot height.","width":192},{"text":"So all it is is just a null check for which return -1 otherwise return height.","width":384},{"text":"And that's just helpful so that I don't have to think about null cases when I'm asking for heights.","width":320},{"text":"Otherwise I'd have to \"If subroot is null, set this to -1, and if subroot right is null set that to -1 and then take the max\".","width":448},{"text":"Here I can just call the height function and then not worry about it.","width":192},{"text":"And the implementation is like so trivial that I know all of you could write it.","width":256},{"text":"So the real reason I have that is because I want to be able to ask for the height of empty trees and have that be well defined.","width":384},{"text":"If I'm dereferencing null points that's no okay.","width":256},{"text":"So that's why this function exists.","width":128},{"text":"Okay and then I'm assuming we've got these two helper functions, which again are these two magic functions that we're just going to assume that I have and then write later.","width":448},{"text":"Which is rebalance left, which fixes it when it's heavy on the left.","width":512},{"text":"A rebalance left will fix things when you've got too many nodes on the left side, and rebalance right will fix everything when you've got too many nodes on the right side.","width":448},{"text":"So all this is is just to check which side is heavy and then to invoke this rebalance function.","width":256},{"text":"In other words I'm using this to diagnose whether I'm going to do, in the case where it's heavy on the left, I have to a right rotation.","width":896},{"text":"And the case where it's heavy on the right I have to do a left rotation.","width":192},{"text":"So basically that's what this is doing.","width":192},{"text":"It's diagnosing which of those major rotations you have to do and then inside these rebalance functions we'll have to decide wether it's a single rotation or a double rotation.","width":448},{"text":"We're going to put that thought off for now, we're just going to think \"is it a left rotate or a right rotate?\".","width":320},{"text":"Or in other words is it heavy on the left or is it heavy on the right?","width":320},{"text":"So auto-balance it's probably my balance factor how do I compute that?","width":320},{"text":"I heard height, height of what?","width":384},{"text":"Height of subroot left dot get, okay so that'll give me the height of subroots' left.","width":896},{"text":"Minus height something similar but with the right.","width":576},{"text":"And that's going to give me the sign to balance factor right?","width":640},{"text":"So this thing could be negative, it could be positive I don't know it's just an integer.","width":256}]