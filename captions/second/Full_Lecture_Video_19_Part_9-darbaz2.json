[{"text":"or we have two children.","width":256},{"text":"those are all the edge cases","width":576},{"text":"if it's a one child removal,","width":192},{"text":"that's as simple as just setting the pointer to null because there is no subtrees below that, you don't have to care about anything else, the structure of the tree has not really changed by removing that node","width":576},{"text":"so one child remove is fine","width":128},{"text":"no child remove, fine","width":256},{"text":"there is only one","width":128},{"text":"if there is only one child, you just pick the one that's not null and you make that be the new root and you get rid of the current node","width":512},{"text":"so that's not too bad","width":64},{"text":"a little more complicated but not too bad, there's only one possible subtree that could be the new root","width":384},{"text":"when we've got 2 children, things get a little bit more interesting","width":384},{"text":"if I actually want to remove","width":64},{"text":"the 50","width":256},{"text":"in this tree and I'm using the in order predecessor","width":345},{"text":"I need to, okay, swap the 23","width":320},{"text":"with the 50 and again I'm probably doing this with node ptr manipulation rather than moving data","width":512},{"text":"and now I need to remove the 50","width":192},{"text":"well, removing the 50 is again another removal case","width":448},{"text":"which in this case is a one child removal","width":256},{"text":"doing the two child remove is actually going to have sort of two removal steps","width":576},{"text":"the first thing is swap it with the in order predecessor and then you call your remove function on the in order predecessor itself","width":640},{"text":"so there's two steps","width":128},{"text":"1 - get the in order predecessor","width":64},{"text":"2- swap with it","width":128},{"text":"3 - delete the node where the in order predecessor was","width":320},{"text":"and removing that position could also be a more complicated removal","width":576},{"text":"so, let's think about this carefully for a second","width":320},{"text":"which cases could apply for when we're removing the node here?","width":448},{"text":"so after we've swapped with the in order predecessor and we want to remove that location in the tree","width":384},{"text":"which removal cases could apply for that removal?","width":256},{"text":"it could be no child, if this doesn't have a child there, we know it's a no child remove","width":640},{"text":"we know it could be a 1 child remove because there it is","width":204},{"text":"why can't it be a 2 child?","width":128},{"text":"right, by definition if it was a two child remove, you did not find the in order predecessor","width":448},{"text":"if I add another child to this thing, 25","width":345},{"text":"the in order predecessor of the 50 is not the 23 anymore, it's the 25","width":384},{"text":"because it's the rightmost node in the left subtree","width":320},{"text":"the in order predecessor of what used to be","width":320},{"text":"if the tree looks like this, the in order predecessor of the 50 had ought to be the 25, not the 23","width":572},{"text":"so only this case or this case could be called from the 2 child remove case","width":576},{"text":"so it's not like a 2 child remove could cause a 2 child remove could cause a 2 child remove and you have to worry about an infinite recursive case","width":704},{"text":"a node child remove, just does so that null pointer's set.","width":192},{"text":"a one child remove is just going to move the root pointer up and the two child remove,","width":592},{"text":"is going to locate the iop, swap with it and then call remove node on the iop's position.","width":384},{"text":"which is going to itself be either a no child or one child remove","width":320},{"text":"does that make sense?","width":192},{"text":"we'll write these, yes","width":448},{"text":"all of them","width":1116},{"text":"so, okay, so you're saying we want to remove the 23?","width":583},{"text":"so what we need to do is, remember when I'm saying when we're removing the 23 what we're really being called on is this pointer here","width":614},{"text":"so we've got subroot which is the right pointer of the 17 which points at the 23","width":367},{"text":"so we have access to the 23's left child","width":226},{"text":"so we can say something like subroot is","width":192},{"text":"so I could say here,","width":192},{"text":"subroot is std::move of subroot left","width":1005},{"text":"okay this pointer should take ownership of this so it's going to go down here, this is going to be null, now there's no pointer pointing at 23 so the 23 had better be going out of scope","width":896},{"text":"before this, if I'm right here before I do this, subroot points at 23","width":642},{"text":"then I assign subroot to look at subroot's left","width":256},{"text":"so now no pointers point at the 23","width":192},{"text":"so 23 is deleted","width":128},{"text":"when I do the assignment, right if you have a unique ptr and you assign another pointer into it, the first thing it's got to do is to get rid of the thing it was pointing at first and then do the assignment","width":926},{"text":"so it grabs the pointer that you care about, then it calls delete on it's own pointer","width":384},{"text":"so let's write the remove node helper function now, so remember","width":1064},{"text":"our remove function just walks the tree, finds the key that we want to remove and then calls this remove node function on that pointer","width":576},{"text":"so if you're removing the 23 like the other case, it calls this directly on subroot which is the right pointer of the 17","width":577},{"text":"so this is being called on the unique pointer that points to the node that we want to get rid of.","width":256},{"text":"and so now, we have to diagnose which of these cases there are, it is","width":263},{"text":"so I'm going to write, for sanity's sake, all of the cases as a seperate helper function","width":395},{"text":"so I'm going to have a no child remove, which removes a node with no children.","width":192},{"text":"and we're going to have a one child remove that removes a node with one child","width":294},{"text":"and a two child remove that removes a node with two children, so the most complicated one is certainly going to be this guy","width":448},{"text":"because that has to locate the iop and then swap and then call remove again, so","width":320},{"text":"we're going to focus on these two for now","width":128},{"text":"so if I'm asked to remove a node ","width":384},{"text":"how do I check which one of these to call? So there's three helper functions and there's three if statements/cases. what's the first case? when am I going to call a no child remove?","width":768}]