[{"text":"We have finished a worksheet. My God! It's about damn time. Well not if I keep talking. Okay! So lets actually write the code for this. ","width":640},{"text":"So we are dealing with a structure that is like that binary tree KV that we talked about earlier. So we know that the node struct has got a  k key of v value, a unique pointer left and a unique pointer right.","width":896},{"text":"Okay! so thats the structure we are dealing with.So now we want to codify that algorithm that we just talked about which is sort of bringing out which subtree to  go down and stopping there.","width":576},{"text":"Okay!The first case we have got here is sort of a unhappy base case. There are sort of two base cases for this algorithm.","width":448},{"text":"The unhappy base case is locate me this key in an empty tree. Right? If its not subroot we know that that tree is empty in which case it can't exist.","width":640},{"text":"Right? So we can't return a value.So we'll throw an exception. So lets throw a std::out of rangeÂ ","width":320},{"text":"or something","width":256},{"text":"And say something like we don't know what the key is or whatever.","width":1280},{"text":"Cause there is nothing we can do if we have an empty tree and we haven't found it yet it can't exist so there is no v that we can possibly return. So its not even possible to return something out of this.","width":576},{"text":"If I try to return a temporary v I am returning a reference to a local variable so I can't. There is nothing I can do.","width":448},{"text":"Alright so I have to kind of say Woh sorry!","width":384},{"text":"Okay1 so the other base case, the happy base case, we found it.","width":320},{"text":"Key is equal.. is double equal to subroot key that is 9 equals 9. So we found it. S what do we return then?","width":512},{"text":"Return the value subroot.","width":576},{"text":"Okay!Then we have got our 2 recursive cases which are gonna tell me which side of the tree you go down.","width":512},{"text":"So if key, key is the thing I am looking for. It's important to keep that straight. So key is the thing I am looking for.","width":448},{"text":"And the thing I am looking for is smaller than the subroot's key. Which subroot do I go down. The left.","width":512},{"text":"And if the key I am looking for is smaller than the current root then I need to go left. ","width":256},{"text":"So I am gonna recurse here so. And I still want to return the value of that recursion so all these cases are gonna have returns in them.","width":576},{"text":"Okay! so i am gonna return the value of my recursive function which is called find. I gotta pass down the key. But now i am gonna look in subroots.","width":1024},{"text":"Left","width":256},{"text":"and passing raw pointers so I need to do a dot get.","width":192},{"text":"Okay! Failing all of these cases mens what?","width":448},{"text":"I need to go right. Right? its either it must be greater. The key I am looking for must be greater than the current one.","width":512},{"text":"So I need to go right. So this is the same thing.","width":512},{"text":"And we are done.","width":1024}]