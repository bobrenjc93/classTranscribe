[{"text":"Using an adjacency matrix has trade offs in terms of the running times of the functions that we're gonna call. So we're calling functions on the graph, we need to look and say, okay, what's the running time of that function if I chose to implement the graph with an adjacency matrix, and then use that the inside of our analysis.","width":1472},{"text":"This part is just setting stuff up--setting the queue up, putting on a vertex, and labeling one vertex. That happens just once, and all of that is gonna be constant time--we already have the vertex labeled, we're just gonna set its label, put it onto a queue. We know how to push onto a queue in constant time.","width":1408},{"text":"That whole part is constant time. ","width":128},{"text":"The real work is happening inside of this while loop.","width":576},{"text":"For question 1, how many times does the while loop iterate?","width":640},{"text":"How many times am I gonna call that? Once for every vertex. How do you know that?","width":448},{"text":"I only push on the vertex when I've never seen it before. I never put it on again.","width":832},{"text":"Every vertex is gonna be pushed onto the queue once, and popped off the queue once.","width":448},{"text":"In terms of the peek to call that front once, all three of those queue operations are constant time. We know how to do that with a queue, that's easy. ","width":704},{"text":"So in terms of the in the loop for every vertex the amount of work I'm doing for the queue itself is constant time.","width":704},{"text":"Every vertex is added to the queue once, peeked off the queue once, and popped off the queue once. ","width":384},{"text":"In terms of the queue operations, per vertex, we're fine.","width":448},{"text":"It's just constant time per vertex so that tells us the running time can't be better than O(n) now, because I'm doing something for every vertex and that something I'm doing so far, in terms of the queue, is constant time.","width":1024},{"text":"So then inside this loop I also have another loop, I'm looping over the adjacent vertices of a particular vertex, that was the front of the queue.","width":832},{"text":"For every vertex I'm going to call this function g.adjacent(u) for every vertex u in the graph.","width":512},{"text":"How long does that function call take for an adjacency matrix implementation?","width":640},{"text":"O(n). So an adjacency matrix for this thing gives me O(n). u is just a number that tells me a row or column so I go to that row or column and scan over and see which vertex id's have 1s in there, and return to you the vertices that did have 1s.","width":1216},{"text":"And that takes time O(n).","width":384},{"text":"I'm inside this loop, for every vertex I remove it from the queue, I do a peek for that vertex, and then I had to have added it somewhere. ","width":768},{"text":"Furthermore, for every single vertex I for its adjacent vertices. ","width":512},{"text":"I'm asking every single vertex for its adjacent set, inside the loop that goes over every vertex.","width":512},{"text":"The function running time of getting the adjacent vertices of one vertex is O(n), if I'm doing that O(n) times, that gives me what? O(n^2).","width":768},{"text":"I have O(n^2), and then, what about the rest of this stuff? So getting the label, checking if it's explored or not, marking a vertex, marking an edge, checking an edge, marking an edge, we haven't talked about those yet. We've just talked about the queue operations, and getting the adjacent vertices.","width":1664},{"text":"How long does the rest of this stuff take?","width":320},{"text":"Constant time. Looking up the label is just--if I have the vertex, it's just, what's the label of this vertex? It's probably in the vertex itself.","width":704},{"text":"That's easy. ","width":192},{"text":"Checking the edge label is probably constant time I get the edge and look at it. I'm already at the vertex so the adjacency vertices should have easy access to the edges of that.","width":1088},{"text":"That's fine. Setting and getting the edge labels and states is fine.","width":320},{"text":"There's this interesting question--the rest of this is basically constant time. The interesting question is how many times am I seeing stuff?  ","width":832},{"text":"Every vertex I mark it once, but that's not the only time I see it.","width":576},{"text":"See it again for every incoming edge.","width":256},{"text":"I don't do anything when I see it the second time,I'm just looking at it.","width":704},{"text":"The bulk of the work that I do for the vertex is gonna be when it comes off of the queue. When I'm just looking around the adjacent vertices, everything I'm doing there is constant time.","width":896},{"text":"In other words, if you think about a vertex, and I'm at this vertex, I'm doing a constant time amount of work for every outgoing edge.","width":704},{"text":"For a particular vertex. And I do that again when I look at another vertex. I might have repeated edges here, but I'm still doing a constant amount of work for every outgoing edge.","width":832},{"text":"If I'm doing a constant amount of work for every outgoing edge of every vertex, what does that sound like to you?","width":576}]