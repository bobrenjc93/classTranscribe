[{"text":"Uh yeah, its already owned by something. So what should I do instead?","width":256},{"text":"Yeah, call the clear function or set it equal to nullptr on the next ptr of tail","width":704},{"text":"So explicitly tell the thing that is owning curr to not own it anymore","width":256},{"text":"Cuz rawpointers are not owning ptrs so there are no more owning ptrs so its freed","width":640},{"text":"That one looked a littel bit nasty, how long did that take?","width":192},{"text":"Order n. If this is a really long list it's gonna take you very long time to get to the thing before the tail","width":448},{"text":"So that you can move the tail to the correct node","width":320},{"text":"This is different from the case when we're removing from the front because it was very easy","width":320},{"text":"","width":64},{"text":"We could get to teh thing that followed head by looking at head, and looking at head's next","width":384},{"text":"It's very easy to move head forward, it's very hard to move tail backwards cuz we dont have a way to go backwards in a singly linked list","width":320},{"text":"What about the doubly linked list?","width":256},{"text":"Is it very different form the the singly linked list? I could do the same thing that I did in the singly liniked list?","width":384},{"text":"Can I do better? Yes, how?","width":64},{"text":"I can look at tail, tail has a prev pointer. Tail points me directly at the thing that comes before it, and htats the node that I want to get to.","width":896},{"text":"So its very easy to set up my temporary to this thing","width":128},{"text":"Cuz I can just say, tail->prev","width":320},{"text":"auto curr is tail->prev","width":192},{"text":"Now I got my pointer to there, and can do the same thing that I did before","width":256},{"text":"Where I need to move tail to point at the same thing curr does, and blank out this pointer","width":448},{"text":"I dont even hafta worry about the prev ptr, the node that used to be the tail, now that there's no owning to the tail its going away","width":704},{"text":"So I didnt really need to set it to null before that, its going away who cares","width":448},{"text":"Ok?","width":256},{"text":"So how long did that take then?","width":192},{"text":"Constant!","width":128},{"text":"Ok so that was very different. What did you have to pay to get that behavior? It's magically this funciton is constant verseus linear, so what is the cost? I had to sacrifice something, nothings free","width":960},{"text":"Memory","width":64},{"text":"How much  memory did I sacrifice?","width":192},{"text":"In big-O notation, how much more memory did the linked list require? O(n)","width":640},{"text":"So I sacrifice linear memory so that I could get consztant removal from the back","width":384},{"text":"Does that make sense? Cuz its a constant amount of memory at each node, but there's n nodes in the list so I spend an additional order n amount of memory so that I can get this operation to be constant","width":1088},{"text":"So, like eveyrthing there's a tradeoff here. If you have a list and you want to remove from the back very quickly and you need to be using a linked structure, you probably want to use a doub ly linked list. If you can afford it, in terms of the memory cost","width":1024},{"text":"Cuz its got another Order n expense tacked onto it","width":320},{"text":"Cuz you got all these extra pointers","width":256},{"text":"What about hte vector? If i wanna remove the stuff ont he end of that vector what do i do?","width":640},{"text":"Take it out, or if I''m maintaining what's the last index, I jsut move it ","width":448},{"text":"I dont' even have to actually reset the value, I could jsut say the current valid range ends at size_t something","width":576},{"text":"and just remember how many things are currently there. I could jsut decrement a counter that says how many things are in the vector","width":512},{"text":"Or I could just blank it out if you know what it means to blank it out","width":256},{"text":"How long does that take?","width":320},{"text":"constant time","width":128},{"text":"It's either decrement a counter or assign something to blnak and move counter, so this is gonna be cosnntat","width":448},{"text":"Up here, we're gonna have O(n), O(1), O(1)","width":448},{"text":"Ok, I don't have scratch paper for this one. But you should be able to reason about it without it","width":896},{"text":"I want to get an iterator to a given position i in the list","width":256},{"text":"What is an iterator? What do I mean when I say get me an iterator at the position?","width":576},{"text":"The thing that conceptually points at that thing in the list","width":384},{"text":"Something that refers to that element to that list","width":128},{"text":"This is effectively saying give me the element at position x at the list","width":512},{"text":"I'm saying, iterator, because it may be nice to have the ability to go back one or forward one but conceptually its the same thing as getting me the ith element in the list","width":640},{"text":"How long is that goinna take me for a singly ulinked list? ","width":448},{"text":"O( whatever the position is)","width":192},{"text":"The worst case would be one before the tail or soemthing","width":384},{"text":"And then you're gonna hafta walk the wholle darn list to get to the thing before the tail","width":384},{"text":"So the worst case is for singly linked list is gonna be linear","width":384},{"text":"Because I could be n - 1","width":256},{"text":"But its O(i), because it depends on the postiion of where teh i is, that's techincally correct too","width":896},{"text":"But the worst case is O(n)","width":128},{"text":"But what about a doubly linked list?","width":384},{"text":"Does anyting change by having previous pointers?","width":128},{"text":"Not really","width":128},{"text":"Myabe if I had some way of knwoing if I was closer to tail, I could go from the tail over instead of teh head over, but the worst case then would be the middle of the list","width":832},{"text":"And HOw many jumps is it gonna take regardless of where you're gonna start? n/2, which is still O(n)","width":448}]