[{"text":"is you know somewhere between 4 times 10^79 and 4 times 10^81.","width":832},{"text":"Let's be pessimistic and take the largest estimate for the number of atoms in the known universe.","width":361},{"text":"Right? Estimated number of atoms in the known universe.","width":164},{"text":"So you know let's say that's okay that's like 4 times 10^81.","width":640},{"text":"Really big number.","width":128},{"text":"Certainly larger you're not gonna be running a particle simulation with every every estimated atom in the known universe.","width":406},{"text":"But if you did but if you did. If that was your n and you have some magical computer that can actually store that amount of stuff","width":599},{"text":"let's think about what the log what the iterated log would give us.","width":171},{"text":"It turns out that log* (4*10^81) is 4.","width":798},{"text":"It's 4.","width":223},{"text":"So if our running times for our disjoint set's find operation are amortized to out to be log* n?","width":704},{"text":"and if n is the number of atoms in the universe, the value is 4?","width":326},{"text":"What does that tell us in practice about the running time of these operations?","width":286},{"text":"They're constant for practically any amount of data that you'd ever ever reasonably throw at them.","width":320},{"text":"Right? Your analysis can thus say oh log* n well that's smaller than 4.","width":448},{"text":"Because your n is not gonna be the number of atoms in the known universe, right?","width":512},{"text":"So in practice disjoint set's find is gonna be constant time because log* n for any reasonable n is something so pitifully small that it just doesn't matter.","width":2210},{"text":"It actually gets even better.","width":182},{"text":"So a later proof by Tarjan and van Leeuwen in 1984 showed that that for any smart-unioning strategy and path compression","width":592},{"text":"that there's a bound  big-O of m inverse Ackermann of n.","width":334},{"text":"where the inverse Ackermann of n function is significantly smaller than the iterated log.","width":553},{"text":"Okay? So the actually running time has been shown to be significantly smaller than even the iterated log, which is 4 for the number of known atoms in the universe.","width":868},{"text":"Estimate. Right? So it's basically constant time.","width":268},{"text":"If you have literally anything else that you're doing that is gonna dominate the running time of this and so it's just gonna fall out of any analysis that you're doing.","width":545},{"text":"If you had something that took log n time, log n is gonna be way bigger than inverse Ackermann of n.","width":342},{"text":"","width":23},{"text":"So inverse Ackermann just gone.","width":192},{"text":"Inverse Ackermann is basically the smallest running time function that you'll pretty much every see in alogrithmic analysis like you","width":512},{"text":"other than constant time, you can't beat it.","width":320},{"text":"So these things are really fast.","width":1472},{"text":"Okay fine I'll do that real quick.","width":448},{"text":"Which one?","width":896},{"text":"Okay well I tossed this in the Wolfram Alpha before lecture and told me 4.","width":640},{"text":"It's just how many times can you take log of your result again and again and again before it hits","width":448},{"text":"In any case it's small.","width":220},{"text":"I don't want you to memorize what the log* of 4 bazillion is. I want you to know that it's something tiny.","width":442},{"text":"I believe the answer is 4.","width":236},{"text":"But it really doesn't matter. It's something significantly smaller than any other operation that you're doing.","width":896},{"text":"So let's just quickly do some operations on this, get a feel for what this looks like when we're doing both a smart-unioning strategy and","width":675},{"text":"path compression? So I said pick 1, let's not pick 1, let's use size.","width":485},{"text":"So union by size just to make our lives easier.","width":222},{"text":"So we're gonna start off with the disjoint set structure with 6 things in it.","width":933},{"text":"So if find(0) and find(1) do not return to me the same element the currently do not I'm gonna merge 0 and 1.","width":740},{"text":"So we have to pick our tie breaking case somehow for I guess what I did was that pick the right thing to be the root.","width":496},{"text":"I think the mp probably has to pick the left thing to be the root, so I'm just gonna pick the left thing arbitrarily.","width":256},{"text":"Just how I tie break. So I'm just gonna say okay 1 is gonna point at 0.","width":320},{"text":"After this.","width":128},{"text":"Okay so we're gonna do this. If find(3) and find(4) different, they are, so merge 3 and 4 so 4 should point at the 3 now.","width":768},{"text":"If find(0) gives me 0 find of gives me 2 are not the same","width":474},{"text":"then merge 0 in 2 so I wanna say","width":454},{"text":"which one should be the root?","width":192},{"text":"0 right? 0 has more things in it than 2 so 2 should become the child of the 0.","width":616},{"text":"Now we're here. Find(2) gives me 0 find(1) gives me 0 so I don't do a merge here because they're the same.","width":768},{"text":"Find(1) gives me 0 find of (5) gives me 5 so those are different.","width":320},{"text":"So you're gonna merge these 2 things together.","width":192},{"text":"So find(1) is 0 find(5) is 5.","width":477},{"text":"Which one of those should I make the new root?","width":214},{"text":"0. 0's got more things in it, so 5 is gonna be the root.","width":364},{"text":"Or sorry, is gonna be the child of 0.","width":170},{"text":"Okay? find(3) gives me 3. find(5) gives me 0 so I'm gonna merge those 2 sets together?","width":537},{"text":"So which 2 roots am I merging then?","width":256}]