[{"text":"So, i have thrown pthread_exit at you, pthread_join, pthread_cancel, etc","width":575.1818182468414},{"text":"This is an exposure to the words in the vernacular, this stuff is not going to sink until you play with it","width":342.18181824684143},{"text":"So, i encode to play a lot with these things and to write little programs and see what happens","width":732.1818182468414},{"text":"Okay, if we don't call pthread_join on a thread, we get a resource leak","width":488.18181824684143},{"text":"And eventually","width":162.18181824684143},{"text":"We wouldn't be able to make anymore threads","width":311.18181824684143},{"text":"We can't reuse the same memory address from the original stack","width":210.18181824684143},{"text":"We are still hanging on to the exit value so we are using up more memory","width":831.1818182468414},{"text":"Okay so the next thing","width":403.18181824684143},{"text":"Take a look at this kind of typical kind of code here","width":445.18181824684143},{"text":"And the...this..something wrong with it","width":289.18181824684143},{"text":"What question is: What?","width":98.18181824684143},{"text":"And how could we fix it? How could we make it valid?","width":228.18181824684143},{"text":"Now your first instinct might be .. HOLD ON IT TAKES A VOID STAR POINTER","width":220.18181824684143},{"text":"That's okay","width":82.18181824684143},{"text":"All i'm doing is passing in a pointer","width":224.18181824684143},{"text":"To start","width":116.18181824684143},{"text":"So that..","width":126.18181824684143},{"text":"My new thread can read a value","width":165.18181824684143},{"text":"Presumably, this 42","width":293.18181824684143},{"text":"So, what do you think might be wrong with that?","width":195.18181824684143},{"text":"Just take a moment to talk it over with your neighbors or neighbor and see how we might fix it","width":507.18181824684143},{"text":"I'll walk around in case you got any questions - [silence]","width":6393.181818246841},{"text":"What did your neighbor say?","width":105.18181824684143},{"text":"What did YOUR neighbor say?","width":100.18181824684143},{"text":"*whisper from student*  - It was out of scope","width":95.18181824684143},{"text":"Ok we got a scope problem","width":177.18181824684143},{"text":"Yeah, so, first of all there is no security","width":290.18181824684143},{"text":"It's okay for one thread to access another thread's stack, it's not like we're going to get a segmentation fault","width":545.1818182468414},{"text":"The hardware doesn't know or doesn't care two threads are stomping over each other's stacks","width":558.1818182468414},{"text":"But we do have a scoping problem","width":183.18181824684143},{"text":"And it's this: we're passing in the address of start","width":327.18181824684143},{"text":"And start, as we know, lives on the stack","width":187.18181824684143},{"text":"How long is that address going to be valid for?","width":280.18181824684143},{"text":"Answer: Not very long, we're about to return from this function","width":353.18181824684143},{"text":"So, when will my funct start?","width":344.18181824684143},{"text":"Answer: I don't know, it's up to the kernel to eventually decide get around this other thread","width":523.1818182468414},{"text":"Maybe we'll put this first thread on pause beforehand and give pro to the new thread","width":283.18181824684143},{"text":"Or maybe this new thread will start much later on .. 100 milliseconds time","width":443.18181824684143},{"text":"By which point, what will be at this particular address?","width":249.18181824684143},{"text":"Could be anything right?","width":81.18181824684143},{"text":"It could be our original value, it could be being reused by a completely different function at this point","width":409.18181824684143},{"text":"So our problem is with time","width":115.18181824684143},{"text":"Our problem is that we gave the address something and that variable is no longer in scope","width":457.18181824684143},{"text":"Alright, how can we fix this?","width":130.18181824684143},{"text":"Well","width":66.18181824684143},{"text":"One trick is to say: I'm going to put this magic word static in here","width":375.18181824684143},{"text":"And if I do that, it's no longer an automatic variable","width":153.18181824684143},{"text":"It lives just once as a global variable inside my whole process","width":498.18181824684143},{"text":"But that is pretty heavy handed","width":406.18181824684143},{"text":"Alright, now I only use this start variable and I better keep its value until i'm sure another thread is run","width":809.1818182468414},{"text":"How else can we fix it? We could use malloc()","width":357.18181824684143},{"text":"And allocate some memory in the heap","width":307.18181824684143},{"text":"We would have run into the same problem if we immediately called free","width":387.18181824684143},{"text":"In this thread","width":135.18181824684143},{"text":"Because we would have created some heap memory","width":216.18181824684143},{"text":"Passed a pointer to it and immediately freed it. OH NO WHOOPS","width":223.18181824684143},{"text":"I didn't give my new thread any time to actually read that memory","width":357.18181824684143},{"text":"So if you do use malloc() ","width":213.18181824684143},{"text":"Don't immediately free it, instead..","width":228.18181824684143},{"text":"Let this function","width":169.18181824684143},{"text":"Free it after it runs","width":239.18181824684143},{"text":"One thread can create heap memory and another thread can actually free it","width":213.18181824684143},{"text":"That's perfectly fine, they all live inside the same process","width":293.18181824684143},{"text":"And there's one heap","width":357.18181824684143},{"text":"I think another way this might be valid is before we turning","width":335.18181824684143},{"text":"We could call pthread_join","width":299.18181824684143},{"text":"On the thread","width":194.18181824684143},{"text":"If we did that, we know that the new thread that is going to run my funct will actually finish before this function returns","width":684.1818182468414},{"text":"So we've solved our timing problem","width":128.18181824684143},{"text":"We've made sure that we don't finish that this variable doesn't go out of scope","width":326.18181824684143},{"text":"Until the other thread has finished","width":216.18181824684143},{"text":"We have just encapsulated from a time point of view","width":221.18181824684143},{"text":"The running time of this other function and made sure that the running is within the scope of this start thread's function","width":516.1818182468414}]