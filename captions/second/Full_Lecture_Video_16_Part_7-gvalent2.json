[{"text":"Which it should be, it's just printing.","width":256},{"text":"What are the things that causes to do work?","width":192},{"text":"Well, theres a peak, theres a pop, and there's two pushes.","width":256},{"text":"All of those are order 1 if we pick a good queue implementation.","width":320},{"text":"So then we're fine to say that this is order N.","width":256},{"text":"What about those other recursive traversals? What's their running time?","width":384},{"text":"How do we analyze that?","width":448},{"text":"How many times is that recursive function called when we're doing that traverse?","width":512},{"text":"Is is any different from the number of things that end up on our queue here?","width":320},{"text":"No.","width":128},{"text":"We for sure call it once in every node in the tree, and then we call it call it again for all those nullptrs.","width":448},{"text":"But we know the number of nullptrs is N+1 so the total number of the recursive function is call is O(N).","width":448},{"text":"So then we better be sure that the work we do inside the recursive call itself is constant time.","width":384},{"text":"We check for a nullptr and we run our function, both of which are constant time.","width":256},{"text":"So our traversal functions, the recursive versions, are also linear time. ","width":320},{"text":"Is it possible for there to be a traversal on a tree that's faster than O(N)?","width":384},{"text":"Why not?","width":320},{"text":"I have to hit every node.","width":128},{"text":"If there N nodes in the tree and I had a traversal that was faster than O(N), you didn't print out the tree.","width":384},{"text":"You did like half the work.","width":128},{"text":"Maybe you only went left or something.","width":128},{"text":"And even then, it wouldn't work.","width":192},{"text":"So, you have to at least take linear time.","width":384},{"text":"So these traversal functions are as fast as we could possibly make them.","width":256},{"text":"So we could even say that they're theta.","width":128},{"text":"You cannot make them any faster.","width":320},{"text":"There's certainly no worse than N, so it's bounded above and below by N, so it's N.","width":384},{"text":"For any traversal.","width":128},{"text":"Alright, switch gears. Let's talk about a new data structure.","width":576},{"text":"Here's a tree, it a friendly, happy binary tree, except we're not going to use a node struct now.","width":768},{"text":"I'm not even going to allow you to linked memory, I'm not going to allow you to use a node struct.","width":320},{"text":"We're going to store this thing in a different way.","width":192},{"text":"How could I store this?","width":256},{"text":"If I tell you that I'm not using a node struct and we're not using linked memory, what's the only option?","width":320},{"text":"It's like a vector or an array.","width":192},{"text":"So I'm going to have an array to store this tree.","width":192},{"text":"So I'm going to use an array and I'm going to have a slot for every element in this tree.","width":1536},{"text":"The array is going to be an array of T, where T is whatever happens to be in this tree, so it's going to be an int star in this case.","width":576},{"text":"Now, the question is, how am I going to put the tree into that array?","width":640},{"text":"I have to put it in there in some way that I can reverse engineer what the pointer like structure would be.","width":960},{"text":"Remember, for every node, I need a way of getting to its left and to its right.","width":320},{"text":"If I wanted to print out this tree with a pre-order or a post-order or an in-order traversal, I need some way of getting the left and some way of getting the right.","width":512},{"text":"So however I store this, I better had put it in some order for which that's easy.","width":256},{"text":"It should be constant time to get to the left and to get to the right.","width":320},{"text":"Oh, yea?","width":576},{"text":"So, this data structure will be an implementation of a priority queue.","width":704},{"text":"So I've got to lay these out some way.","width":256},{"text":"I'm going to tell you that we're going to lay these out in the order of some traversal.","width":256},{"text":"We got like 4 choices.","width":576},{"text":"25% shot.","width":128},{"text":"Level order.","width":256},{"text":"We have a winner.","width":192},{"text":"Level order, we're going to put this in level order. We're going to see why in a second.","width":192},{"text":"So, we put this in level order, we're going to have 4, 5, 6, 15, 9, 7, 20, 16, 25, 14, 12, 11.","width":1088},{"text":"So when we lay this out in level order, if I do this, how do I get, so remember this is an array, so we can think of it being an index 0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, and maybe we have extra space here, or whatever.","width":2176},{"text":"Cause it's going to be a vector and you're going to probably have some room and if you're adding stuff you might grow the vector.","width":256},{"text":"From our perspective, we can just think of it having 12 things in it right now.","width":384},{"text":"So, how do I get the left and the right child of the node?","width":384},{"text":"If I'm at, I don't know, let's say 4, how do I get the left child of the 4?","width":576},{"text":"Remember, the way that we're going to represent being at a node now is just being at its index.","width":448},{"text":"So when I say I'm at the 4, what I have is an int idx set to 0.","width":448},{"text":"So how do I get to the left child of the 4?","width":192},{"text":"In this case, idx + 1 would work and I get to the 5. ","width":192},{"text":"Is that always going to work?","width":64},{"text":"If I'm at the 5, I do idx + 1, so the 5 is at slot 1, idx + 1 would be the 6, that would on the other side of the tree.","width":512},{"text":"That's not what I wanted.","width":128},{"text":"Is there a general formula that would work?","width":320},{"text":"Time 2 plus 1.","width":256},{"text":"So, let's check, so if we're at the 4, we're going to add idx 0 times 2 would still be 0 plus one will give me the 5.","width":448},{"text":"That is indeed the left child of the 4.","width":128},{"text":"Let's try a harder one.","width":128},{"text":"Let's try 5.","width":64},{"text":"If I'm at 5, I'm at index 1, times 2 gives me 2, plus one would give me 3, and oh hey, the left child of 5 is at 3.","width":768},{"text":"What about 6?","width":192},{"text":"Well 6, that's at position 2, so 4, 5, so at position 5, hey, there's the 7!","width":384},{"text":"Hey that works!","width":128},{"text":"And you can verify for yourself that this does indeed work for every node in the tree.","width":256}]