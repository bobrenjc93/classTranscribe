[{"text":"this is a binary search tree. so we write a recursive definition for what a binary search tree is ","width":448},{"text":"so, a binary search tree is either , what's the bass case, empty, the in-ordered property is true for empty tree.","width":1024},{"text":"what's the bass case, empty, the in-ordered property is true for empty tree. there is nothing to compare. so a binary search tree is either empty, ok, or","width":1408},{"text":"a binary tree, so the root, let's say left, let's say right,ok. so let's take care of the first node first, and then do recursion backwards.","width":896},{"text":"what must be true, what must be true about r, relatively T-l, T-R,","width":384},{"text":"so we want, we want the roots, so we just say where , where the root should be ....think about T-left, first, what's true of the root relatively to the T-left.","width":1408},{"text":"the root better be greater than... the root of T-left, if the T-left doesn't exist, it's definitely right, because there is no root be cared about. ok","width":960},{"text":"and the root has been better smaller than, the root on the right, ok. that alone ... we just need to know that , the, the two subtree is also binary search tree. ","width":1216},{"text":"so, and , T_l, and T_R are binary search trees.ok","width":768},{"text":"cuz that's true, we know that....en.....wait a second......and this is not significant. sefinite","width":1408},{"text":"cuz it could be that for example, if i do , i put 15 there, what i just write just work, cuz the root is smaller than the left, sorry, the root is bigger on  the right. And the left and right are binary search trees.","width":1216},{"text":"but the problem is that there is a big elements on the left subtree that is larger than the root. so we should be careful. ","width":320},{"text":"so what i should say is that something like, the,e.. the max, the max on the left subtree, had better been smaller than ","width":1024},{"text":"ok, and similarly, the minum on the right must be larger that the root, that will handle this case.so now we fix this","width":832},{"text":"ok, cuz the largest thing in the left is 15, which is not smaller than 14.","width":704},{"text":"yeah, in this case, we not going to, you could in general, but when we are going to think about, we don't think about too complicated case.","width":576},{"text":"so all the keys would be unique....ok.... it just formulizing what we mean by in order properties. . we haven't say anything about the height yet.","width":1216},{"text":"we will get there. ...so if i had got this kind of structure","width":768},{"text":"what happened what should you do, if i ask you to find 9. how could you labrige the fact you know this in-order to find it faster","width":832},{"text":"oh, first, the height, of the tree is significant smaller that the numbers of nodes. right. so i can make, i can make my algorithm faster by not doing a full traversal ","width":1216},{"text":"by averaging the fact that at every node, i sort of know which half of the tree to care about . if  i ask you to find, what i say, 9","width":640},{"text":"so , so if i ask you to find 9,  memory of the goldfish, if i ask you to find 9, i know 9 cannot occur on the right of 14, cuz that's the violation of the in-ordered property","width":960},{"text":"so by knowing this tree is in-ordered, and maintaining while i am using that tree's fact. i know, it's always going to be in-ordered after inserting something insided it.","width":640},{"text":"then i know i can just skip all of this subtree, i don't care about at all what's there.","width":384},{"text":"so....i can just say, is 14 9 no, 9 is smaller than 14. 9 could only occur on that subtree.","width":768},{"text":"right...so then i go to there, 7....ok, is 9 7 no...ok...ok i need to figure out which side to insert, 9 is bigger than 7. so i know i have to go right. it can't go left side of 7. because everything on the left of 7 must be smaller than 7. so i can completely immediately root out","width":1408},{"text":"everything in this subtree is useless to me. so instead  i go right, because then 9 could only exist in this subtree.  so i am shrinking by half of nodes i have to consider, right","width":832},{"text":"if this tree is well balanced. if i got,sort of,  unique member of nodes, it's kind of on the left or the right. i'm having numbers of the things i am looking at","width":576},{"text":"so i am at 11, ok ,11 ,9 node, 9 is smaller than 11. so it can't be the right child of 11. so if 9 is here, it has to be this, 9, 9 yeah...","width":832},{"text":"i found 9, so i can return the value elements existed in that node, i haven't written the key, the value with key, right? but  you can think there is a value inside the node, and i just return it.","width":704},{"text":"it doesn't matter what it does, it maybe a picture, or a dog, it doesn't matter","width":512},{"text":"so this is the basic idea. we are using , leveraging the fact that this tree is in-ordered, shrinking our searching significant.","width":576},{"text":"so let's write the code for that","width":256}]