[{"text":"kinda thing do i want to be removing from it","width":1536},{"text":"so exactly","width":704},{"text":"so we're going to be using a min heap in this case","width":256},{"text":"and the reason is if you have the heap that contains your top 10 candidates right now","width":256},{"text":"and you see a new element","width":128},{"text":"what element are you likely to replace in your set of candidates ","width":384},{"text":"thats the only guy that you might replace","width":256},{"text":"so we want to build a heap","width":64},{"text":"for which","width":64},{"text":"accessing the smallest element is convenient","width":192},{"text":"that's the only guy you might replace","width":64},{"text":"and we see our new element","width":576},{"text":"we say okay","width":64},{"text":"here's this new element, here's the root of our heap","width":128},{"text":"the root of our heap is going to be the smallest largest thing we've seen so far","width":320},{"text":"the smallest one of those 10 candidates is sitting at the root","width":384},{"text":"so we say okay","width":64},{"text":"is the new element that we're seeing bigger than the smallest candidate I know about?","width":384},{"text":"If so, then that smallest candidate is not the right element so I should remove it","width":320},{"text":"and add this new element to my candidate list","width":192},{"text":"if however the new element is smaller than my smallest candidate I know that well, the smallest candidate is still bigger than it","width":512},{"text":"a top 10 so I just drop it","width":128},{"text":"so we're gonna have a a heap of size k","width":384},{"text":"adding one element to that heap of size k is going to take me a k","width":704},{"text":"cause the heap has size K","width":256},{"text":"so the height of that height will be log K","width":192},{"text":"removing one element is going to take ","width":640},{"text":"have a heap of size K, remove a element, how long does that take?","width":192},{"text":"log K","width":64},{"text":"so one way of doing this is to have a heap is to have a min heap","width":832},{"text":"maintain that there is always k elements on it at the end of your for loop. At the end of everyone iteration of your for loop","width":384},{"text":"so just take the element that they're proposing put it in your heap and remove the smallest thing","width":448},{"text":"so your heap will, if K is 10, you'll add an element in your heap, your heap is now size 11. ","width":448},{"text":"You shrink it by 1 by removing the smallest thing so then you are left with the top 10 things afterwards","width":384},{"text":"regardless of whatever is the status of the element that you just added","width":448},{"text":"so what's the overall running time of this then?","width":192},{"text":"","width":384},{"text":"so how many ","width":192},{"text":"so think of the inner loop, the inner loop is PUSH POP","width":192},{"text":"when it's filled to size K, we can just pretty much ignore the first 10 pushes","width":448},{"text":"After that it's going to be push pop","width":192},{"text":"we know that push takes log K, pop takes log K, so the inner body takes log K","width":576},{"text":"how many loop iterations are there?","width":128},{"text":"ALL N, we have to look at every element in the array ","width":192},{"text":"so this is going to be big O (nlogn)","width":256},{"text":"if logK, if K is some constant, this is pretty darn good","width":1088},{"text":"log, if K is 10log10, is something really small, so this is just n with a very small constant","width":512},{"text":"if you happen to want like the top 30,000 things okay. Then the k really does matter","width":448},{"text":"it's getting larger, it's getting close to N","width":64},{"text":"But if we make the assumption like we did in the beginning, that K was significantly smaller than N,","width":384},{"text":"The logK factor really doesnt matter a whole lot. So this looks close to linear","width":320},{"text":"the best known algorithm that i'm aware of for doing this can give you O (n).","width":512},{"text":"Without a new logK, has no dependence on k whatsoever. This is called quick select","width":448},{"text":"you'll end up writing an implementation of this in the next MP","width":256},{"text":"So I mentioned I sort of liked this second algorithm a little bit more. Does anyone know why that might be the case","width":768},{"text":"The second algorithm may be preferable","width":896},{"text":"Yeah maybe it's a little bit larger, because I've got a logN factor","width":768},{"text":"that's not my reason, but that's a good explanation","width":320},{"text":"his observation was that this space needed for this algorithm to work in the second case is really small","width":1088},{"text":"if you're looking for the top 10 things, your heap is only ever an array of size 11","width":384},{"text":"if you're doing the add","width":192},{"text":"if you're always making it always be size 10. then the array is any bigger than 10 elements","width":256},{"text":"In either case, your array is really small...","width":256},{"text":"And notice that the amount of memory you need to use to do this algorithm, has nothing to do with the number of elements in that array ","width":448},{"text":"So instead of it being an array, it could be a string of elements coming to you over a network","width":512},{"text":"Could beeeeeeeeeeeee,","width":192},{"text":"you know any source of data, potentially that doesn't even fit in memory and you can still find the top 10 things in it","width":102},{"text":"because you are only 10 elements at anytime","width":320},{"text":"So this one is nice because it's space complexity is really small","width":320},{"text":"normally, we look at run time complexity, which is what is the running time as a function of n","width":384},{"text":"but another way of looking at algorithms is looking at their space complexity and say okay, how much memory do they use as a function of N","width":512},{"text":"if I increase the amount of input data to this algorithm, how does the memory usage grow","width":256},{"text":"well in the first one it grows linearly with the amount of data you've got, cause you've got to build the heap that contains all the elements","width":448},{"text":"furthermore, the first one has to work given the assumption that you have all the data available to you right now","width":576},{"text":"this second algorithm can just kinda sit there and wait for the next element ","width":256},{"text":"it can be days later... couple minutes","width":128},{"text":"and it's always what the top 10 things were","width":192},{"text":"as of that point in time","width":128},{"text":"the second algorithm is actually really nice. It's called a streaming algorithm","width":192},{"text":"If you're curious, you can look up streaming algorithm that operate within this setting where you can't assume that all of your data is there and you furthermore cant assume that you can store all of the data in memory","width":640},{"text":"you can't assume you have  have O(n) storage","width":384},{"text":"to operate over huge amounts of data, and this second algorithm satisfies that ","width":448}]