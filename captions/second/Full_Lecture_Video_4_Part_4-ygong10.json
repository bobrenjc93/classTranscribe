[{"text":"yeah I heard segfaults","width":64},{"text":"Yeah, I heard segfaults. Umm, so this is undefined.","width":448},{"text":"I might write a blank image, it might crash, umm, it might write a weird looking image because the heap's been overwritten, and that the stack frame has been overwritten in that position with something else.","width":832},{"text":"Umm, but it is definitely a runtime error, so this is not good codes, this is a runtime error","width":448},{"text":"The reason for that is that when we return a pointer to something that lived on our stack frame.","width":704},{"text":"Alright, if you return a pointer to something that's on your stack frame, you're setting up whoever is using that pointer for sadness because you know that all of the memory associated with the stack frame is going to be released at the end of the function.","width":896},{"text":"Right? So if I have a pointer to an image that I put on the stack and then my stack goes away I give you a pointer to something that's no longer there, right? so that's definitely a problem, so this is not good umm","width":768},{"text":"Yeah the memory diagram makes that clear, you got a pointer up into a stack frame that I drew an X through and then you try to dereference that pointer and that's bad, alright...ok?","width":896},{"text":"Right, so so ok. So, how do we fix this is the question basically and his suggestion is well we sort of want that png to live longer than the function call, right? we want allocate png to stick around after allocate is gone, which means that we definitely can't put it on the stack, right?","width":1856},{"text":"cause if we put it on the stack, it goes away, so what if we use the heap, right? The heap memory stays around until we explicitly get rid of it","width":384},{"text":"so if we put something in a heap and give somebody a pointer to it and tell them hey it is your responsibility now, right?","width":384},{"text":"that memory will stick around after the function is done. So we can fix this, we can fix this by instead doing something changing how this works, so instead of these lines you know I might write something like","width":1024},{"text":"ok umm, png star ret is a new png w h ","width":960},{"text":"Nowww, if we go back and modify this, ret is no longer the image itself, ret is a pointer to the image over there","width":896},{"text":"right? so now the image is in the heap somewhere ok? and then we should return, return what?","width":640},{"text":"address of ret or ret? just ret. why not address of ret?","width":256},{"text":"it is already a pointer, an address of ret would be a png star star right? So that would be a type mismatch, so just going to return ret, ok? Now what happens ok? So now my function is returning by return value,","width":1088},{"text":"is the memory location of this thing, cause Im giving it the value of ret, so my img pointer will take the same value that is it will point at the same thing and then the stack frame for allocate is released ok?","width":1024},{"text":"Does that do anything to the image that is in the heap?","width":384},{"text":"when this stack frame goes away? Oh, ok. The png variable that is in the heap, the png object that is in the heap is not going out of scope ok? going out of scope is exclusively for stack allocate objects","width":1152},{"text":"k? so the png that I put in the heap doesn't go out of scope, the pointer to it does, but it is just a pointer it is just a number there is nothing special about that. That is released just like any other primitive data type that we ever talked about it is just an integer, it is ok move away stack frame done","width":1152},{"text":"k? so this goes away, which means that ok this pointer is gone but who cares, we already have a pointer to where it refer to already, right? so we haven't leak anything just yet because we have a pointer that we can still get to k? ","width":896},{"text":"Noww, inside of main, we are going to invoke img arrow save, that is the same thing as saying star img in parens to get the image and then call the dot save on it to save it out. we did this in the lab, so now is that fine?","width":1024},{"text":"yeah, right. the img pointer is now pointer to valid memory it is not clouded out or X out, it is still there. We know it is still live, we can still access it the behavior is defined, we get a 100 by 200 pixel white png saved to blank dot png on that line.","width":1152},{"text":"ok? and then we delete img, ok? which is going to follow this pointer and delete the memory and then we return 0 so now we know that we don't have any memory leak, there is no run time error, this is all good and fine so yes exactly so this is exactly how we fix this problem.","width":960},{"text":"ok? we need to make sure that we needed some way to guaranteeing that the object lived longer than the function did and we can't do that with stack frame.","width":640},{"text":"Ok, so what are the second one? Let's look at the second one","width":448},{"text":"Looks very similar, right? ","width":384},{"text":"we got a allocate function taking width and height thats returning you know it is setting up an image ret on the stack and is returning that object, but now it is returning by reference instead of as a pointer ","width":896},{"text":"ok? and then umm instead of having a pointer on the stack frame for main, we have an actual png on the stack frame for main, so img is now actually a full png object","width":1152},{"text":"ok? it may have pointers in the heap but just think of it as a block box you don't have to care about what is in it you just know it is there, ok so there is a png on the stack alright? and now we are setting it to the allocate of 100 200 so we are invoking this function now, so we go here again, samething as before, ret before we fixed it, so ret is going to be an image on the stack set up, right? probably blank with that dimension so it is a big white image","width":1984},{"text":"Ok? and we return it, so now we are returning ","width":320},{"text":"at main, with a reference","width":448},{"text":"ok? oh we are not going to make a copy of the thing we are returning instead we are saying ok we are going to give you, we are going to give the caller here's a name,","width":704},{"text":"right? here's a name that refers to some memory, somewhere else, it is not a pointer, you don't have to dereference it but it is just another name for something ok? so when you use this, you are just going to refer to other some memory somewhere else, right? I'm not going to give you brand new copies of this","width":1024},{"text":"ok?","width":128},{"text":"so what is this so then given that what do you think this does?","width":384}]