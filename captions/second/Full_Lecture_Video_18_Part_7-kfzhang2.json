[{"text":"An actual dictionary, right?","width":571},{"text":"What's the key?","width":1034},{"text":"A word.","width":53},{"text":"And what's the value?","width":124},{"text":"Definitions, pronunciations, etymologies, it depends on the kind of dictionary you've got.","width":379},{"text":"Some kind of record that represents information about that particular word.","width":607},{"text":"Right, so then you've got to be a little bit careful.","width":181},{"text":"So maybe the data element for a word contains all of its different definitions.","width":259},{"text":"Or all of its different pronunciations.","width":155},{"text":"But yeah, you have to be careful. Because again, you've got to have unique keys for what we're dealing with here.","width":464},{"text":"So if you have - If you have a need to have a key-value pair with multiple values for a specific key","width":347},{"text":"You've got to represent your value as a list of values, or something, rather than just a single value.","width":384},{"text":"You don't really say anything at all about what your value has to be.","width":192},{"text":"Your value could be itself, an array of values, or something.","width":256},{"text":"Or it could be a class that you've defined that has a bunch of fields in it","width":384},{"text":"Okay.","width":256},{"text":"So we're going to implement this ADT in a bunch of suboptimal ways.","width":192},{"text":"First.","width":64},{"text":"As usual","width":64},{"text":"And then, figure out how we can make it better.","width":64},{"text":"So","width":128},{"text":"Suppose you've implemented the above ADT with a binary tree.","width":256},{"text":"Write the declaration for the binary_tree<K,V>::node class.","width":334},{"text":"So note now that we've got two template parameters; one is the key, and one is the value.","width":256},{"text":"So we're saying that our keys can be pretty much anything,","width":192},{"text":"and our values can can also be pretty much anything.","width":128},{"text":"So what would our node class look like now?","width":256},{"text":"Well, we've got to find elements, and we know that the \"find\" - or the \"at\" operation that we're given here in this dictionary ADT","width":512},{"text":"takes a key, and gives me a value.","width":192},{"text":"So I had better store both the key and the value pair together inside my node.","width":320},{"text":"So my node class might look like...","width":192},{"text":"It's going to be K key, V value","width":1216},{"text":"So I'm going to have my key, my value, and I'm going to have my left and my right pointers.","width":1472},{"text":"Again, I'm going to use unique pointers here so that I have a clear chain of ownership","width":320},{"text":"All the way up the tree.","width":64},{"text":"So really the only difference here for the binary tree that we've been talking about so far,","width":320},{"text":"is now I'm storing two different elements in it.","width":192},{"text":"This could be effectively the same thing as having a binary tree T, where T was a pair.","width":448},{"text":"Object with key-value. That would also work.","width":320},{"text":"Template arguments, just like T.","width":256},{"text":"So my binary tree is now going to be template class K, class V.","width":512},{"text":"So I've got two template arguments.","width":128},{"text":"That's what this is about.","width":320},{"text":"So the nodes are going to be private, so it doesn't matter.","width":512},{"text":"That's good thinking, though.","width":192},{"text":"Normally, you don't want public member variables.","width":128},{"text":"But this is a private implementation detail anyway,","width":192},{"text":"so the only people who can access it will be the binary tree class, so it's fine.","width":320},{"text":"So let's try and implement this thing.","width":320},{"text":"This seems like a useful thing to have - There's lots of real-world applications for something like this.","width":320},{"text":"So let's see how we can implement using what we know right now.","width":128},{"text":"So, I've got four different choices that we could make here.","width":384},{"text":"So, let's focus on, I don't know, let's focus on inserting first.","width":448},{"text":"So why don't I insert a key-value pair","width":320},{"text":"into my implementation for this dictionary ADT","width":256},{"text":"And I'm going to choose to implement this dictionary ADT with a sorted array.","width":256},{"text":"Actually, I'm going to focus on one implementation first, and then the next implementation.","width":320},{"text":"So I'm going to do this entire row first.","width":128},{"text":"I think that's more... That'll help you think about what it looks like, and then think about the next thing.","width":512},{"text":"So a sorted array - I'm going to maintain a sorted array for this ADT.","width":192},{"text":"When I say sorted array, what...","width":128},{"text":"On what? Sorted by...","width":192},{"text":"Probably sorted by the keys, right?","width":128},{"text":"That's what I want to look stuff up by, so I should probably sort the array by K.","width":256},{"text":"So this is going to be a sorted array of, maybe, a key-value pair struct that's got a K key V value, or something.","width":576},{"text":"The data part of that node struct or something.","width":192},{"text":"Or, a std::pair key-value.","width":256},{"text":"However you want to think about it.","width":128},{"text":"Okay, so if I'm inserting into this sorted array","width":192},{"text":"So I already have a sorted array; it's already sorted by K","width":128},{"text":"...and I get a new key-value pair to insert","width":192},{"text":"how long is that going to take me?","width":128},{"text":"O(n), right?","width":128},{"text":"I can locate where I'm going to insert in log(n) time.","width":256},{"text":"Right, I can do a binary search.","width":128},{"text":"But I still have to shift stuff out of the way.","width":192},{"text":"Right, and that's going to be in the worst case linear time to shift everything over.","width":256},{"text":"So in a sorted array, insert is going to take linear time","width":256},{"text":"What about remove? If I ask you to remove a certain key?","width":320},{"text":"In this structure?","width":192},{"text":"O(n).","width":64},{"text":"Again, I can find it","width":128},{"text":"...in log(n) time, but then I've got to get rid of it and shift elements over to compensate for that blank that I just added.","width":384},{"text":"So that's going to be linear time for the shift.","width":192},{"text":"And then find() is finally when we're a little bit happy.","width":192},{"text":"We can look these things up in logarithmic time.","width":128},{"text":"","width":64},{"text":"That's just your standard application of binary search, where your searching for a K and then when you're done, you return the V associated with that K.","width":768},{"text":"But it's still sort of your bog-standard binary search on sorted array.","width":256},{"text":"","width":512},{"text":"","width":64},{"text":"You could do that, but it's not going to -- you could do that, but it's not going to help you.","width":320},{"text":"Because you're still going to have","width":192},{"text":"Some, like if your bucketing is","width":384},{"text":"Some fixed constant, so you have 26 buckets","width":128},{"text":"You know, the worst case is like n/26.","width":256},{"text":"If I evenly give you things that split among the buckets","width":192},{"text":"So it's still n because it's divided by some fixed constant.","width":320}]