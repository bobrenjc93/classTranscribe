[{"text":"No they're Lvalues cause they're passed in by values. Once I'm inside of this function, they've got a name, they've got a memory location, they're Lvalue. ","width":1088},{"text":"So I need to move them out. Even though I pass them in by Rvalues, they've been move constructed. But there's still a local object of that type. So now it's a Lvalue so I still need to move it down. ","width":630},{"text":"Yeah?","width":934},{"text":"Yes, I mean if you're taking a parameter by rvalue reference, once you're inside of a function, you've got a name so it's actually a Lvalue inside of the function. ","width":640},{"text":"So that's why you have to say std::move again. ","width":832},{"text":"So if you have a function, and it takes a rvalue reference, right? You've got a variable that's got a name and a memory location now. ","width":512},{"text":"So if you know it's a rvalue, it still has a name and a memory location when you're inside of that function. ","width":489},{"text":"So inside that function it's a lvalue. You know it's really a rvalue. Cause you can say its name, it's definitely an lvalue. ","width":413},{"text":"So you still have to std::move, even though you took it by rvalue reference. I'm gonna move on cause I..","width":500},{"text":"don't have time for a long discussion on that. So what're the other cases? First case is we didn't find the key and instead of throwing exception, we actually replace that empty subtree with a tree with one node, alright? ","width":1084},{"text":"So what's the other case? there're two other cases. ","width":576},{"text":"It's not an empty tree what do I do? ","width":285},{"text":"It checks the key, so I'm gonna say something like else..","width":320},{"text":"else if (key<subroot->key)","width":768},{"text":"if the key I'm inserting is smaller than the current subroot key what do I do? ","width":384},{"text":"I better insert it on the left right? So I'm gonna make a recursive call to the left subtree. So I'm gonna say something like..insert..","width":640},{"text":"","width":512},{"text":"insert to subroot->left, I'm actually passing the unique pointer now, cause it's taking it by reference. I'm not gonna do .get(), cause that'd be type mismatch. ","width":576},{"text":"Then I'm gonna pass down the key..","width":576},{"text":"","width":576},{"text":"and the value to the recursive call, again moving them so I don't make another unnecessary copy. ","width":704},{"text":"Enter this last block, where do I go? Right, so I know it's a non-empty tree, and the key was not smaller than the current subroot's key so I should go right now. ","width":960},{"text":"So this is gonna be insert (subroot->right..","width":960},{"text":"","width":768},{"text":"This looks kind of very very similar to find, the only difference is that there's only one base case for the empty tree and you just assign it to a pointer in that case. ","width":704},{"text":"Yeah? ","width":297},{"text":"I'm gonna deal with non-unique keys. The question was what happens if there're keys that are the same? ","width":576},{"text":"If you insert the same key twice, We're not gonna handle that case. ","width":192},{"text":"You could add a case for that, like replace a value, but maybe that's not what you want, you want it to have two values now so it's sort of unambiguous, we're just not gonna handle that case at all. ","width":768},{"text":"Yeah? ","width":512},{"text":"It's just gonna be slow, it's not gonna be an issue of stack overflow probably, it's just slow. ","width":384},{"text":"Again if it's a png object, you're copying it every time you pass it you're making heap memory again and again and again for the copy of that image every time you pass it. ","width":568},{"text":"But the stack size if actually pretty small. So you might use a crap ton of heap memory but your stack is probably fine. ","width":320},{"text":"","width":192},{"text":"So what's the running time of this function in terms of the height of the tree? ","width":384},{"text":"","width":256},{"text":"O(h), we only go down one branch of the tree at a time, ","width":448},{"text":"it's not as though we go down one branch and come back up and go down the others.. It's not like a traversal. ","width":342},{"text":"So I'm only gonna go down the height of the tree in the worst case, so it's big O of h. ","width":384},{"text":"","width":432},{"text":"So the last thing we haven't done yet, ","width":384},{"text":"is removal. ","width":319},{"text":"We've done insert, we've done find, now we have to do remove, right? Cause it's the three functions that we got for the dictionary ADT. ","width":640},{"text":"So for now we're gonna write remove, assuming we've got a nice helper function. ","width":370},{"text":"Remove node taking an unique pointer node reference, that would actually remove the node of that position, ok? ","width":448},{"text":"So our remove function here, all it's gonna do is to locate the node to be removed, and then call this non-recursive remove nodes function on it. ","width":640},{"text":"ok? So then we're gonna write that helper function later, ok? ","width":320},{"text":"Can anybody guess what this looks like? ","width":256}]