[{"text":"no","width":512},{"text":"Ah, the element that is inside of node struct is an unique pointer, so okay ","width":640},{"text":"I could have, but I would have to change my base case.","width":256},{"text":"So the question was why can't it be a node *, and answer is well...","width":256},{"text":"the way I am gonna write it cannot be a node *","width":192},{"text":"there exits a way to write it where it could be a node * but you have to change your base case.","width":256},{"text":"My base case i going to be when I am recursing into an empty tree","width":384},{"text":"I am gonna say okay, let that empty tree be the tree with one node containing this key value pair","width":256},{"text":"And that's sort of very simple base to write","width":256},{"text":"If you pass a node *","width":128},{"text":"you have to change your base case of this so that it's...","width":320},{"text":"okay the base case is actually when I am at the node ","width":192},{"text":"and whatever direction I am gonna go","width":128},{"text":"has a nullptr there and I change it there rather than recursing again.","width":320},{"text":"You have to kind of move your base case up one and you have to deal with nastiness that what if the tree is empty and you don't have a node to start off with","width":512},{"text":"cause your base case is now one-node tree so you have special case ","width":384},{"text":"maybe in the public function ","width":64},{"text":"which you can do, you can make it work","width":128},{"text":"Well it's significantly more code than, well not significantly","width":192},{"text":"I think it's a little bit more work","width":128},{"text":"than doing in this way","width":128},{"text":"this way is simple cause you can think of your base case just being an empty tree","width":192},{"text":"in which case I am gonna replace that empty tree with a new tree with one node","width":192},{"text":"Yeah,","width":64},{"text":"yes ","width":448},{"text":"You have to move it","width":128},{"text":"Well unless you moved it","width":192},{"text":"that's what I mean in that somebody giving you ownership of something","width":128},{"text":"we have in order to pass it in unique pointer by value  ","width":192},{"text":"somebody had to have an unique pointer and move it into your function ","width":192},{"text":"that moving process is that I am giving you ownership of this thing","width":256},{"text":"the thing over here that you are in charge of","width":192},{"text":"right, so it's flipped and moved","width":64},{"text":"okay","width":128},{"text":"so no moving happening here, just refer","width":192},{"text":"and we need the reference that we could modify the tree cause my base case is gonna be","width":256},{"text":"fairly simple, just the empty tree","width":128},{"text":"so I wanna kick this function off by, passing down the value that I need ","width":448},{"text":"which I knows gonna be, okay, the root","width":192},{"text":"root itselt, notices that if the tree is empty my base case it still gonna work here","width":384},{"text":"if ","width":128},{"text":"root is a nullptr, I will hit my base case right away, and replace that nullptr with one node","width":320},{"text":"right, so I know how many special cases the case for the tree is empty just works","width":256},{"text":"And I also gonna pass down my key and my value","width":256},{"text":"ah","width":64},{"text":"there are number of different ways you could do this","width":128},{"text":"you can pass them, so here I am passing them in the function here by value","width":320},{"text":"both the public and private helper function ","width":128},{"text":"you could do that, you can pass them by const reference","width":256},{"text":"either of there would work","width":128},{"text":"the point here is that you only want to make one copy of these","width":320},{"text":"what I am going to do is passing them by value to make the copy or do a move if I need to","width":256},{"text":"and then move them at every other function call","width":192},{"text":"so the very first public function is either going to move construct to k and move construct to v ","width":512},{"text":"or copy constructor to k and copy constructor to v or any combination of that","width":64},{"text":"and then from there on I am just gonna move it down the call train ","width":192},{"text":"but you could sort of write this ","width":256},{"text":"in bunch of different ways, all of them would be fine","width":192},{"text":"the key thing here is if you're passing by value you will make a bunch of unnecessary copies ","width":320},{"text":"so I am gonna move the values down, if we have a value like a png","width":192},{"text":"it's gonna be copied once and move down all the recursive functions ","width":256},{"text":"rather than copy different times ","width":64},{"text":"so when I am calling my helper functions actually I gonna say ","width":448},{"text":"std::move(key) std::move(value)","width":704},{"text":"I am just gonna move down the key and the value to the next function","width":192},{"text":"just remember whenever I am passing by value I has to create a local object from that type ","width":512},{"text":"from whatever the argument was if the argument is std::move something of that same type","width":128},{"text":"it's just gonna move construct it","width":64},{"text":"be at most one copy made here","width":320},{"text":"assuming that k and v are move constructable","width":256},{"text":"which is fine to do so","width":64},{"text":"Okay ","width":256},{"text":"So what am I actually gonna do in this helper function ","width":128},{"text":"so I've said a lot about the base cases","width":256},{"text":"so I said the base case is gonna be an empty tree","width":320},{"text":"if !subroot that is if subroot itself is nullptr, meaning I got an empty tree","width":704},{"text":"now I know I am at the position where I actually want to insert it, so now I am in it, you know","width":256},{"text":"I'm","width":64},{"text":"here where I am recursing on this nullptr in the 54 ","width":384},{"text":"so that is the nullptr I got so I wanna change that nullptr to point at new node that I've created","width":384},{"text":"with the right key-value data","width":128},{"text":"so I am gonna say","width":320},{"text":"I wanna say subroot should become equal to std::make_unique","width":1664},{"text":"what's std::make_unique","width":64},{"text":"it just gives me an unique pointer of the type that I put into the brackets, right","width":448},{"text":"and the arguments to that are just the arguments to the constructor for that object","width":256},{"text":"so the arguments to the node struct are ","width":192},{"text":"for its constructor I am gonna give std::make_unique, we'll do whatever needs do for those constructor  ","width":384},{"text":"so in this case, probably my node struct takes a k and v if the key and value in that order ","width":576},{"text":"so I am gonna do a std","width":64},{"text":"std::move(key) std::move(value) to move those into the constructor ","width":960},{"text":"for the node and then I am done","width":192},{"text":"so this is replaced the current tree which is an empty tree with one node tree that contains ","width":640},{"text":"this key and this value","width":64},{"text":"and I am gonna have a bunch of conditions ","width":384},{"text":"I don't want to copy it again","width":640},{"text":"think a value that is png object","width":256},{"text":"this like...make_unique","width":1472},{"text":"you can take make_unique as being just a function says, return std::unique_ptr t","width":448},{"text":"(new t(whatever the arguments for the function)) and curly brace","width":448},{"text":"so it's gonna just wrapping up that long ugly, I wrote the type like twice ","width":320},{"text":"I write the arguments again","width":128},{"text":"so it's just make that shorter,","width":128},{"text":"it's effectively same thing as unique pointer with some new node that  I create with constructor ","width":384},{"text":"and then moving into this pointer ","width":128}]