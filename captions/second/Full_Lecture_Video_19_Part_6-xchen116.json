[{"text":"no the L value is passed by value","width":640},{"text":"once I am inside this function, they got a name, they got a memory location","width":384},{"text":"they are L value","width":64},{"text":"so I need move now","width":128},{"text":"even though I passed they in by R value ","width":128},{"text":"they've being moved constructed ","width":128},{"text":"but they are still local object of that type ","width":64},{"text":"and till now it's L value","width":128},{"text":"so I still need to move it down","width":64},{"text":"yeah","width":128},{"text":"yes","width":896},{"text":"I mean even if you take it by R value reference you admit that once you are inside the function, you now got a name","width":384},{"text":"so it's actually a L value inside the function","width":192},{"text":"that's why I say std::move again ","width":128},{"text":"so if you have a function","width":896},{"text":"and it takes a R value reference","width":128},{"text":"right you got a variable that's got a name in the memory location","width":192},{"text":"so even though it's an R value, it's still has name and the memory location when you are inside that function","width":448},{"text":"so inside that function it's a L value ","width":192},{"text":"you know it's really a R value","width":64},{"text":"cause you can say it's name ","width":128},{"text":"it's definitely L value","width":128},{"text":"so you still have to std::move even you took it by R value reference","width":128},{"text":"and I am gonna move on","width":256},{"text":" I am on time for a long discussion on that","width":256},{"text":"what are the other cases ","width":192},{"text":"so first case is ","width":128},{"text":"we didn't find the key so instead of exception we actually replace that empty subtree with one node ","width":512},{"text":"right","width":64},{"text":"so what's the other case ","width":256},{"text":"two other cases ","width":128},{"text":"if it's no an empty tree what do I do","width":320},{"text":"check the keys I am gonna say something like else ","width":384},{"text":"else if","width":256},{"text":"key is less than subroot key, if the key I am inserting is smaller than the current subroot's key what  I do","width":1152},{"text":"I better insert it on the left ","width":128},{"text":"so I am gonna make a recursive call to the left subtree","width":256},{"text":"so I am gonna say something like insert ","width":128},{"text":"into the subroot left, I am actually passing the unique pointer now ","width":768},{"text":"cause it's taking by reference,  I am not gonna do .get()","width":128},{"text":"cause that the re-type is match","width":192},{"text":"okay,  I am gonna pass down the key","width":384},{"text":"and value to the recursive call","width":1024},{"text":"again moving ... unnecessary copy","width":192},{"text":"and I do this last walk","width":448},{"text":"where do I go","width":256},{"text":"right so l know it's an non empty tree and key was not smaller than the current subroot key I should go right now ","width":512},{"text":"so this is gonna be insert ","width":192},{"text":"subroot right","width":448},{"text":"so it looks kind of very similar to find the only difference that there is only one base case for the empty tree and you just assigning a pointer in that case ","width":1792},{"text":"I am not gonna deal with a non unique ","width":512},{"text":"the question was what happens if there is a key that is the same","width":256},{"text":"if you insert the same key twice we are not gonna handle that case ","width":320},{"text":"you could do ","width":192},{"text":"you could add a case that might replace the value ","width":192},{"text":"but maybe that's not what you want maybe you want it to have two values now so it's sort of ambiguous we just not gonna handle it","width":384},{"text":"just can be slow ","width":576},{"text":"it's not like an issue ","width":64},{"text":"of stack overflow probably ","width":192},{"text":"it's just slow","width":128},{"text":"I give it a png object you're coping it every time, you pass it you are making heap memory ","width":320},{"text":"again and again and again ","width":64},{"text":"the image return you pass it ","width":128},{"text":"but the stack size is actually pretty small ","width":128},{"text":"so you might use a craft on a heap memory ","width":64},{"text":"but you stack is by fine","width":128},{"text":"so what's the running time of this function in terms of the height of the tree","width":512},{"text":"o(h)","width":512},{"text":"we only go down one branch of this tree a time ","width":192},{"text":"right it's not as though we go down one branch come back and go down the others, not like a traversal ","width":448},{"text":"so I am only gonna go down the height of the tree of the worst case ","width":128},{"text":"this is o(h) as well","width":64},{"text":"right","width":576},{"text":"so the last we haven't done yet is removal ","width":512},{"text":"we've done insert ","width":384},{"text":"we've done find ","width":128},{"text":"now we need to do remove ","width":64},{"text":"cause these are the 3 functions we got for the dictionary ADT","width":384},{"text":"so for now we gonna write remove assuming we got nice helper functions ","width":512},{"text":"remove_node taking an unique pointer reference ","width":64},{"text":"that actually remove the node at that position ","width":320},{"text":"so our remove function here is gonna do is locate the node to be removed ","width":64},{"text":"and then call this non-recursive remove_node function on it","width":448},{"text":"okay, and then we gonna write that helper function ","width":256},{"text":"anybody guess what this looks like ","width":320}]