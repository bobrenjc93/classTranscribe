[{"text":"I need to make a new node that will become what head points to.","width":512},{"text":"I need the next pointer of that node to point at what the current head is and I need head to point  to the new node that I've made.","width":384},{"text":"So, up here I've given you that there's a default implementation of this constructor for the node so I can make a new node from a T and it just makes it by moving in the element, and by default I'll tell you the default constructor for a unique pointer, just like scoped pointer, is set to null.","width":1152},{"text":"So we don't have to worry about the null case.","width":320},{"text":"I need to make a node, auto N is make unique node.","width":1472},{"text":"And I'm going to move the data into the node incase it was expensive.","width":256},{"text":"I still need to copy, so I pass in by value.","width":64},{"text":"So I make a copy but I'm going to move it in there incase it's really big.","width":192},{"text":"I would valid to not say std::move here, its just an optimization.","width":320},{"text":"So now what do I have?","width":64},{"text":"Well, I've made this new node with value maybe 3, and this is set to null, and my current list is something like this is head, which points at here.","width":1344},{"text":"So now I need to make sure that the next pointer of this new node that I've made points at the same thing that head does. How could I do that?","width":768},{"text":"I need to set its next, so N next equals the thing more just head.","width":960},{"text":"Because I can't copy a sign or copy construct any of these unique pointers. ","width":448},{"text":"So what do I need here?","width":64},{"text":"Std::move. I need to move it","width":192},{"text":"If i just said N next equals head, thats going to try and copy head, which is not allowed.","width":320},{"text":"You can't copy unique pointers. So it won't compile. So I actually need to move it.","width":448},{"text":"What does that do to our diagram?","width":704},{"text":"You can think of this move assignment as the same thing that you wrote for your scoped pointer, so what did that do?","width":448},{"text":"What happens to the argument?","width":128},{"text":"The argument ends up being null and what happens to the current object?","width":448},{"text":"It points at the same thing that your argument was","width":128},{"text":"Our argument will be left empty, which means that head will be set to null","width":384},{"text":"But this, the current object, which happens to be the unique pointer inside this new node N is going to point at that.","width":640},{"text":"We've transferred ownership.","width":256},{"text":"We said OK, the node that held 2 used to be owned by the head pointer inside of the list. When we moved it, it is now owned by this new node we created","width":768},{"text":"So now the lifetime of this whole chain of memory is tied to N, but N is going to go away, so now what do we need to do?","width":512},{"text":"We need to make head point at N.","width":320},{"text":"Now we can move N into head.","width":320},{"text":"N was a unique pointer of the node.","width":768},{"text":"So now when we say std::move N, we leave N null and we make head point at this instead.","width":576},{"text":"So now we've crafted a new node at the front of our head and everything is happy.","width":448},{"text":"N is a pointer, so I have to either star N dot or N arrow.","width":1152},{"text":"It's just like a scoped pointer, where you have to access data elements through dereferencing.","width":704},{"text":"I drew a picture here because I wanted to be clear about who was owning what at every step.","width":384},{"text":"If you don't do that and you're a cavalier here, you're going to have magically disappearing lists.","width":320},{"text":"So make sure you draw the diagram and know what's owning what, so when your destructor for your temporaries are invoked, it doesn't delete your whole list.","width":512},{"text":"So here when the destructor for this N temporary is run, nothing happens because it's null.","width":384},{"text":"So I keep my list, I didn't lose it.","width":192},{"text":"Write an implementation of size.","width":448},{"text":"So how could we do that? How can we get the number of nodes in the list?","width":384},{"text":"Remember, right now our only data member is just a pointer to the head of the list.","width":384},{"text":"How would I figure out how many things are in this?","width":320},{"text":"I could recursion, I could also do iteration, but I need some way of counting the nodes, right?","width":704},{"text":"I fundamentally need to go from the head and say there is one node, two, three, four, and go through the whole list to figure out how many things there are.","width":640},{"text":"That's how I would have to do it right now.","width":192},{"text":"Is there a better way?","width":320},{"text":"Just have an int inside the class that keeps track of how big it is.","width":576},{"text":"If I do that and I maintain that whenever I'm adding and removing nodes, I don't have to go through the whole list.","width":384},{"text":"How long would size take given our current implementation?","width":192},{"text":"What is the big O running time of size?","width":128},{"text":"N. O(N), because we have to start from the head and go all the way down to the tail.","width":256},{"text":"And if there are N things in the list, it takes O(N) time.","width":256},{"text":"If we maintain a size counter that counts how many nodes there are in the lists and increment that when we add a node and decrement it when we remove a now, how long does size take in that case?","width":640},{"text":"O(1) because I can just return the counter.","width":384},{"text":"Which means that I need to add a size here.","width":576},{"text":"And that would also mean I need to set the size to 0 in my default constructor which I haven't provided here, but you know how to do that by now.","width":768}]