[{"text":"so here's two gotchas the first is that my variable, array i didnt build it to update","width":820.1818182468414},{"text":"and so it could be that during testing everything is fine but later one it turns out that im trying to change the size of realloc and actually had to move my array to different memory and i didnt update it","width":812.1818182468414},{"text":"so make sure you use a return value","width":193.18181824684143},{"text":"this second error is awful","width":153.18181824684143},{"text":"and im going to tell you know its because life is short","width":216.18181824684143},{"text":"and please please never make this error","width":183.18181824684143},{"text":"unless youre trying to confuse someone else","width":184.18181824684143},{"text":"this is a fantastic gotcha","width":367.18181824684143},{"text":"does that code really allocate enough things for 100 entries","width":482.18181824684143},{"text":"no it allocates 100 bytes","width":187.18181824684143},{"text":"what we forgot to do was multiply it by the sizeof() our entries","width":696.1818182468414},{"text":"so don't just plug in N here or number of items remember that calloc realloc and malloc work with bytes","width":477.18181824684143},{"text":"and we didnt allocate enough bytes","width":139.18181824684143},{"text":"which means later on","width":74.18181824684143},{"text":"when we start putting things in our array we're going to go past the end of the array","width":285.18181824684143},{"text":"and exciting things can happen called segfaults and data corruption","width":405.18181824684143},{"text":"so start and pause whenever you see realloc are you actually passing the right number of bytes","width":351.18181824684143},{"text":"and when you see sizeof() are you calculating the size of the right type","width":443.18181824684143},{"text":"okay","width":58.18181824684143},{"text":"thankfully now no one in this room is ever going to mkae that error again","width":194.18181824684143},{"text":"we'll just let university of whatever make those errors","width":277.18181824684143},{"text":"okay","width":29.18181824684143},{"text":"so","width":80.18181824684143},{"text":"what do remember about calloc?","width":105.18181824684143},{"text":"what does calloc do","width":164.18181824684143},{"text":"okay it takes two arguments","width":140.18181824684143},{"text":"and it multiplies them together to determine the number of bytes","width":179.18181824684143},{"text":"what else? how is it different from malloc?","width":289.18181824684143},{"text":"it clears the memory","width":68.18181824684143},{"text":"yes","width":112.18181824684143},{"text":"calloc now only gives you back a pointer to some memory","width":194.18181824684143},{"text":"it zeros out all that memory as well for you","width":242.18181824684143},{"text":"so we go back to java arrays","width":120.18181824684143},{"text":"we said hey i need a new integer array","width":159.18181824684143},{"text":"a great way to implement that would be to use calloc","width":371.18181824684143},{"text":"so of course then","width":48.18181824684143},{"text":"calloc is much slower","width":83.18181824684143},{"text":"we actually have to write to all those memory locations","width":104.18181824684143},{"text":"and you remember talking to memory is really slow","width":187.18181824684143},{"text":"especially when you need to talk to lots of it","width":167.18181824684143},{"text":"so the reason that we dont necessarily always call calloc is because sometimes we know that our program is going to write into every memory location","width":505.18181824684143},{"text":"we don't even need to waste time zeroing it out first","width":498.18181824684143},{"text":"so it zeros the bytes","width":800.1818182468414},{"text":"so you can write a loop to do this","width":228.18181824684143},{"text":"but ill give you a little hint","width":138.18181824684143},{"text":"if youre ever writing a calloc and you want it to be performant","width":233.18181824684143},{"text":"then remember when you do the operating system and say hey i need some new bytes","width":358.18181824684143},{"text":"i guarantee you those bytes will be zero","width":304.18181824684143},{"text":"because the kernel the operating system does not want to give you some memory that is being used by a different process","width":517.1818182468414},{"text":"maybe its got a password in it","width":73.18181824684143},{"text":"maybe its got a secret key in it","width":85.18181824684143},{"text":"maybe its got stuff that you shouldnt have access to","width":156.18181824684143},{"text":"so for security","width":134.18181824684143},{"text":"you will get bytes which are zero","width":315.18181824684143},{"text":"so if you know that you're getting new bytes","width":183.18181824684143},{"text":"you can reliably","width":114.18181824684143},{"text":"you dont actually have to zero those out","width":139.18181824684143},{"text":"but only if you know that youre getting them fresh from the operating system","width":201.18181824684143},{"text":"youre not just using memory thats already part of your process","width":687.1818182468414},{"text":"boundary tags we haven't talked about much","width":159.18181824684143},{"text":"but we have talked about indirectly","width":207.18181824684143},{"text":"the last lecture","width":78.18181824684143},{"text":"i gave you an idea about whenever we did an allocation","width":220.18181824684143},{"text":"we could actually store the size of our allocated area","width":463.18181824684143},{"text":"at the beginning and the end of each part","width":270.18181824684143},{"text":"so rather than having a separate struct like we saw at the beginning of this lecture","width":223.18181824684143},{"text":"we could actually hide inside here how many bytes this is","width":280.18181824684143},{"text":"so this say is 16 bytes","width":158.18181824684143},{"text":"put 16 here","width":71.18181824684143},{"text":"this is 20","width":212.18181824684143},{"text":"so if we do these tags at the beginning and end","width":272.18181824684143},{"text":"then when we come to do something like a free","width":359.18181824684143},{"text":"i know that because these are like train couches becuase theyre next door to each other if i just go backwards enough bytes","width":438.18181824684143},{"text":"i can actually read how big the previous allocation was","width":236.18181824684143},{"text":"and that allows me to manipulate these values","width":149.18181824684143},{"text":"and to maintain a list what's been allocated","width":334.18181824684143},{"text":"as part of this train","width":174.18181824684143},{"text":"as part of these tags which are next to each other","width":369.18181824684143},{"text":"alright","width":55.18181824684143},{"text":"so when actually return from malloc","width":193.18181824684143},{"text":"we wouldn't return the beginning of the carriage if you like, no we look a few bytes in","width":383.18181824684143},{"text":"and say okay here's that area for you to play with","width":240.18181824684143},{"text":"you can put whatever data you want inside this bit here","width":246.18181824684143},{"text":"because you asked for 8 bytes in the middle","width":258.18181824684143},{"text":"but becuase the users code was broken","width":296.18181824684143},{"text":"it kept going","width":140.18181824684143},{"text":"say someone didn't actually request enough bytes","width":238.18181824684143},{"text":"so as a result of that","width":101.18181824684143},{"text":"the user code just destroyed our metainformation inside here","width":329.18181824684143},{"text":"in fact it could've kept going as well","width":527.1818182468414},{"text":"things might seem to work until the day the code calls free","width":446.18181824684143},{"text":"becuase now you're free implementation assumes that it can read these values correctly","width":417.18181824684143},{"text":"but as we've just seen the values here are gone","width":473.18181824684143},{"text":"they've been replaced by whatever the user code happened to write in there or the rest of the program actually did","width":467.18181824684143},{"text":"so now you linked list manipulation and your calculations","width":267.18181824684143},{"text":"ha ha ha","width":240.18181824684143},{"text":"might be updating arbitrary pieces of memory","width":144.18181824684143},{"text":"and you're adding whatever the values were in here","width":255.18181824684143},{"text":"heres an example where a buffer overflow could make your perfectly reasonable code do bad things","width":478.18181824684143},{"text":"now it could make it say write arbitrary values into arbitrary different locations","width":339.18181824684143},{"text":"which is why buffer overflows are so dangerous","width":275.18181824684143},{"text":"of course most likely whats going to happen is when you call free your program crashes","width":385.18181824684143},{"text":"so when your program crashes during free its probably because something bad happened earlier to the heap","width":546.1818182468414},{"text":"so how can we stop that?","width":229.18181824684143},{"text":"what can we do?","width":364.18181824684143},{"text":"lets say youve inherited a program where it just crashes strangely on free","width":350.18181824684143},{"text":"how could you try to figure out what's going on?","width":693.1818182468414}]