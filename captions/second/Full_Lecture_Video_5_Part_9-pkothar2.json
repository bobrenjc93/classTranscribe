[{"text":"{writing things on board}","width":1216},{"text":"What am I gonna do in here?","width":384},{"text":"I need to copy over the argument right because I am sorta redefining what assignment means and I know I need to make a deep copy of the right hand side. What do I need to do first?","width":896},{"text":"Check for self assignment. Check to make sure I'm not like doing a=a. Because if I'm doing a = a, then we don't change anything. It's fine, a already equals a. So we wanna check for that so we know we're not doing weird things when we say a =a .","width":1513},{"text":"So I'm gonna say \"if\" something to make sure its not self assignment. What does that check look like? if(this != & rhs)","width":1088},{"text":"What in the world does that mean? What is \"this?\" A pointer to the current object. So a memory location. I'm saying that if the memory location of the right hand side of the assignment is not the memory location of the right hand side of the assignment. So when would they be equal?","width":1672},{"text":"Only when they're the exact same object. Only when a = a, when this == rhs. Only when they are the exact same object are they going to live in the exact same place. So I'm just checking if they live in the same place. If they do not live in the same place, do whats inside of this if block, otherwise don't.","width":1600},{"text":"So if I'm inside the if block I know that they are not the same object. So I know I need to do the copy but there is something I need to do first. Clear, why do I need to clear? Why do I clear? ","width":1085},{"text":"Yeah. I would leak memory if I didn't. The key point here is that in order to be inside of the assignment operator, my left hand side already exists. Which means it already has memory allocated for it. This is different than the copy constructor because the copy constructor is happening before the object even exists you're creating it. Here I already have a left hand side. The book has already been created. So we will already have memory allocated for it.","width":2470},{"text":"So I need to make sure that I release whatever I was using in the past before I make a deep copy of the right hand side. Does that make sense? That's the key difference between copy constructor and assignment operator. The copy constructor is making new stuff, making a new object. The assignment operator is changing an existing object. ","width":1204},{"text":"So Since I'm changing an existing object I may have already set my member variables so I may already have a whole bunch of memory setup. So I'm going to do a clear first to get rid of it, then do a copy.","width":960},{"text":"This is how those helper functions are useful, I don't need to rewrite what it means to do a clear, what it means to do a copy. And then what do I return? * this.","width":1152},{"text":"Remember this points at the current object, it's not a reference, so * this is the current object. So I'm returning the current object by reference. Why is that fine? Why is returning a reference fine? That should scare you. Why is it safe to return * this?","width":1600},{"text":"I'm assigning into it, therefore it already existed. It's not going to go away at the end of this function. In order for this to happen, you're doing something like b equals a [b = a], then returning b's reference. B already had to exist, so it's fine to return it by reference because I know it's lifetime is longer than this function.","width":1462},{"text":"Whenever you see something that is returning a pointer or reference, have in the back of your mind what the lifetime of the thing you're returning is. Does it live longer than the scope of this function or not? In this case, whats the lifetime of * this? well I called a member function on it so it better have already existed. Better live longer than this function does. So it's fine to return * this.","width":1344},{"text":"So now I wanna address all the questions we're having in the prelecture for the wrong way to do this. In the one in the prelecture I believe the only thing I changed was like this. Instead of ampersand (in the header), I used * this (instead of this) in the function. This completely changed the function. Two characters, totally different meaning. What does that if statement now do?","width":2176},{"text":"It's comparing the objects with a not equal operator. So type of left * this going to be a book, and right hand side is a reference to a book. So my left hand side and my right hand side are like books. No I am saying not equal on book objects, so I'm gonna look for a \"!=\" thats defined on books","width":2209},{"text":"So first problem, that might not even exist. The way that we've written it the books dont know how to compare each other like that. In our example saying a != b or a == b, I don't know what that means. It won't even compile unless I define it. The system does not provide you a default !=. Okay, so first of all it does not even compile unless I have defined a != for books okay. Even if I did define a not equal for books, why is that bad?","width":2368}]