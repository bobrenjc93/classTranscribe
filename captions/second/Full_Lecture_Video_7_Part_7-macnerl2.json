[{"text":"question?","width":256},{"text":"right so","width":320},{"text":"the question was why are we returning a book referance rather than just a void. um. an","width":384},{"text":"and the answer for that is kind of the same the same answer we had for the assignment operator","width":512},{"text":"where we could do things like a = b =c","width":64},{"text":"right so we had to return a reference","width":256},{"text":"because that kind of thing, that kind of thing is syntactically valid in c++","width":256},{"text":"the same thing should be","width":64},{"text":"true of operator +=","width":192},{"text":"so if we said something like ","width":192},{"text":"a +=b +=c","width":192},{"text":"that should be valid","width":128},{"text":"unfortunately","width":128},{"text":"we return a reference to the left hand side","width":256},{"text":"for sort of the same reason","width":128},{"text":"because you should be allowed to chain these things together","width":128},{"text":"if we return void we couldn't do this","width":128},{"text":"which maybe is fine, but it's sort of","width":128},{"text":"it's sort of counter-intuitive compared to what you can do with existing types","width":192},{"text":"you can do this with existing types","width":64},{"text":"it 'ought to be true that you're type also returns a reference","width":320},{"text":"but its not like the compiler \"no you can't do that\" you can do whatever you want, I can have += just return an int for all the compiler cares","width":576},{"text":"it just wouldnt make sense to people","width":192},{"text":"a += it gives me 4","width":128},{"text":"right","width":64},{"text":"so it should probably be","width":192},{"text":"if its going to return anything at all","width":192},{"text":"it should be a book reference","width":64},{"text":"and the question should it return void or should it return book reference","width":256},{"text":"to make it sort of blend in it should return a book reference","width":128},{"text":"okay","width":256},{"text":"alright","width":64},{"text":"get rid of the diagram here","width":320},{"text":"cause i want to","width":64},{"text":"other conversation","width":136},{"text":"we're sick of my  conversations at this point","width":95},{"text":"... conversations..","width":128},{"text":"alright","width":56},{"text":"so I was sort of unhappy at the end of the second","width":320},{"text":"double for loop of this +=","width":192},{"text":"because I was forced to do a depp copy of those strings","width":384},{"text":"but what if I was saying","width":128},{"text":"+= with a right hand side that was a temporary?","width":384},{"text":"right?  then I dont really need to do that deep copy, now I know that the right hand","width":384},{"text":"side isnt going to be referred to by anybody","width":64},{"text":"I can make that better right","width":256},{"text":"if I know my right hand side is a temporary","width":64},{"text":"I can actually go ahead and move those strings because nobody is going to refer to that anymore, right?","width":384},{"text":"it may be reasonable to also provide an overload for this function that takes an r-value reference ","width":254},{"text":"right","width":64},{"text":"because then we know that we can change that last copy there","width":256},{"text":"","width":10},{"text":"to not do a copy","width":64},{"text":"to do a move instead","width":128},{"text":"because then we know the right hand side is a temporary value","width":256},{"text":"and it's fine if we steal things from it because no one's going to look at it anymore","width":192},{"text":"right","width":64},{"text":"so im may also want ot provide an overload for this function that takes a","width":384},{"text":"r-value reference. so I may want an overload that was","width":512},{"text":"and then the one place where I can make that overload slightly different to be more efficient","width":1088},{"text":"would be right here where for the overload that took a book ref ref I could do the = std::move()","width":640},{"text":"only if I know the right hand side is safe to steal from, and thats only safe to steal from if i'm getting it as an r-value reference","width":896},{"text":"okay","width":64},{"text":"so if I add another funtion that's exactly like this one but it takes a book ref ref","width":256},{"text":"and I change that last line","width":128},{"text":"the line that i've","width":192},{"text":"put an arrow to here to be a std::move()","width":64},{"text":"just like the one above it, that can be a little bit faster","width":192},{"text":"okay","width":256},{"text":"I only know that's safe if my argument is temporary","width":192},{"text":"my argument is an r-value, then its safe to steal from","width":192},{"text":"if its not an r-value, then its not safe to steal from","width":144},{"text":"alright","width":192},{"text":"yeyeah?","width":626},{"text":"<question>","width":117},{"text":"it would invoke so the answer is ","width":152},{"text":"it's complicated","width":73},{"text":"it depends on what the assignment operator for that specific class does","width":384},{"text":"that class being the thing that is this","width":256},{"text":"what is that type","width":64},{"text":"so that type is a std::string so it's going to invoke the operator equals","width":320},{"text":"for std::string","width":128},{"text":"now however string happens to implement their operator equals, the answer could be different","width":192},{"text":"if string uses copy and swap it's probably going to invoke the move constructor for the string object","width":256},{"text":"if the string class doesnt use copy and swap and instead has two different overloads","width":320},{"text":"one for const ref","width":128},{"text":"and one for r-value ref, it might not use a move constructor, but it will","width":256},{"text":"move it for you","width":192},{"text":"it'll do whatever the move semantic should be","width":64},{"text":"but the question it ... depends on the implementation","width":192},{"text":"for most classes that we would write","width":192},{"text":"if this was like a uh.. a png or something, then yeah it would invoke the move constructor for that argument","width":512},{"text":"because it would take it by value","width":192},{"text":"the important thing to remember there isn't necessarily which constructors are invoked ","width":448},{"text":"or whatever","width":64},{"text":"its to recognize thatwhen you're doing an assignment and you're giving it a right hand","width":256},{"text":"side that has been std::move() of somtheing","width":192},{"text":"you're allowing the system to steal stuff out of that object if it can","width":181},{"text":"if it  doesnt have a move constructor, obviously it won't invoke one because it doesn't exist.","width":256},{"text":"so it'll still do a copy if it has to.","width":64},{"text":"but if a move constructor does exist it will invoke that which typically can do something faster","width":320},{"text":"if your class has a fast routine for that","width":384},{"text":"if your class provides a move constructor","width":128},{"text":"so when would I provide a move constructor? that's also an interesting question","width":192},{"text":"when should a class provide a move constructor","width":192},{"text":"<question>","width":256},{"text":"yeah kinda like if copying is too big maybe it should provide a move constructor","width":512},{"text":"that's contingent on there being something better that you can do than that copy","width":256},{"text":"so like if I had a class that had a static stack allocated array of size 1,000 in it","width":384},{"text":"oh okay copying that is going to be expensive, I'm going to add a move constructor","width":192},{"text":"there's nothing I can do that's more efficient there because it's always going to be","width":192},{"text":"part of the class that array is inside of the class its not a pointer to heap memory I cant steal ","width":384},{"text":"the stack array from another object","width":256},{"text":"its not possible","width":64},{"text":"so having a move constructor in that case wouldn't help me at all","width":192},{"text":"likewise if I've got a class thats got like a bajillion member variables","width":256},{"text":"like 47 member variables","width":131},{"text":"oh, thats going to be slow to copy because there's 47 of them, im going to wirte a move constructor","width":268},{"text":"if they're all on the stack, there's nothing more efficient that I can do","width":256},{"text":" than just copying those values","width":128},{"text":"alright","width":64},{"text":"so the answer is if you had to redefine what copying meant","width":320},{"text":"that means you're probably using dynamic memory, you're probably using heap memory","width":320},{"text":"in which case you would probably know a better way to do a move than doing a deep copy","width":384},{"text":"thats doing a new dynamic array allocation ","width":128},{"text":"in the heap.","width":64},{"text":"so the answer is if you know of a way to move your class faster than to copy your class, then it makes sense","width":358},{"text":"to have a move constructor","width":128},{"text":"but if I've just got a class that's got like a thousand integers in it","width":256},{"text":"and its not a dynamic array, its just like a thousand member variables that are just integers","width":256},{"text":"or a statically allocated array of integers that's a size 1000 on the stack, not in the heap","width":256},{"text":"there's nothing I can do to make moving faster","width":256},{"text":"than copying for that class there's no point in having a move constructor","width":302},{"text":"the answer is kind of pretty much when you've got dynamic memory you should start thinking about whether","width":271},{"text":"it makes sense to implement a move constructor","width":192}]