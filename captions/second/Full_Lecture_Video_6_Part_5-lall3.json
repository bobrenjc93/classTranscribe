[{"text":"No audio","width":1344},{"text":"Deep copy of array of b","width":512},{"text":"Thats going to call the copy constructor that we have already defined nad written. It sets up the array properly","width":576},{"text":"okay , fine","width":256},{"text":"I call swap with right hand side","width":256},{"text":"This is just going to swap our pointers around. So that means that, remember the current object is the left hand side ","width":448},{"text":"So the current object is 'a'. So when I call swap what I'm doing is, rhs look here and a look here","width":896},{"text":"Thats all that swap is going to do. Just swap the memeber variables","width":192},{"text":"Then I say return star this which mean that the stack frame for operator equals is going to go away and remember whenever a stack frame is destroyed, the destroctors of all its local variables are invoked in reverse order of their allocastion","width":1280},{"text":"So when I return out of this function. I invoke the distructors of any temporary variables. I have one temporary variable here, right hand side  ","width":576},{"text":"I invoke its destructor which means I am going to delete what ever heap memory it allocated. which happens to be this array here. Stack frame for right hand side goes away and now I have 'a' being an independent copy of 'b'","width":960},{"text":"I've leaked no memory. I'm strogly exception safe because exception will be thrown before I am able to change anything","width":640},{"text":"What about self assignment. So the answer to the efficiency question is going to come with an astrix. What about self assignment?","width":896},{"text":"I still do the same thing. I have no check for self assignment","width":256},{"text":"So if I sat 'a' equals 'a'. I make a copy of 'a'. I swap myself with the copy. I destroy my memory. and then I return","width":768},{"text":"So, yes self assignment is less efficient then before. However self assignment still works. Self assignment works as we expect, the object has not changed its values. Internally it refers to something else but the values remain the same. Its asif nothing happened.","width":1408},{"text":"So it is robust self assignment. Yes, it is less efficient but who really cares. How often are you doing a equals a","width":512},{"text":"As long as it still works, I am happy. I don't expect people to say 'a' equals 'a' all that often. The reason we had to before was to make sure it was even valid.","width":832},{"text":"Not just as an optimization. If we didn't it would be broken. Here we are not checking for self assignment because we don't have to. Yes its less efficient but it sill works.","width":704},{"text":"And this has all kinds of nice things about it so its more reasonable to write this. I would rather write this.","width":768},{"text":"Much easier to remember","width":320},{"text":"Remember the strong exception safety part of this not to prevent the error from happening. If there is an error when I'm making the memory, the assignment does not happen","width":1088},{"text":"The problem with the other one is that when it does run out of memory and I say 'a' = 'b'. I have changed 'a' in an assignment that shouldn't have been allowed to happen cause I couldn't make memory allocations","width":896},{"text":"So this new one, if I cant make the memory then I can't even call the function. So nothing is going to happen to my left hand side. So that's the difference. This can still throw an exception but the difference is that the left hand side is not changed, where as before we lost data and its gone for ever even if the system is like \"Sorry, bad alloc is thrown\"","width":2048},{"text":"Now when we say 'a'='b'. It doesn't get rid of the data until it knows it can do the assignment, do the copy.","width":640},{"text":"so now if it fails, I still get std bad alloc but the data is still there. It is actually true that the assignment didn't take place.","width":768},{"text":"Don't need a try catch block here. The point is to not catch the exception. the point is that when an exception is thrown, is not to catch the exception nut if doing the assignment is going to throw the exception the left hand side should not be deleted. We want it to be as though nothing happened at all.","width":1664},{"text":"The one before doesn't work because if an exception is thrown during memory allocation when the copy() function is called, we have already modified the left hand side. Cleared the left hand side","width":1280},{"text":"I don't mean that there are no more exception. What I am saying is that when an exception is thrown, the left hand side is left in a valid state, that is what it was before.","width":896},{"text":"Left hand side is as though as it has not been modified. When i throw an exception out of the pixel access operator, I did not actually access an invalid pixel, I just through as exception like \"No, don't do that\" . Should be as though nothing happened because it couldn't. That the difference. ","width":1536},{"text":"","width":64},{"text":"Always write your assignment operator like its written here because reasons.","width":576}]