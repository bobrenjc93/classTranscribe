[{"text":"Particularly, if i set this to some value that is less then 1, so most of my lists are 0 or one in terms of their lengths,","width":1280},{"text":"That's obviously pretty good, because if there is only 1 thing in your list, that's just dereference list and then you are done.","width":448},{"text":"This resizing is super important to gurantee that these lists are very small.","width":512},{"text":"What do we actually do when we do a resize?","width":320},{"text":"Sort of similar to the argument that we had before, where we wanted to do a geometric resize of the table, we are going to do a geometric resize of the table as well with one little modification just make things turn out nicely.","width":1088},{"text":"It turns out if you have hash table sizes that are prime numbers, you get a little bit better hash function performance when you do the modulo, they're just worked out nicely with sizes that are relatively prime.","width":768},{"text":"We are going to create a new array","width":704},{"text":"Of 2 times m up to the nearest prime","width":704},{"text":"And the function that is already given to you for the lab, you don't have to worry about that","width":384},{"text":"I want to double the array size and then round up to the next closest prime.","width":256},{"text":"Because I always want my table sizes to be prime if I do that theres some theory that I'm not going to go into that ensures that your hash functions are a little bit more behaved when you've got relatively sized table sizes","width":960},{"text":"Step 1 is to make the new storage","width":320},{"text":"And now I've got to move everything over","width":192},{"text":"This is your question where if I'm resizing, When m is going to increase, the values for my hash function are now being modded by a different number.","width":1152},{"text":"Which means that potentially every key in this thing has a different location now.","width":512},{"text":"So when I'm resizing, I cannot just do a blind copy over all the lists, that does not work.","width":384},{"text":"I cannot just move over all the lists into the new array into the new positions because those elements might not go there anymore.","width":704},{"text":"So what I have to do here when I do a resize is go through all of the elements that I've got and rehash them and then insert them into my new table.","width":704},{"text":"So I sort of redo the process of inserting everything","width":512},{"text":"And so again this is where that doubling comes into play, where we really need that doubling.","width":320},{"text":"Because I'm going to do something when I do the resize and make a new thing of twice m up to the next prime","width":384},{"text":"And then I do a bunch of insertions n different times","width":256},{"text":"And so I want to make sure that I'm not doing that very often","width":128},{"text":"So I'm going to do that same kind of set up where I double the array so it doesn't happen very often.","width":320},{"text":"It's sort of the same intuition as when we were doing resizing on just regular old arrays, we are going to do the same thing here","width":768},{"text":"Using the table itself","width":128},{"text":"So you would use -- when I need to resize this table I go through I make my new array and then I go through all of the elements that were in my old table and insert them into my new storage.","width":832},{"text":"And then once I'm done I can throw away the old table","width":256},{"text":"The key step here is going to be to rehash everything","width":640},{"text":"From the old table into the new array","width":1344},{"text":"Once I've got that array all made I sort of swap it","width":640},{"text":"I make the array thats got the right number of things in it","width":192},{"text":"I go through all the things I used to have and insert them into this new bigger array","width":256},{"text":"And then I throw away that old array, take ownership of this new array that I've made and now my hash table has been resized","width":384},{"text":"And I can still find everything","width":64},{"text":"If I have to rehash everything so I can relocate them again","width":256},{"text":"Because the mod changed, so their index in the new table is different so I have to make sure that I am rehashing","width":384},{"text":"If I forget to do that I won't find anything after I resize","width":448},{"text":"If we are doing that then what are our running times?","width":448},{"text":"In this first one we are looking at the worst case, so somebody gave you a horrible hash function that does not satisfy the uniform hashing functions, what could happen?","width":960},{"text":"If we are doing an insert, and somebody gave us a horrible hash function whats the worst case running time of an insert?","width":576},{"text":"So as long as the hash function, lets say that our hash function is indeed constant time, and is deterministic, it just is not uniform","width":1088},{"text":"Whats the worst case running time of insertion?","width":192},{"text":"What do I do on an insertion?","width":64},{"text":"On an insertion I take my key, I hash it to some value, I modulo the size, and then I insert into a list","width":640},{"text":"Right it didn't really matter, this is still constant time","width":448},{"text":"But now what if I go to find something?","width":320},{"text":"This could be linear now, if I have a bad hash function, this could be linear","width":256},{"text":"The hash function could chose to put everything in the first cell","width":320},{"text":"Return 0 is your deterministic constant time non uniform hash function","width":256},{"text":"So its just a linked list now","width":256},{"text":"Similarly remove could be linear as well if you have a crappy hash function.","width":320},{"text":"So that assumption that we've got a not crap hash function is really important","width":384},{"text":"if our hash function is really bad everything ends up in the same cell, because it is not uniform and then we can't make any of the arguments that we just made","width":448},{"text":"So that simple uniform hashing function is super important","width":320},{"text":"Lets assume that ","width":192},{"text":"And lets talk about the average case with the expected running time","width":256},{"text":"I'm not talking about worst case running times, I'm talking about the average case","width":320},{"text":"In expectation what is the running time for one of these functions","width":320},{"text":"Insert doesn't really change, it is still const time, it doesn't have any average","width":448},{"text":"But what about find now?","width":256},{"text":"Find is O(1)* now","width":384},{"text":"On average","width":128},{"text":"And the reason for that is I made an argument about the average length of a list","width":320},{"text":"So if I ask you to find a particular key the average length of a list is the load factor which is some constant so I can say that the average case here is constant time","width":576}]