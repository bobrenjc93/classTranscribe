[{"text":"The question was \"why are we returning a book reference rather than just void\".","width":768},{"text":"And the answer to that is the same answer we had for the assignment operator where we could do things like \"a=b=c\". So we had to return a reference because that kind of thing is syntactically valid in C++","width":964},{"text":"The same thing should be true for operator+=","width":256},{"text":"So if we said something like \"a+=b+=c\".... that should be valid","width":576},{"text":"Unfortunately. We return a reference to the left hand side. For the same reason that you should be able to chain these things together.","width":640},{"text":"If we returned void we couldn't do this, which maybe is fine, but it's sort of counter-intuitive compared to what you can do with existing types.","width":512},{"text":"You can do this with existing types but it ought to be true that your type also returns a reference. But it's not like the compiler says \"you can't do that\". You can do whatever you want.","width":512},{"text":"I can have \"+=\" return an int for all the compiler cares. It just wouldn't make sense when \"bookA+=B\" gives me 4.","width":640},{"text":"So if it should return anything at all, it should be a book reference.","width":384},{"text":"To make it blend in, it should return a book reference","width":448},{"text":"(silence)","width":384},{"text":"Getting rid of the diagram here, because I want to....","width":832},{"text":"Pretty sick of my conversations","width":512},{"text":"I was unhappy about the second double for loop of the += because he was forced to do a deep copy of the strings. But what if we used += with a right hand side that was a temporary?","width":1088},{"text":"Then I don't really need to do that deep copy. Now I know that the right side won't be referred to by anybody","width":448},{"text":"I can make that better right?","width":192},{"text":"If I know that my right side is a temporary, I can actually go ahead and move those strings b/c nobody's going to refer to that anymore","width":448},{"text":"But it may be reasonable to provide an overload for this function that takes an r value reference","width":448},{"text":"Aight because then we know that we can change that last copy there to not do a copy but a move instead","width":1088},{"text":"Then we know that the right hand side is a temporary value and it's fine if we steal things from it because nobody's going to look at it anymore.","width":64},{"text":"So I may also provide an overload for this function that takes a R value reference","width":896},{"text":"-silence-","width":832},{"text":"The one place where I can that overload slightly different or efficient would be here, with = std::move.","width":896},{"text":"-silence-","width":384},{"text":"Only if I know if the right hand is safe to steal from. And I know that it's safe if I'm getting it as an R value reference","width":512},{"text":"If I add another function that is exactly like this one but it takes book& ref, and I change that last to be a std::move, just like the one above it, that can be a little faster.","width":960},{"text":"I only know it's safe if the argument is temporary","width":384},{"text":"If my value is an R value, it's safe to steal from. If it's not an R value, it's not safe to steal from.","width":384},{"text":"-silence-","width":896},{"text":"It depends on the assignment operator that specific class. That class type is a std::string.","width":1216},{"text":"That's going to invoke the operator equals for std::string","width":192},{"text":"However it happens to implement it's operator equals may make the answer different. If string uses copy and swap, then it's probably going to invoke the move constructor for the string object","width":512},{"text":"If the string class doesn't use copy and swap and instead has 2 different overloads one for const ref and one for R value ref, it might not have a move constructor but it will move it for you. It will do whatever the move semantics should be","width":960},{"text":"It depends on the implementation","width":192},{"text":"For most of the classes that we would write, like a PNG, then yes it would invoke the move constructor because it would take it in by value","width":768},{"text":"The important thing to remember there is not \"which constructor is invoked\" but rather it is to recognize that if you give a right hand side that is a std::move of something, you are allowing the system to steal stuff out of the object if it can","width":1216},{"text":"If it doesn't have a move constructor then obviously it won't invoke one since it won't exist so I will still do a copy if it has to. But if it does exist then it will invoke that, which is typically faster","width":640},{"text":"If your class has a faster routine for that","width":256},{"text":"If your class provides a move constructor","width":256},{"text":"When should a class provide a move constructor?","width":448},{"text":"-silence-","width":320},{"text":"If copying is too big, maybe it should provide a move constructor","width":384},{"text":"That's contingent on that it is possible to do something better you can do than the copy. If I had a class with a static stack allocated array of size 1000","width":576},{"text":"Copying that would be expensive. I'm going to add a move constructor","width":256},{"text":"There's nothing I can do that is more efficient there because it's always gonna be part of the class that the array is part of. It's not like a pointer to heap memory. I can't steal the stack array from another object.","width":768},{"text":"It's not possible.","width":64},{"text":"So having a move constructor in that case wouldn't be helpful at all.","width":192},{"text":"If I have a class with a bajillion member variables, and I want to write a move constructor","width":768},{"text":"If they're all on the stack there's nothing more efficient that I can do than just copying those values","width":320},{"text":"If you had to redefine what copying meant","width":448},{"text":"That means you're probably using dynamic memory, heap memory. In which case you probably know a better way to use move than doing a deep copy that's making a new array in the heap","width":896},{"text":"If you know of a way to move your class faster than copying your class, then it makes sense to have a move constructor","width":576},{"text":"If I just have a class with 1000 integers in it in the stack not the heap, there's no way of making anything faster than copying that class.","width":1088},{"text":"When you have dynamic memory you should think about whether it makes sense to implement a move constructor","width":704}]