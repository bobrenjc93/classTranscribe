[{"text":"Ok so declare a temporary assign a in the temporary so this is going to.  Oh so on the line t temp equals a what constructor for t is going to be invoked.  copy constructor.  Why copy constructor?  a is an l value.","width":1728},{"text":"Alright so  when the compiler goes to look for a constructor that takes another t it say ok what is that oh its an l value ok so the only constructor that will apply with the copy constructor so it runs that","width":896},{"text":"Ok so you copy construct a temp we assignment operator a into b we assignment operator b into a we assignment operator temp into b and then we are done","width":1216},{"text":"This is good this is good but it could be better, right?  Right?  How could I make this better, yea using move semantics.  So this is how I would write it is I didn't have access to c++ 11 if I'm working at a company that is only using c++ 03 and doesn't know a thing about move semantics I can't std::move cuz it doesn't exist.  This is how I would write it.  Ok so so this is good but we can make it slightly more efficient.  If t is a type that has defined a move constructor for us.  Ok ","width":2432},{"text":"I'm going to write it now even if t doesn't provide a move constructor.  It will still work but is invoke the copy constructor like before.  So it'll be the same behavior except for if they do provide a move constructor then it will be faster.  So how would I change this to use the move semantics","width":1344},{"text":"Um right  I could call std swap.  How do I do it without calling standard swap.  Cuz standard swap this is how standard swap is going to be implemented.","width":704},{"text":"Alright I'm going to move it over. So I'm going to say t temp is std::move","width":576},{"text":"of a","width":128},{"text":"so now if t has got a move constructor it is going to move the value out of a.  If t doesn't have a move constructor then its just going to copy construct like before.","width":576},{"text":"when we say a equals b.  We going to std::move b this time.  ","width":640},{"text":"Finally b is going to std::move.  So it looks almost the same the only difference is that we are moving stuff around now if we can.","width":1344},{"text":"No. So this is a good point though. He's remembering ok when we wrote that move constructor we sort of initialized ourself to be empty then swapped with the argument.  But we are calling the swap function right?","width":1536},{"text":"Well we are calling a swap function but remember the one we called was a member function that only took one arguement.  So that's a different swap function than this one.  It's not infinitely recursive.","width":832},{"text":"When we call the swap function we just say inside of a class when we say swap other","width":576},{"text":"Yea that is taking 1 argument.  And is a member function.  So that's the same thing as saying this arrow swap other or *this. swap(other).  So that's envoking the member function which is not the same this as a stand alone template function that is not a member of a class.  Alright?","width":1536},{"text":"So its a different swap that we are calling. Yes so the move semantics here mostly matters when type t inside of it has pointers to dynamic memory.  If the type t didn't have any pointers into dynamic memory or no heap whatsoever then a move construction wouldn't be be any faster than a copy because you can't do that shallow copy resource stealing.  So move semantics only matter when you have pointers into dynamic memory.  Points into heap memory.  RIght?","width":3584},{"text":"And then the point here is it doesn't matter where a & b live.  a or b could be on a stack frame somewhere.  a or b could in the heap somewhere.  Its not a & b live it whether a & b have themselves pointers into heap memory. That's the part that matters.  So if the type t inside of it has like a dynamic array or has a two dimensional array of strings then move semantic make sense because you can do something faster than copying it.  You can't do any better than copying over your member variables.  It's not like you can reuse an old member variable from something else.","width":3392},{"text":"But if one of those member variables is a pointer to heap memory then instead of making a deep copy of that heap memory and making a new array and pointing to the new thing.  You can just steal the old array that somebody else was using if you know that person is no longer going to need it.  Which is signalled by it being an r value.","width":1280},{"text":"And the two cases basically the two cases you have to care about are either temporary or something I've explicitly said std::move on","width":640},{"text":"The std::move is doing is saying treat the arguement to std::move as if it was an r value for now.  But only at the call site.  It doesn't change a forever to be an r value.  It just says right here right now pretend a is an r value so then it moves when its constructing temp it can constructs temp by stealing the memory from a and leaving a empty.  And then when I say a is std::move(b) it move assigns into a so it steals the memory associated with b leaving b empty and then when b is std::move temp it moves the memory out of temp and into b leaving temp empty so then when temps destructor is envoked nothing happens so all I've done is effectively swapped the pointers of the a and b.","width":3328},{"text":"std::move on a point is not really going to help you much.  its more you use the more to force a type to be an r value when you constructing a class.  Std::move on a pointer is not going to help you much or its more you use that to force a type to be an r value when you are constructing a class.  and that string over there.  I know has a name I know is an l value pretend its an r value so that I can steal the internals of that thing and then leave the other string empty.","width":1664},{"text":"","width":576}]