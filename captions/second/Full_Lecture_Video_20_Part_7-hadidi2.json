[{"text":"So what's happening here is I'm creating the righthand side, so this is like I've got my stack frame and we're inside of one child remove. So I'm getting another stack frame for operator equal.","width":1408},{"text":"I'm taking my argument by value here. For the copy and swap.","width":512},{"text":"And I'm creating that value from an argument that is std::move subroot's left.","width":384},{"text":"So before my function is even called, before it does anything at all, what I'm going to do is invoke a constructor for a unique pointer from this right hand side argumen.","width":832},{"text":"So I'm going to create a new variable called right hand side.","width":512},{"text":"Which is a unique pointer. And it's being constructed from an r value reference to an existing pointer, subroot's left.","width":704},{"text":"So what do we know that that does?","width":192},{"text":"By move constructing from a unique pointer a from a unique pointer b, what happens? What's true about b at the end of that?","width":768},{"text":"b is left empty and a is pointing at whatever b used to point at. ","width":320},{"text":"So if I'm constructing this right hand side argument, from subroot left, subroot's left should be left null and right hand side should point at the node that I've asked it to. So what I'm going to get is a picture that looks like this.","width":1280},{"text":"Where subroot's left has been left empty IE null, and right hand side has been constructed to point at the same thing that subroot's left used to.","width":960},{"text":"I've just moved the pointer from subroot's left into right hand side.","width":448},{"text":"So now, if you think of what the assignment operator's doing, delete ptr, delete subroot, fine, delete this and we don't accidently delete teh other node because we still have a unique pointer to it. And then we do a std::move from this in here. Or just an assignment actually.","width":1408},{"text":"Does that answer the question? ","width":320},{"text":"This is actually valid and the reason it's valid is sort of that's what you would expect to have happen.","width":640},{"text":"So it's been implemented so that this behavior is indeed valid.","width":320},{"text":"If you were like super concerned, you could do this in a couple lines. You could instead say unique pointer temp is std::move subroot's left. subroot equals std::move temp. and do it in two steps so that you're more comfortable about what's happening here. But the way it's written here is fine.","width":1536},{"text":"What's the other case going to look like?","width":320},{"text":"It's just the same exact thing. Subroot is std::move subroot right.","width":1344},{"text":"Which was the exact same thing, just the child is on the right side now instead of on the left side.","width":384},{"text":"So just jump the pointer down to the child and then, in the processs of doing that assignment, the node that we want to remove is deleted because we're assigning into subroot.","width":896},{"text":"Does that make sense?","width":320},{"text":"If I asked you to write this function on an exam, could you write it? OK, good!","width":512},{"text":"Ok, before we write the two child remove case, I'm going to write a couple helper functions first so that we can assume we've already got the IOP. So we're going to solve the problem of finding the IOP of any node in the tree first. And then we're just going to use that inside of our two child remove. Because we know that we need to have a pointer reference to the IOP when we're doing the two child remove. So let's just think about finding the IOP of the node for now.","width":1728},{"text":"The IOP of a node is the rightmost child of the left subtree.","width":576},{"text":"So I've written two helper functions here. One is the in order predecessor that give you the IOP by reference again. Notice that the return value here is a unique pointer node reference. I've just used trailing return types to help myself not write a nasty return type expression.","width":1152},{"text":"I've also got this rightmost helper function which is also returning a unique pointer reference.","width":384},{"text":"And rightmost should return the rightmost child in the subtree rooted at subroot. So let's write that function first.","width":320},{"text":"And then write what IOP should be. So what should rightmost do? I'm asking you here's a subroot. I've given you a rightmost. Find me the rightmost node in that subtree.","width":832},{"text":"So This is my base case. If there is no more children to the right, and I've asked you to give me the rightmost child, what should you return?","width":960},{"text":"The subroot itself. So my base case is not the empty tree because if I go that far, I can't give you the child anymore. There's no more. The base case for this is going to be when I no longer have a right child pointer. Then I know I was the rightmost node in whatever subtree you asked me for.","width":1152},{"text":"Alternatively, you can think of this recursively. If I ask for the rightmost child in a tree, the only tree you can answer that question for is a one node tree. In which case it's just the node that you're at.","width":1280},{"text":"It doesn't matter what it has on it's left because even if it has stuff on the left, that's not the rightmost. So the base case is just going to be return subroot.","width":832},{"text":"What's the recursive case?","width":448},{"text":"The rightmost of subroot's right. So if I don't hit this base case, I know I have a valid right pointer so that means that that thing-I'm going to ask that subtree to find me the rightmost node in that subtree. And the rightmost node in my right subtree is the rightmost node in my subtree.","width":1216},{"text":"So this recursion bubbles out. It's going to be return rightmost.","width":448},{"text":"Of subroot right.","width":320}]