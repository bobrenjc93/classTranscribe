[{"text":"You can't really make that a whole lot faster than just copying the three integers right?","width":320},{"text":"There's nothing to steal, the three integers were baked into the class itself.","width":329},{"text":"So providing a move constructor for that was sort of pointless because there's nothing... You couldn't make it faster.","width":360},{"text":"You provide a move constructor when you can actually make the thing faster.","width":238},{"text":"So, think of your linked list class, you could make move construction a hell of a lot faster than you can make copy construction.","width":465},{"text":"Copy constructing a list you have to go through a new node for every old node in the old thing, and copy over all those values, right.","width":454},{"text":"So that was going to be really slow and really sort of costly.","width":299},{"text":"If I'm just moving a list, just steal the pointer right?","width":176},{"text":"Steal a head pointer, steal a tail pointer, steal the size, right?","width":192},{"text":"And you're done.","width":64},{"text":"So I can make that vastly faster, right?","width":113},{"text":"That was constant time versus linear time to copy the list. ","width":147},{"text":"I can move the list in constant time, I can copy the list in linear time.","width":249},{"text":"","width":4},{"text":"Because moving doesn't actually touch the data it just steals pointers and stuff. ","width":209},{"text":"But the actual data is just still sitting there. ","width":167},{"text":"Same thing was true for you dynamic array class, or your circular array class. ","width":281},{"text":"If I've got a pointer to some heap allocated array, I can steal that in constant time, I can't copy it in constant time. ","width":478},{"text":"So, when I'm in a scenario where I can actually do a stealing operation faster, that's probably when I care about writing a move construct.","width":704},{"text":"So we've talked about constructors and we've talked about assignment, right.","width":192},{"text":"So, our assignment operators were used when I said stuff like a equals b, when a already existed and b already existed right.","width":593},{"text":"So, remember that weirdness where if I say....","width":196},{"text":"I guess I probably have an example here... Do I? ","width":236},{"text":"Uh... Yeah.","width":47},{"text":"So, here.... is that an assignment operator call?","width":640},{"text":"No. ","width":56},{"text":"This is the weird thing.","width":119},{"text":"Remember that if you're declaring the variable and assigning into it at the same step, that's not an assignment operator that's a constructor.","width":454},{"text":"And the reason that I harped on that is because people would try and test their assignment operator like this and oh it's working, and it didn't even call your assignment operator.","width":512},{"text":"This is a constructor.","width":63},{"text":"This is the same thing as saying book a, b.","width":492},{"text":"Those two things mean the same thing.","width":220},{"text":"So the assignment operator is called when you have on the left hand side an object that was already constructed and on the right hand side you have some object.","width":640},{"text":"So you have to be assigning into a variable that already exists, that has already been constructed, already has values in it.","width":384},{"text":"Which is naturally you do this all the time.","width":128},{"text":"You say x equals y, all the time, that's a reasonable thing to do.","width":192},{"text":"And so again from the same reasons that we needed to provide a copy constructor when our class was sort of non-trivial, we needed to provide an assignment operator when our class is non-trivial.","width":596},{"text":"Because the default version of assignment is not going to work anymore, we're going to leak memory, we're going to have pointers pointing at the same thing, and all kinds of horrible, terrible things happen.","width":576},{"text":"So we need to redefine what it means to do assignment in the cases where I would need to redefine what it means to copy.","width":832},{"text":"So, if I was.... Let's skip this thing, and finish off with this. ","width":448},{"text":"You should be able to rattle that off for any type now at this point.","width":256},{"text":"So, I want to write an assignment operator, I want that assignment operator to give me the strong exception safety guarantee, and I'm writing it for class books.","width":576},{"text":"So, what should this thing return?","width":512},{"text":"Reference. ","width":108},{"text":"Should return a book reference. ","width":64},{"text":"Why a reference?","width":280},{"text":"So I'm returning a book so I can chain assignment, I'm returning a book reference so I don't do a copy for every one of those equals.","width":512},{"text":"So if I say a equals b equals c equals d, I don't want to copy the book for every equals, I want to just keep passing down the same one by reference, so I'm returning by reference here.","width":522},{"text":"What is my argument?","width":461},{"text":"And, why is it by value?","width":189},{"text":"It must be by value if I'm doing a copy and swap, why is it by value?","width":258},{"text":"Yes?","width":171},{"text":"Right, the goal here of the copy and swap is....","width":156},{"text":"I mean the goal of the assignment operator right?","width":108},{"text":"Is to make an independent copy of whatever the right hand side was, and make sure that any values that the current object already had, are destroyed.","width":640},{"text":"But if I don't do that step, I leak all the stuff the current object's got.","width":256},{"text":"So I have to make sure the current object is emptied out before I copy all the values over from the other thing. ","width":335},{"text":"So what I'm doing here is passing it by value, meaning that I'm going to get an independent copy either made by a copy construction or by a move construction, into the stack frame for this operator equals, at which point I can just swap my values with it, and just return. ","width":1053},{"text":"When I return the local variable right hand side will go away, and so if I swap with it, all of my values are in that temporary, so that temporary's destructor will clean up my values.","width":605},{"text":"And since I swapped with the argument, I know have all the things that used to be in the argument.","width":279},{"text":"So I've done this copy first, swap with it, and then when I return my old values are cleaned up, I have the values, I don't have to worry about exceptions because when I'm doing the pass by value is where the exception might happen, doing the swap is not going to through an exception.","width":931},{"text":"But copying might if I run out of memory, or some type inside of it, one of the sub-types threw an exception or whatever.","width":384},{"text":"So might happen when I'm copying, it's not going to happen when I'm doing a swap.","width":232},{"text":"So, if I copy first, do the swap, return, then I'm sort of guaranteed the strong exception safety of this function.","width":741},{"text":"This would just look like that. ","width":430},{"text":"This is assuming I've got a swap helper function, if I don't you'll have to write one, but it's probably simple, it's just swapping some pointers around. ","width":439},{"text":"There's a question in the way back. ","width":353},{"text":"Number 7 part 2, this one?","width":352},{"text":"Okay, so, the question is on this line. ","width":478},{"text":"Whether that is a copy construction, a move construction or an operator equals.","width":367},{"text":"And I'm not going to touch at all here on return value optimization, because the answer could be it's none.","width":362},{"text":"Because the compiler might optimize it out.","width":128},{"text":"So, I'm ignoring return value optimization. ","width":158},{"text":"So, here, I'm calling a make book function which makes a book on its stack frame, does some stuff to it and returns it.","width":448}]