[{"text":"O(1)","width":256},{"text":"because they gave you the list","width":192},{"text":"its's already unsorted","width":64},{"text":"no work","width":128},{"text":"return right","width":64},{"text":"so this is constant","width":128},{"text":"the key was in place, i'm saying use this list for your key","width":576},{"text":"or for your priority queue","width":64},{"text":"use this lsit for your priority queue, i don't care about it anymore","width":320},{"text":"so you don't have to copy, you can just steal it","width":128},{"text":"so wait if i'm using the constant time peek trick","width":832},{"text":"this can't be constant right?","width":192},{"text":"I have to find the smallest thing","width":64},{"text":"so this implementation changes depending or not if you're being clever with the peek or not","width":320},{"text":"if i do this","width":384},{"text":"where the upper will be not using peek trick lower will be using it","width":384},{"text":"not using the peek trick is going to be linear time here but constant to build in place","width":384},{"text":"using the peek trick","width":128},{"text":"is constant time to peek but now i have to locate and set that pointer when i'm building it in place","width":448},{"text":"now be careful with your tricks","width":640},{"text":"so if you really care about your peek performance being constant time","width":384},{"text":"then maybe you do this","width":128},{"text":"but at the cost of having a linear time building","width":320},{"text":"i'm not sure how that will give you constant time","width":2240},{"text":"i'm not sure how that will give you constant random access","width":1280},{"text":"you still got these pointers flying around","width":384},{"text":"so finally","width":256},{"text":"how long does it take me if I give you an array","width":256},{"text":"build me a heap in place with this array","width":256},{"text":"how long does that take?","width":192},{"text":"i.e did you watch the prelecture","width":384},{"text":"what was the running time of the best build heap algorithm","width":192},{"text":"O(N)","width":128},{"text":"you not have to do all the work of the sort in order to get a heap","width":896},{"text":"nlogn tells basically you're doing the amount of work that's required to do a full sort of the data","width":320},{"text":"because it can sort in nlogn time","width":256},{"text":"so if i gave you a random array and said make this a heap you can sort it in nlogn time","width":256},{"text":"but you can do better than that","width":320},{"text":"you don't actually need the thing to be sorted","width":64},{"text":"you just need to have the heap property","width":128},{"text":"which is looser than being sorted","width":128},{"text":"if you look at the array of the heap, they are not fully sorted","width":256},{"text":"they got this weird notion of being sorted which is the heap property","width":256},{"text":"but they are not sorted","width":64},{"text":"so we can actually do better than nlogn time, let's prove it","width":320},{"text":"suppose i give you an array containing elements that have some definition of priority","width":704},{"text":"how could you construct a heap in place using this array?","width":384},{"text":"there are several different choices, one of them is the right one","width":320},{"text":"rest of them are not","width":128},{"text":"so one option i could is just sort the data like i was saying if you take a sorted array and and you look at it, that's a heap","width":448},{"text":"if you think about it it's laid out in level order","width":448},{"text":"it's gonna go 1,2,3,4,5,6,7,8,9,10","width":256},{"text":"it's going to be a heap","width":192},{"text":"i could just alright sort the array","width":64},{"text":"what's the fastest algorithm you know about sorting an array?","width":256},{"text":"nlogn","width":192},{"text":"or if you're clever, you'll use this sorting algorithm that we might get to today","width":640},{"text":"although it would be really silly because it's going to evolve what we're going to talk about","width":576},{"text":"so you can sort the data in nlogn time","width":192},{"text":"can we do better than that?","width":256},{"text":"how could i build a heap using heapify up?","width":448},{"text":"right so this is the top-down aproach","width":576},{"text":"i say that ok you given me some random tree","width":256},{"text":"some random complete tree","width":512},{"text":"whose elements are probably not a heap4","width":192},{"text":"so what i'm going to do is incrementally make this be a heap","width":256},{"text":"by sort of pretending to do an insertion on to an empty heap repeatedly","width":320},{"text":"this is effectively what this is doing","width":64},{"text":"if i heapify up, continuously","width":256},{"text":"if i start from the root, i can say ok","width":64},{"text":"i know that the root is going to be a heap","width":256},{"text":"if i ignore the children below it","width":192},{"text":"a tree with one node is a heap i'm done","width":128},{"text":"so then i say ok, what if i look at just this part of the tree?","width":256},{"text":"well i know that the root is a heap","width":256},{"text":"so the only thing that could be out of place is if I'm only considering these two nodeswould be the left node","width":384},{"text":"so i'll heapify up the left node","width":128},{"text":"if it needs to move up it will, if it doesn't it will stay where it's at","width":128},{"text":"and then i know that those two nodes are a heap","width":320},{"text":"then i can say what about this tree?","width":320},{"text":"well again, if ignore the right node that I just added","width":256},{"text":"the left two nodes are in fact a heap","width":128},{"text":"so the only thing that could be in the wrong spot is the rightmost node here","width":256},{"text":"so i'm going to check and see if i need to move up by calling heapify up","width":256}]