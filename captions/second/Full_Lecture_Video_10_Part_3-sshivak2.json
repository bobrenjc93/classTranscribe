[{"text":"So, the same function can behave differently depending on programatic circumstances.","width":512.3999999761581},{"text":"So, here the programatic circumstances are what is the concrete type of the thing pointed to by obj and the polymorphic part is calling foo().","width":622.3999999761581},{"text":"Depending on whether it points actually at an A or at a B or at a D which derives from A, depending on what it actually points at we are calling a different functions, we have different behaviour depending on the runtime setup of the code. ","width":934.3999999761581},{"text":"So, this is runtime polymorphism. Polymorph meaning many forms, so, this function takes many different forms, and we pick the right one at runtime depending what the current state of the system is.","width":832.3999999761581},{"text":"What thing that obj points at? What is the concrete type, that's how we choose which function to call.","width":384.39999997615814},{"text":"If we didn't have virtual function calls, we could not achieve runtime polymorphism. It would not be possible.","width":512.3999999761581},{"text":"But if we just had inheritance, but we didn't have virtual functions, we could have an A pointer to a B, but if we called obj->foo(), if we didn't have virtual, it would call A's function, because it fall back to static look up. ","width":859.3999999761581},{"text":"We need the virtual in order to achieve runtime polymorphism. Otherwise it's just going to look at what is the base type of the pointer and call that function. We have to have the virtual in order to achieve runtime polymorphism.","width":704.3999999761581},{"text":"Okay?","width":256.39999997615814},{"text":"Good, yes? ... is it A? Good question? is it dynamic or static?","width":1152.3999999761581},{"text":"Dynamic, technically. It just doesn't do anything interesting.  ","width":268.39999997615814},{"text":"It's says okay, I'm calling function foo() through an A pointer, so I'm going to go to class A and I'm going to look for function called foo(). I find one. Oh, but it's virtual. So, I need to go figure out what is the actual thing that I'm pointing at? What's is it's concrete type. It's an A. look in A, look for foo() again, find it, call it.","width":1088.3999999761581},{"text":"Even though the pointer and pointee are the same exact type, there's still this tiny little bit of overhead to figure out what the right function is to call.","width":640.3999999761581},{"text":"If you're curious, and want to learn about compilers, this is implemented as a v-table, so you can go google v-table and you can figure out how exactly the compiler makes this work.","width":640.3999999761581},{"text":"Does that make sense. That's kind of crucial for understanding object oriented programming in polymorphism. Yeah?... ","width":626.3999999761581},{"text":"What this code actually do? So, which one? This one? So, to call a A, A's foo()? Oh, it's stops at the first. It only does the.. the dynamic look up happens once and then once it finds a single function that works, it's done.","width":1275.3999999761581},{"text":"Okay. Lets move on, hopefully we figured out what was going on here.","width":621.3999999761581},{"text":"I think I can get it all to fit on this screen... no, I can't","width":512.3999999761581},{"text":"Actually the header file is for the obelisk and basilisk aren't that important, so we can just scroll down here. ","width":576.3999999761581},{"text":"Okay, so what do I have here? What is monolith?","width":576.3999999761581},{"text":"Monolith is a obelisk, monolith is a public obelisk. right? is a. So, what does mean about monolith? what does mean about the memory structure for monolith? ","width":1216.3999999761581},{"text":"It inherits functions and data from the obelisk class, which means that the monolith has space for an obelisk, inside of it. And after the obelisk, it has it's own monolith stuff. right?","width":1085.3999999761581},{"text":"What is the monolith stuff. So, the obelisk is boring, there's no data members inside of it. But what about the monolith class itself? What is contained inside of a monolith?","width":576.3999999761581},{"text":"A basilisk, right? with template parameter int; so , there were questions about how do I have a template class member of an existing class, this is how. Sort of what you'd expect. okay?","width":896.3999999761581},{"text":"So, that means that the memory layout for a monolith is going to look like there's an obelisk first, cause it inherits all the stuff from obelisk, so it is an obelisk, that has at the.. the start of the object is going to be an obelisk. ","width":852.3999999761581},{"text":"And then underneath that, there's going to be space for it's own private member variables, which happens to be a basilisk. So, it has space for a basilisk, okay?","width":576.3999999761581},{"text":"What happens when I construct one. Let's look at that case first and then we'll have figure out, untangle, what happens when we return and the destructor's invoked. What about construction?","width":704.3999999761581},{"text":"So, I make a monolith? What happens first? What is the very first function that's call when I make a monolith? is it the monolith constructor? is it the obelisk constructor? or is it the basilisk constructor?","width":832.3999999761581},{"text":"Obelisk! I have to invoke... since I haven't invoked in the initialiser list explicitly any constructors for the basilisk, the compiler automatically  invokes the default constructor for basilisk. And it has to happen first, because before you can set up the monolith, you need to have the obelisk. ","width":1310.3999999761581},{"text":"Cause the monolith is an obelisk and then it adds stuff to it, so it has to do the obelisk constructor first, so we get: \"stone\" first, and now what?","width":1280.3999999761581},{"text":"Do we get the monolith or the basilisk constructor? The Basilisk constructor. ","width":510.39999997615814},{"text":"Before we can start running the code for our constructor, we need to have made all the member variables. ","width":448.39999997615814},{"text":"So, we actually invoked the basilisk constructor here. So we get: \"hisssss\".","width":384.39999997615814},{"text":"And now we, invoke the monolith constructor. ","width":576.3999999761581},{"text":"Easy way to keep that straight in your head is to think about what happens  in your initialiser list, right?","width":437.39999997615814},{"text":"So if you have inheritance and you need to invoke the constructor the base class, it goes in your initialiser list, and it goes first in the initialiser list. So, that means that's what happens first.","width":561.3999999761581},{"text":"Then, if you needed to set up your member variables, those go next. So that means that the member variable constructors are invoked and then finally, only after that's done do you go inside of the method that you provided for the monolith constructor. Right?","width":868.3999999761581},{"text":"So, the ordering is going to be base classes, data members, yourself.","width":384.39999997615814}]