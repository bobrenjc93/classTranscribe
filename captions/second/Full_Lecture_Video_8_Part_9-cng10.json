[{"text":"","width":128},{"text":"possible call the fly() method of bird if you've got a swallow ","width":384},{"text":"","width":64},{"text":"yes? I think you can do it if you explicitly say like s.bird::fly()","width":640},{"text":"don't do that","width":128},{"text":"I think you can do it, but don't","width":192},{"text":"no really good reason to","width":128},{"text":"","width":448},{"text":"","width":64},{"text":"ok","width":64},{"text":"yeah. This is a good question. So ok. ","width":256},{"text":"could I do bird b = std::move(s)?","width":192},{"text":"so now I'm gonna take a bird r value reference","width":320},{"text":"when I'm constructing rather than","width":192},{"text":"rather than a const ","width":192},{"text":"","width":64},{"text":"still work. the r value reference is still a reference to a bird. you can still have a reference","width":512},{"text":"to the base kind of the derived class. that still works","width":256},{"text":"the weirdness is that it's not like","width":128},{"text":"it won't leave like if swallow have an extra dynamic memory, the bird move constructor doesn't know a thing about that ","width":512},{"text":"so it can only move over the bird dynamic memory, and then it still gonna leave the swallow part there","width":384},{"text":"so it might be fine but it's a little weird because it's not like... It didn't really leave the argument totally empty","width":448},{"text":"it left empty the things that are common to bird, but for the swallow part, I don't know","width":320},{"text":"I don't know what it did","width":64},{"text":"this kind of thing is generally not a good idea","width":256},{"text":"this is most of the time if we write something like this you have a bug and it slices. It's called the slicing bug","width":448},{"text":"'cause you've taken a derived class assigned into a base class and you lost everthing that made that dervied class","width":512},{"text":"what it was, right","width":64},{"text":"now you are left with just a bird. It's probably not what you meant ","width":256},{"text":"ok. so then if I call... If I've done this construction and I call b.fly()","width":576},{"text":"what method is called?","width":192},{"text":"bird's fly() right? this is again","width":128},{"text":"this is again static dispatch because I'm not going through a reference or pointer here. I'm just going through a value type and it's gonna invoke the bird part","width":640},{"text":"if I want this to invoke the swallow's fly() method, how could I change the code? to do that?","width":960},{"text":"in other words, how do i get this to actually do dynamic dispatch?","width":384},{"text":"right. I could declare as a swallow. swallow b = that. so then copy construct the swallow and then now it worked","width":512},{"text":"how do I do that using dynamic dispatch?","width":256},{"text":"Yeah. I have to go through a pointer, so how would i change? so i'm gonna say bird","width":384},{"text":"pointer b2 is what ?","width":256},{"text":"yeah I could do &s","width":384},{"text":"","width":128},{"text":"and then how would I invoke fly() then?","width":256},{"text":"yeah arrow operator ","width":64},{"text":"b2 -> fly()","width":192},{"text":"","width":192},{"text":"now i'm going through a pointer","width":192},{"text":"so now if fly() is virtual then i will invoke","width":448},{"text":"the appropriate derived class fly() function, so I'm going to look and say ok ","width":384},{"text":"is fly() virtual? yes, fly() is virtual, ok","width":256},{"text":"so then what is the actual type to the thing that i'm pointing to?","width":192},{"text":"oh, it's a swallow, so i'm going to invoke","width":192},{"text":"swallow's fly()","width":384},{"text":"","width":384},{"text":"we will stop here","width":128},{"text":"","width":13248}]