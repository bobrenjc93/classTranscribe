[{"text":"nothing","width":704},{"text":"that's a really good point","width":64},{"text":"so suppose insert a 9, then i want to insert 10","width":448},{"text":"now i need to resize, based on amortized analysis, how big the array i'm gonna allocate?","width":448},{"text":"right,twice the size","width":256},{"text":"anything smaller than that won't pass banker's method test","width":448},{"text":"and we can't divide by n get something looks constant. we want that amortize to a constatnt","width":384},{"text":"so we must double the size of array when it's full","width":192},{"text":"ok fine, we could double it","width":384},{"text":"(drawing)","width":704},{"text":"that's gonna have 12 things and just copy cells","width":1280},{"text":"if i did that, front is there, back is there, why is that a problem?","width":896},{"text":"if i push 10, what happens?","width":448},{"text":"how could we avoid that?","width":1024},{"text":"instead of copying straight down, start at \"front\" to the \"end\"","width":2432},{"text":"and then i just push 10","width":192},{"text":"now the front is here, back is here","width":448},{"text":"push 11 is easy","width":256},{"text":"use this wrap around need to be careful regrading resize to make sure put front at index 0","width":960},{"text":"after the resize, you want to make sure there are room after the array","width":512},{"text":"front and back shouldn't be together after the resize\\","width":448},{"text":"make sure there are lots of buffer room","width":320},{"text":"it's just easier to stick at 0","width":768},{"text":"that's what i mean for best implementation","width":832},{"text":"if you're using array based queue, the best implementation is to wrap around","width":832},{"text":"maintain O(1) amortized","width":256},{"text":"O(1) amortized of push","width":256},{"text":"that's the best array based implementation of queue","width":192},{"text":"when i said best, you are free to use the modulo trick","width":384},{"text":"to make sure the implementation is efficient","width":128},{"text":"using vector is not a smart choice","width":384},{"text":"a little bit more comfort than that","width":320},{"text":"nothing","width":384},{"text":"that's run with array base implementation","width":256},{"text":"what's the running time of push?","width":256},{"text":"amortized constant","width":704},{"text":"worse case O(n)","width":128},{"text":"on average amortized constant","width":256},{"text":"i'll say o(1)*","width":256},{"text":"that's good for array","width":192},{"text":"nothing","width":320},{"text":"what about pop?","width":128},{"text":"how long does pop take for this array?","width":128},{"text":"constant why?","width":192},{"text":"nothing","width":192},{"text":"i just increment my index and maybe wrap around if i have to.","width":192},{"text":"but this is amortized constant or just constant?","width":704},{"text":"just constant if i'm not downsizing","width":192},{"text":"if i'm resizing then it's amortized ","width":576},{"text":"just not worry about it getting bigger","width":256},{"text":"then it's just constant time, even the worst case","width":384},{"text":"then peak. what does peak do?","width":384},{"text":"see what's gonna come off. how long does it take?","width":192},{"text":"constant.","width":768},{"text":"not amortized constant, just constant","width":192},{"text":"just an array look up","width":128},{"text":"nothing depends on the length of array or things in the queue","width":320},{"text":"so that's one implementation","width":320}]