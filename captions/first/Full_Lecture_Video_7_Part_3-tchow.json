[{"text":"So, i have thrown pthread_exit at you, pthread_join, pthread_cancel, etc","width":512},{"text":"This is an exposure to the words in the vernacular, this stuff is not going to sink until you play with it","width":384},{"text":"So, i encode to play a lot with these things and to write little programs and see what happens","width":384},{"text":"Okay, if we don't call pthread_join on a thread, we get a resource leak","width":640},{"text":"And eventually","width":256},{"text":"We wouldn't be able to make anymore threads","width":192},{"text":"We can't reuse the same memory address from the original stack","width":448},{"text":"We are still hanging on to the exit value so we are using up more memory","width":512},{"text":"Okay so the next thing","width":512},{"text":"Take a look at this kind of typical kind of code here","width":384},{"text":"And the...this..something wrong with it","width":448},{"text":"What question is: What?","width":192},{"text":"And how could we fix it? How could we make it valid?","width":192},{"text":"Now your first instinct might be .. HOLD ON IT TAKES A VOID STAR POINTER","width":256},{"text":"That's okay","width":64},{"text":"All i'm doing is passing in a pointer","width":192},{"text":"To start","width":128},{"text":"So that..","width":192},{"text":"My new thread can read a value","width":128},{"text":"Presumably, this 42","width":128},{"text":"So, what do you think might be wrong with that?","width":384},{"text":"Just take a moment to talk it over with your neighbors or neighbor and see how we might fix it","width":448},{"text":"I'll walk around in case you got any questions","width":192},{"text":"What did your neighbor say?","width":6336},{"text":"What did YOUR neighbor say?","width":128},{"text":"*whisper from student*  - It was out of scope","width":64},{"text":"Ok we got a scope problem","width":192},{"text":"Yeah, so, first of all there is no security","width":320},{"text":"It's okay for one thread to access another thread's stack, it's not like we're going to get a segmentation fault","width":512},{"text":"The hardware doesn't know or doesn't care two threads are stomping over each other's stacks","width":576},{"text":"But we do have a scoping problem","width":192},{"text":"And it's this: we're passing in the address of start","width":320},{"text":"And start, as we know, lives on the stack","width":256},{"text":"How long is that address going to be valid for?","width":192},{"text":"Answer: Not very long, we're about to return from this function","width":320},{"text":"So, when will my funct start?","width":256},{"text":"Answer: I don't know, it's up to the kernel to eventually decide get around this other thread","width":768},{"text":"Maybe we'll put this first thread on pause beforehand and give pro to the new thread","width":192},{"text":"Or maybe this new thread will start much later on .. 100 milliseconds time","width":384},{"text":"By which point, what will be at this particular address?","width":320},{"text":"Could be anything right?","width":128},{"text":"It could be our original value, it could be being reused by a completely different function at this point","width":320},{"text":"So our problem is with time","width":192},{"text":"Our problem is that we gave the address something and that variable is no longer in scope","width":384},{"text":"Alright, how can we fix this?","width":128},{"text":"Well","width":128},{"text":"One trick is to say: I'm going to put this magic word static in here","width":384},{"text":"And if I do that, it's no longer an automatic variable","width":128},{"text":"It lives just once as a global variable inside my whole process","width":320},{"text":"But that is pretty heavy handed","width":576},{"text":"Alright, now I only use this start variable and I better keep its value until i'm sure another thread is run","width":576},{"text":"How else can we fix it? We could use malloc()","width":512},{"text":"And allocate some memory in the heap","width":384},{"text":"We would have run into the same problem if we immediately called free","width":384},{"text":"In this thread","width":192},{"text":"Because we would have created some heap memory","width":128},{"text":"Passed a pointer to it and immediately freed it. OH NO WHOOPS","width":320},{"text":"I didn't give my new thread any time to actually read that memory","width":320},{"text":"So if you do use malloc() ","width":192},{"text":"Don't immediately free it, instead..","width":192},{"text":"Let this function","width":192},{"text":"Free it after it runs","width":256},{"text":"We thread can create heap memory and another thread can actually free it","width":256},{"text":"That's totally fine, they all live inside the same process","width":192},{"text":"And there's one heap","width":192},{"text":"I think another way this might be valid is before we turning","width":576},{"text":"We could call pthread_join","width":128},{"text":"On the thread","width":256},{"text":"If we did that, we know that the new thread that is going to run my funct will actually finish before this function returns","width":832},{"text":"So we've solved our timing problem","width":128},{"text":"We've made sure that we don't finish that this variable doesn't go out of scope","width":384},{"text":"Until the other thread has finished","width":192},{"text":"We have just encapsulated from a time point of view","width":192},{"text":"This running time of this other function and made sure that the running is within the scope of this start thread's function","width":576}]