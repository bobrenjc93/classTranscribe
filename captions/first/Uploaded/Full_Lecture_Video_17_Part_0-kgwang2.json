[{"text":"So good morning ladies and gentlemen and welcome to another exciting episode of CS 241","width":768},{"text":"...the Dining Philosopher's Code Edition!","width":448},{"text":"Alright, are you ready for some synchronization?","width":192},{"text":"Okay, so, here we go. What we're gonna do today is we're gonna talk about dining philosopher's, we're gonna look at what makes a good dining philosopher's solution, we're gonna look at what makes a bad dining philosopher's solution, even if you find it on the internet, it's probably wrong.","width":448},{"text":"We will also","width":256},{"text":"...make a fat wallet, and we'll see about that in a little bit. Also, if you're looking for your exam script because you forgot to put your netid or something else on it, I've got them all in the corner over there, so you're welcome to come down anytime during lecture or after lecture to help find your exam script in that pile.","width":1088},{"text":"Okay, and, so let's get started. Right, so.","width":192},{"text":"Dining philosopher's... Hello! Welcome to lecture, what's dining philosopher's about?","width":384},{"text":"Okay, thank you, yes! It's a resource problem! It's about we've got some philosopher's sitting at a table and sometimes they want to be inside a critical section or do something and they gotta try and grab their fork, or, if you prefer, chopstick...","width":1216},{"text":"Doesn't really matter to the actual conceptual problem, right?","width":128},{"text":"We can deal with abstraction here...","width":128},{"text":"And our problem is that we might run into deadlock because they want to grab two at the same time, and we've talked about deadlock. What are the four necessary and sufficient conditions for deadlock? Give me one...","width":768},{"text":"You don't know. Okay, good answer! Alright, give me another one:","width":256},{"text":"Circular wait! Thank you, yes! What is circular wait?","width":256},{"text":"Okay, yes, it's from they're spinning around really fast here... no, no, yes, thank you! Yes, correct. It's when we have a set of processes where there's a cycle in the dependency graph, where one has to wait for the next one wait for the next... Okay, give me another one!","width":1024},{"text":"No preemption! What do you mean by that?","width":192},{"text":"Thank you! Yes, correct.","width":64},{"text":"Okay, so what do you mean by no preemption?","width":256},{"text":"Yes! Correct, okay great!","width":128},{"text":"Correct, you can, we're not gonna interrupt a process once it's got a lock","width":448},{"text":"Okay, right, it's not like you've heard now. Like, yeah okay","width":192},{"text":"Okay","width":64},{"text":"Right, so we've done two. Any others?","width":256},{"text":"Mutual exclusion! What do you mean by that?","width":256},{"text":"Okay, yeah, we're both talking at the same time, yes!","width":256},{"text":"Right, so, mutual exclusion: that once a resource has a lock, no one else can use that lock at the same time.","width":640},{"text":"Okay, so obviously with our gardener tools example, if the gardeners choose to be nice and actually share tools at the same time, there's no problem! It's only when they say, \"no, I want exclusive access to this!\" Because there we have a possibility.","width":704},{"text":"Right, have we forgotten anything?","width":128},{"text":"Hold and wait, yes!","width":320},{"text":"I need to be holding onto at least one resource, and wanted to get another one, in order to get a circular dependency.","width":448},{"text":"If I only had one resource, that's not a problem. It's only when I try to grab two.","width":448},{"text":"Right, so, you see dining philosopher's conceptually, this was used as basically as a academic discussion problem for many, many papers because it's simple to describe, it encapsulates a lot of the problems of asynchronous systems, systems trying to do things at the same time.","width":1216},{"text":"And we can look at different solutions and say why they suck.","width":320},{"text":"And analyze what the problem with them is. And do all philosophers get to eat the same amount? Could it be, for example, the last philosopher does eat, there's no possibility for deadlock, but maybe when we actually run an experiment we discover that they're less likely to be able to get both forks. So, there's actually quite a lot of literature about dining philosopher's.","width":1216},{"text":"And, it would be embarrassing to be a computer scientist and not know about this.","width":320},{"text":"And not know about dining philosopher's.","width":128},{"text":"Hence, we teach you at UIUC.","width":64},{"text":"So let's actually today look at some code, and that's what I've got in front of you right now.","width":384},{"text":"Because I don't know about you, but being a recovering physicist, you know, I like to experiment with stuff and play with stuff.","width":512},{"text":"Okay, overhead, let's start off with this...","width":128},{"text":"Actually build things, and kind of kick them until they don't work.","width":256},{"text":"You know, standard kind of experimental physics stuff, right? We like to, just, play with things and see what happens.","width":448},{"text":"So, I thought okay, let's build dining philosopher's and then see what happens, and you can download this stuff from the web.","width":384},{"text":"And so here's how we might start:","width":128},{"text":"Right, I need to conceptualize each philosopher and so I'm going to give them a name, there will be a thread associated with each philosopher,","width":640},{"text":"and whether they've failed or not to pick up their two forks, or whether they've managed to lock both mutexes.","width":576},{"text":"Okay, so, here's our struct. Why do we do typedef? Because I don't wanna have to write \"struct philosopher\" all the time, so,","width":384},{"text":"so, here's how we read this, we say here look, this is the actual type, I'm defining inside here,","width":320},{"text":"and here's the alias, \"Philosopher.\"","width":128},{"text":"Then I have a global flag \"running\"; so at some point, I want to stop my program.","width":256},{"text":"And if we spin down to the bottom of this code, here's the plan: right, we're gonna sleep for 40 seconds in our main thread, then we change \"running\" to zero,","width":832},{"text":"and if everything has worked okay, then at some point, our philosophers won't have deadlocked, and they will escape their loop","width":448},{"text":"and we'll be able to finish.","width":128},{"text":"So, then we can call \"pthread_join\" on all of them, and exit.","width":320},{"text":"Oops, I'm sorry, exit down here with \"return 0\".","width":192},{"text":"If we couldn't join on them, for whatever reason, if they failed somehow, then we'll know about it at this loop here, so we can find out whether our solution is good or not.","width":576},{"text":"Okay, let's check that those mutex locks really were initialized...","width":384},{"text":"Okay, so, here let's go back and have a look at the top of the code... where is it...","width":384},{"text":"Okay, so we've got our \"nameList\",","width":256},{"text":"we've got all of our forks,","width":128},{"text":"so, we're actually gonna define our forks as automatic variables inside our main method","width":448},{"text":"that means we cannot use this static initializer, we better call \"pthread_mutex_init\" here because the mutexes are actually on the stack now.","width":704},{"text":"Okay, so now let's pass in the address of each fork","width":256},{"text":"there's no special options we need to set today, and oh look how robust this code is: it even checks the return value to see if it failed. Right, so if we get past here, we know for sure that all those mutex locks have been initialized.","width":960},{"text":"Now it's time to set up each philosopher.","width":128},{"text":"So, each philosopher just has a pointer to a left and right fork.","width":448},{"text":"And fortunately, we know about modular arithmetic, so that the very last philosopher, the index 4, will get the 0th fork again because we go 'round, right, so now each philosopher has a left fork and a right fork.","width":1152},{"text":"And the last thing we can do with a philosopher is stop them! We've got a \"Philosophunction\" called \"Phil\",","width":448},{"text":"which we're gonna run and we give it a pointer to our struct.","width":384},{"text":"So, when you work on the MP, you'll be reusing mutex locks as well, so hopefully this lecture is useful to you, and, oh yeah, that's something else we'll talk about in a little bit.","width":832},{"text":"Right, so that's our main loop; pretty simple, right? Just initialize everything, sleep 40 seconds, and then, just like any dinner party, you have to clean up at the end.","width":704},{"text":"That's not the interesting bit. Here's the interesting bit: page two!","width":320}]