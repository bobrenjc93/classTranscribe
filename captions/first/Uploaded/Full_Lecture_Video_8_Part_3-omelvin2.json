[{"text":"ok, only one of them will win that fight if they happen to try and lock at the same time","width":576},{"text":"one of thems till wins and the other one has to wait","width":128},{"text":"if the other thread comes around and tries to lock it whilst you've got the lock it has to wait","width":512},{"text":"and it keeps going around, yeah, so you take the lock, you increment it and give the lock back","width":640},{"text":"goes around again, yes","width":256},{"text":"yes? [student question]","width":704},{"text":"yeah, it's not a very good program I agree","width":320},{"text":"correct, in some cases the only reason to do parallesism is simply to add it to your resume","width":448},{"text":"it may not actually give you a speed up","width":64},{"text":"and this is an example of that. it's just a silly little example","width":448},{"text":"we'll get to to more complicated examples soon in the course where we talk about multiple threads spawning to read and one thread wanting to write","width":576},{"text":"now, I'm showing you code but I want you to stop for a moment and think about this conceptually","width":448},{"text":"we're talkinga bout threads, but this could apply to real life. this could even apply to processes","width":448},{"text":"now I'm not going to show you any code with processes but there are certainly times when multiple processes are asking the operating system to do things at the same time","width":704},{"text":"'hey I'd like to write to disk at the same time' sorry, I'm not going to let you do that","width":256},{"text":"'oh I want to open a file descriptor at the same time as someone else'","width":128},{"text":"now the operating system has to play these same kinds of tricks to make sure that they data structures are valid whenever a different process tries to read it","width":768},{"text":"so the operating system is full of code like this to make sure that we correctly work with our data structures even when different processes are trying to run, or use them or read them or write to them at the same time","width":1024},{"text":"right, so, the other thing we can do is talk about this pthread_mutex_lock()","width":384},{"text":"yes, it's just a little data structure here pthread_mutex_t but behind it there's additional resources","width":704},{"text":"this elusive thing I just called a spin lock is behind it","width":256},{"text":"and so we're tying up system resources in creating a mutex lock. not much, just a tiny bit","width":320},{"text":"so good C programs will free up a mutex when they've finished using it","width":704},{"text":"OK, so, down here we can call pthread_mutex_destroy() and pass in our mutex","width":960},{"text":"that doesn't do anything to the C variable, but it does say to the pthread library 'hey any resources you've connected to my little C variable can be released and reused'. a question? [student question]","width":1216},{"text":"aha, that's a great question","width":256},{"text":"if one thread locks a mutex, can another thread unlock it?","width":320},{"text":"no","width":128},{"text":"this is where the bathroom analaogy is great. if you lock the bathroom door you don't want anyone else unlockingit","width":448},{"text":"no, the idea of a pthread mutex is that you lock it and then a few nanoseconds later you've finished updating your datastructure and then you're going to unlock it","width":704},{"text":"it's an error for another thread to actually try and unlock it","width":448},{"text":"also with a simple mutex like this unless we give it additional options it's an error to lock it twice","width":640},{"text":"if you try to do that the most likely thing to hapen is that the pthread library will say 'that mutex is locked, I'm just going to sit here until it's unlocked'","width":832},{"text":"but there's a problem becasue you locked it so it's never going to be unlocked, so now you've got code that's hit a deadlock again","width":448},{"text":"that this poor little thread is waiting for itself but it can't continue because it can't execute anymore code because it's waiting for the lock","width":448},{"text":"yes, so don't try to lock it twice","width":128},{"text":"you can give more arguments to pthread mutex locks to say add some more debugging and checking and it will complain to you if you do things like that","width":704},{"text":"but in practice we don't do that because a) it slows our mutex locks down and b) we should just write correct code anyway","width":512},{"text":"right, good luck with that","width":64},{"text":"yes? [student question]","width":384},{"text":"aha, ok, let's suppose the mutex is locked and you try to call destroy","width":384},{"text":"yes, don't do that","width":192},{"text":"it can lead to undefined behavior ","width":192},{"text":"the exciting thing about undefined behavior is that it's undefined! it can do anything! it could start world war three, it could change your facebook status to single","width":768},{"text":"ok that was a joke","width":128},{"text":"um, it could update your tinder profile, whatever","width":384},{"text":"it could - so, so - don't do this ","width":384},{"text":"these primatives are designed to be extremely high performant so as a result there's no safeguards so look back with nostalgia at Java where Java would say 'excuse me you've gone past the end of the array'","width":832},{"text":"I'm going to politely shut down your process and throw an exception","width":320},{"text":"this doens't exist anymore, you are ice climbinb here and you'd better make sure that every line of code you write is correct","width":512},{"text":"so write code slowly, especially code that deals with locks","width":320},{"text":"especially code that deals with malloc and calloc and free","width":448},{"text":"and realize the lifetime of functions now can be very diferent","width":384},{"text":"so for example here's a student error I saw once where we had some memory ","width":448},{"text":"ok, so calloc sizeof an int, lets have enough memory for say a hundred of them. we'll pass this in is a parameter","width":704},{"text":"and then we'll free our memory","width":384},{"text":"not a good idea","width":384},{"text":"alright, because if my count gold function is now using that memory the code I've just written assumes that I can free it straight away","width":832},{"text":"well hold one, we don't know when countgold is going to end so just because we don't write anymore code in our main function that uses this memory doens't mean we can immediately free it","width":832},{"text":"no I've probably got another thread that's going to use that memory","width":192},{"text":"so now we have to think of the lifetime of our threads as well and how long their going to run","width":448},{"text":"so like I said this is like ice climbing, you do it carefully and think about each line of code and the lifetime of our data structures and whether they - what happens when two threads try to work on them at the same time","width":960},{"text":"alright, any questions about mutex locks?","width":448},{"text":"ok, so, I'll just reiterate the main points again","width":320},{"text":"they're not magic","width":64},{"text":"they're just little loops","width":256},{"text":"a pthread lock is basically just a little loop until that lock is available","width":512},{"text":"so it's up to you to use them as such","width":192}]