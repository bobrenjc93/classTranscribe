[{"text":"[pause]","width":4480},{"text":"okay good morning and welcome to a very cozy edition of CS241","width":448},{"text":"it's eleven o'clock according to siebel 1404","width":192},{"text":"so let's get started","width":64},{"text":"here's what we're going to do today","width":128},{"text":"we're going to look at something called the critical section problem","width":64},{"text":"this is a fundamental idea of how we cope with doing two things at the same time","width":512},{"text":"or to be precise, how do we stop two things from happening at the same time","width":320},{"text":"we played around last lecture with counting gold remember? ","width":384},{"text":"and we saw that if we let two threads access that global variable","width":192},{"text":"then our count will be wrong","width":256},{"text":"and so our messing around reading or writing that piece of data we solve the problem via putting a mutex lock around it","width":704},{"text":"and we said okay right but if we do that then only one thread can continue and change that variable","width":384},{"text":"and the other one has to wait","width":64},{"text":"so what we did is we identified a critical section of our code","width":320},{"text":"where only one thread or one process can manipulate that memory at a time","width":320},{"text":"so what we're going to do now is step back from thinking about mutexes and locks and think about it in terms of some pseudocode and also think about what happens might you implement say mutex lock and mutex unlock","width":896},{"text":"and that is what we're going to do","width":192},{"text":"right so here we go","width":128},{"text":"it turns out for example that someone forgot to implement mutex lock and unlock","width":320},{"text":"and here's my idea of how we could actually implement those two functions","width":640},{"text":"okay so remember the game here is that if two threads called lock only one of them should win","width":576},{"text":"and the other one has to wait","width":128},{"text":"it's the you know any one person in the bathroom at a time type of rule here","width":448},{"text":"so how's the code work?","width":128},{"text":"right so when you call it you pass in a pointer to this mutex object inside that data structure I've got something called lock","width":512},{"text":"which can just be an int","width":64},{"text":"so if someone else has already entered, in other words, if they have already set the lock","width":448},{"text":"then my code does nothing","width":64},{"text":"it just goes around and says okay is it unlocked now is it unlocked now is it unlocked now is it unlocked now?","width":448},{"text":"so it's going to busy wait, it's going to just keep testing that variable","width":320},{"text":"once it's unlocked, my little thread is going to say okay great","width":320},{"text":"now I can set the lock","width":128},{"text":"that means if any other thread at this point tries to lock it, they are going to have to wait","width":576},{"text":"they are going to be inside that busy loop because I still have the lock","width":256},{"text":"and of course eventually when my code finishes I can then just immediately set it back to zero","width":384},{"text":"I don't need to have any loops here, I know that I'm the only thread that could of set this lock","width":384},{"text":"so the code is simple, just unlock the door and walk out","width":256},{"text":"right so that's my first attempt at protecting my critical code, my critical section","width":576},{"text":"so that's my first implementation of how lock and unlock might work","width":192},{"text":"is it any good though?","width":192},{"text":"will it work?","width":64},{"text":"perhaps you and your neighbor can figure out why this proposed code is actually not sufficient ","width":512},{"text":"what race conditions could you see? what would happen if two threads happen to call it at about the same time?","width":512},{"text":"so here's what we have to do, you have to look at that code with two parts of your brain","width":448},{"text":"and imagine two different threads were running the same code","width":192},{"text":"what could happen that would be bad?","width":128},{"text":"[pause]","width":4864},{"text":"okay so what have we discovered?","width":512},{"text":"is this implementation any good?","width":192},{"text":"what do you think?","width":448},{"text":"no, why not?","width":128},{"text":"no okay too scary, alright","width":704},{"text":"so here's our problem, our lock needs a lock","width":320},{"text":"there's a potential race condition here","width":128},{"text":"what would happen if two threads called lock at about the same time","width":256},{"text":"both of them would see that the door is unlocked","width":256},{"text":"yes? both of them would see that the variable is zero. great they say, I don't need to be inside my while loop anymore and they continue","width":448},{"text":"at the same time","width":64},{"text":"so now they both set the lock equal to one and they both return, they both continue","width":384},{"text":"so both of them, both threads are now able to enter the critical section","width":384},{"text":"which is precisely what we didn't want","width":128},{"text":"we wanted to make sure that only one thread at a time could escape from our lock","width":320},{"text":"does that make sense?","width":640},{"text":"because this is the easy one, this lecture is designed to blow your mind","width":576},{"text":"and to make new connections that didn't exist","width":320},{"text":"this stuff is really hard to think about if you have a human brain","width":320}]