[{"text":"So if you don't have enough CPUs to run all the threads, the scheduler says \"I've got this stuff to do\", and puts them in a queue. And we'll  be talking about that when we talk about schedulers.","width":768},{"text":"Every thread, every process from the scheduler's point of view is either in a runnable state or running, or finished, or about to start so part of its job is to keep track of that","width":896},{"text":"Okay so we've got a little function. Its job is to turn a number into a string, and we wrote some implementation, we've got some memory, and it's not thread safe. Why?","width":1088},{"text":"Yes! So if you make something static there can be only one. This is the highlight of the variables. So we've got a single piece of memory, called result. And all threads if they call this will therefore be writing over the same piece of memory. So if you have two threads that are doing this about the same time then they're going to corrupt each other's result. It's like you and I trying to share a secret piece of paper, and I come back to it and I'm like \"what's this writing on it? I didn't write it before.\" We need to make sure that doesn't happen in our program.","width":2944},{"text":"So we've got a problem here. How can we fix it? I know! A temporary variable, an automatic variable, and be done. Yes? It's Friday, the best code is always written on Fridays. It's actually not true. You can actually do data analytics on check-ins and see how many bugs are generated by code on Fridays. Fridays and Monday mornings are the worst. So what mistake have we made now? Okay yes we are returning the pointer to some local memory and after the variable goes out of scope that is not longer valid, that area on the stack is going to be reused for other functions we call","width":3264},{"text":"So we can't just do that","width":64},{"text":"Okay, so how can we fix this? Well one thing we can do is not use any memory inside here at all. Instead we'll change this to take a pointer to some external memory.","width":960},{"text":"And if you look at the c-library, you'll actually see this has happened over time. There were early versions of functions which just declared things, say, using static. The nice thing about that is it's cheap. We don't have to wait for malloc() to find us memory. ","width":1280},{"text":"But the bad news is that it's not thread safe. So later versions of similar functions allow us to pass in a pointer to some memory that can be used.  ","width":512},{"text":"So I'll come back to twelve in a moment. First of all, there's a quiz on Monday!","width":896},{"text":"What? What? Yes, it will be about fork, exec, basic synchro stuff and I/O. ","width":640},{"text":"Here is a hint about some stuff that might be on the quiz, and you can find references to all these things inside the wikibook.","width":1024},{"text":"Is it comprehensive? I'm not quite sure what you mean by that. Will there be things on there which are challenging questions? Absolutely, yeah. They will include gotchas so know the difference between sizeof() a type and sizeof() pointer of a type. It will include code that is good and bad, you are expected to notice when it is bad. ","width":1600},{"text":"I have a habit of writing multiple choice questions which state things like \"hey which one of the following statements is not true?\" So that means you have to recognize false statements which are not true","width":768},{"text":"Right, let's just finish of with these then. The advantage of threads over forking processes: Hey, they share memory, so it is easy for us to communicate between threads. Very very easy","width":1024},{"text":"They're also very cheap. And you too can create a new thread, just call pthread_create! It's trivial, it's easy! So can I fork a process with multiple threads? ","width":1472},{"text":"Yes, but don't. ","width":384},{"text":"Unless you know what you're doing. Unless you're really sure you know what you're doing. Unless you're crazy and you're really sure you know what you're doing","width":384},{"text":"And you want to maintain this code for the rest of your life","width":192},{"text":"So here's why: when you do this, the only thread which survives this cloning is--you know how I said \"Fork, you're gonna clone everything\"? I lied! --the one thread that calls fork() continues. ","width":832},{"text":"In the copy, in the clone. All of the other threads have disappeared. They're no longer running. ","width":384},{"text":"So now all of the other threads in the clone that were doing things have just disappeared. They may have been in the middle of calling malloc(). They may have been in the middle of doing something important. And now the good work that they were doing has disappeared. So that's why in practice it's extremely difficult to write good programs that fork() AFTER they've created more than one running thread.","width":1600},{"text":"So yes, if you want a world of pain.  Otherwise, try not to.","width":512},{"text":"So let's finish with this: condition variables, semaphores, and mutexes. ","width":256},{"text":"This is the meat of the couse","width":320},{"text":"This is the cool stuff. This is the stuff that is going to make your head explode","width":384},{"text":"These are the primitives we are going to learn about so we can communicate with our threads.","width":448},{"text":"So we can make sure that our threads pause while another thread finishes its work","width":256},{"text":"So that we can make sure that threads don't step on each other's memory structures.","width":320},{"text":"So that we can have ten threads write to one memory structure and know that the result is valid at the end. ","width":384},{"text":"So that we can have threads that don't fill up buffers then spin and use up CPU, instead intelligently use the CPU","width":576},{"text":"And we'll be talking about those next week. Have  a wonderful weekend.  Look out for an email from me about the next assignment and the MP. Thank you very much and I'll be here for questions. For those of you that forgot to write down your exam key on the last exam we can find your exam script right now. I know there was like two of you. One percent of the class failed to write down their exam key. So let's fix that","width":1728}]