[{"text":"ok, what would our value be now?","width":448},{"text":"again, about 1.5 million, certainly not two million","width":256},{"text":"our pyrax cannot count","width":320},{"text":"OK, so why did it fail? why did my sum not get two million?","width":512},{"text":"thank you! yes! two threads are touching the same memory location","width":256},{"text":"so even though we wrote sum++, sum++ is not an atomic operation","width":512},{"text":"now like would be easy if our threads were like gorillas","width":256},{"text":"if they walked up to a memory location [giberish]","width":448},{"text":"they changed it, they added one to it","width":192},{"text":"they asked it any other thread","width":256},{"text":"and they threw it back","width":128},{"text":"ok, but that's not how it works of course, no instead we're copying bit patterns","width":384},{"text":"we're copying bit patterns from main memory into the CPU ","width":128},{"text":"we're runnign through our model adding machien and then we're putting the value back into memory","width":256},{"text":"during that time another thread may have come along and coppied the original bit pattern from memory and done it's thing inside it's CPU","width":640},{"text":"and then put it back","width":128},{"text":"so hopefully you can see that it's possible that the value could be less than two million","width":704},{"text":"if it turns out that are trying to add at the same time","width":256},{"text":"in fact it's possible for  the value to be much smaller than that","width":768},{"text":"but let's talk instead about how we can actually fix this","width":320},{"text":"we've made it delibaretly interesting by making sure that each threads are touching the same memory","width":576},{"text":"it would be pretty boring if they were working inside their own stack space","width":256},{"text":"or we'd give them different memory locations to play with, say if we'd give them sum one and sum two then of course everything would be fine","width":512},{"text":"things actually get interesting when we have two threads competing and working on the same memory","width":256},{"text":"so what we'd like to do is say 'oh I've got a problem and here are pices of my code that I only want one thread to play with at time'","width":704},{"text":"in other words, I've got a critical section","width":192},{"text":"and itnside this little example here this single line is my cirtical section","width":256},{"text":"it's the [gibberish] where you say 'I only want one process or one thread' to read this memory or modify this memory","width":576},{"text":"because if I have two threads working then they may see things or leave things in an inconsistent state","width":640},{"text":"now we're programming a very simple exaple with integers and sums","width":128},{"text":"but now think about your other data structures in say CS 225","width":320},{"text":"where you've got multiple memory structures, you've got pointers to arrays, integers which reperesnet the number of things in an array","width":512},{"text":"if you didn't write that thing directly than the STL library did it for you","width":320},{"text":"all those things need to be in a consistent state","width":128},{"text":"if you wrote linked lists then you'd better make sure that you're sentinal value is actually present","width":384},{"text":"and there's a few nanoseconds where that's not true","width":320},{"text":"so whilst you'll updateing a data structure you don't want anybody else to touch it","width":192},{"text":"you dont' want anybody else to read it and you certainly don't want anybody else to try and update it at the same time","width":256},{"text":"so that's where mutex locks in ","width":512},{"text":"so a mutex is a very valuable thing","width":384},{"text":"it's like having a girlfriend or a boyfriend or a dob","width":256},{"text":"it's yours","width":128},{"text":"and you're not going to let anybody else own it","width":192},{"text":"very objective thing","width":128},{"text":"it's mine, I'm jealous","width":192},{"text":"don't let a field holding a mutex, you don't want anybody else","width":256},{"text":"any other thread to try to lock that mutex","width":256},{"text":"if they do they have to wait until you've finished with it","width":448},{"text":"now to be procise we are locking and unlocking","width":256},{"text":"I just wanted to give you some ideas so that in your next jealous outburst you can remember this lecture","width":448},{"text":"alright, so, let's have a look to see how we can do this, is around this critical section we'd like to lock a mutex and afterwords we'd like to unlock it","width":832},{"text":"unlocking doesn't take anytime at all","width":256},{"text":"locking usually doesn't take anytime at all unless somebody else has locked the same mutex","width":320},{"text":"in which case you're out of luck","width":128},{"text":"it's a bit like trying to walk up to a counter, the clerk is currently busy, you'd have to wait and twriddle your thumgs","width":576},{"text":"in fact you might actually use up a bit of CPU time while twiddiling thumbs, it's often called a spin lock","width":448},{"text":"which is how this thing is implemented underneath but we don't need to talk about that","width":128},{"text":"but essentially we've got a little piece of code that says ok, i have to wait i have to wait i ahve to wait i ahve to wait until the mutex lock has been unlocke","width":576},{"text":"but they're designed to be efficient for whatever you want to lock them and unlock them in the very near future","width":512},{"text":"so let's actually have a look at the code for that, how do we do that?","width":320},{"text":"we'll it's part of the pthread library","width":192},{"text":"and we can say I've got a pthread_mutex, here it is, it'sa pthread_mutex_t type","width":448},{"text":"and I'll just call it my mutex one","width":192},{"text":"so now we want to lock it","width":192},{"text":"how can I possibly write that code if pthread_mutex_lock()","width":384},{"text":"what do I need to give it? the address of the mutex","width":256},{"text":"and guess how I unlock it","width":256},{"text":"you write pthread_mutex_unlock()","width":192},{"text":"OK, so now we think we've got working code","width":256},{"text":"let's try it and just for fun I'm going to reduce the number I wrote by an order of magnitute to make it run a bit faster","width":192},{"text":"tick tick tick","width":704},{"text":"suddenly we noticed even though I made the for loop to help with the speed I think it returned","width":576},{"text":"OK, heres, here's to the first surprise, it shouldn't hav worked","width":448},{"text":"[laughs]","width":64},{"text":"it appeared to work, but that's just lulling you into a false sense of security","width":576},{"text":"the second surprise is that it took a bit longer","width":128},{"text":"so at least I'm sorry I took the loop down by an order of magnitutde yet it still took a long time","width":384},{"text":"so this is a not free the lock and unlock are not free, it takes a crtain amount of time","width":320},{"text":"especially if you look at how much overhead we're doing in this example","width":128},{"text":"we'ere just incrementing and getting them out of a loop. so they don't take a small amount of time to run","width":512},{"text":"the second thign is that they may not work if you've gotten to initialize them","width":320},{"text":"and this time for a [givver] i was unlucky that it did work","width":256},{"text":"what we should do is make sure that our mutex locks are properly initialized","width":384},{"text":"alright, so how can I do that?","width":128},{"text":"well before using them we should call pthread_mutex_init","width":512},{"text":"and let's look at the man page","width":192},{"text":"we can pass in a pointer to mutex as some attribrutes if we'd like as well","width":448},{"text":"so I can say 'ok initialize my mutex and here's some additional attributes I could set up for them as well","width":320}]