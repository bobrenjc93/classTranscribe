[{"text":"and, if we do that, we actually have Peterson's solution","width":896},{"text":"so now Peterson's solution says \"I'm only going to look at your flag if the turn variable is pointing at you\"","width":1152},{"text":"otherwise, I'm just going to be the bully and walk in","width":256},{"text":"now, I'm not going to spend twenty minutes to prove that this works","width":512},{"text":"because we'd actually have to look carefully at the possible different sequences of how this could work","width":448},{"text":"well I'm going to kind of just do a little bit of hand waving which is just. I think you can agree that by the time we get to the wait loop, one of them has set the turn variable","width":960},{"text":"so the turn variable is either pointing at process 1 or process 2. one of them has finished doing that most recently","width":384},{"text":"so, one thread will wait. and the other, will continue.","width":448},{"text":"so we've solved the progress problem","width":192},{"text":"right, so dekker and peterson are two solutions to this and every systems programmer should be able to kind of recognize how these solutions work","width":1344},{"text":"sorry, at least be able to recognize these solutions","width":256},{"text":"you'll notice what peterson did, what peterson noticed was this. was setting the turn to me before the wait","width":448},{"text":"that was his insight","width":128},{"text":"to say \"oh look! if I change the turn variable to me, BEFOREhand, I can actually write a really really simple solution\"","width":512},{"text":"and like I said, that wasn't actually discovered until 1981","width":320},{"text":"okay, what about the last one?","width":192},{"text":"does this work?","width":448},{"text":"what about algorithm 4? or solution 4?","width":576},{"text":"no progress again! yes, we can have a case where both sides are seeing each others flag being","width":960},{"text":"each others flag is raised and so we get stuck","width":256},{"text":"alright so, we've worked out two possible solutions. dekker's solution and peterson's solution here. through that minor change here","width":576},{"text":"how about enable us to actually implement a mutex lock and unlock?","width":256},{"text":"what part of the code would you put inside mutex lock and which part would you put inside unlock?","width":384},{"text":"alright. it's actually not that hard, right? let's use dekker's solution. we'll say this is the pseudocode I'm going to put inside","width":640},{"text":"the lock","width":128},{"text":"and this is the part that we'll put inside unlock","width":384},{"text":"and we better write some documentation to say that our code actually only works for two threads","width":448},{"text":"and if you want to use this for more than two threads, you better pay me more to think real hard about how to generalize this","width":448},{"text":"okay so, not bad for a morning's work! look, it's only 11:25 and we've already figured out some code to write mutex lock and mutex unlock. unfortunately, we come back a moment later and people say, wait, you know what? okay, it failed!","width":1088},{"text":"what do you say? this is impossible! I learned this in class! this is a correct solution. I even proved that it's correct","width":704},{"text":"it doesn't work","width":64},{"text":"it does not work on modern hadware","width":256},{"text":"here's why","width":128},{"text":"the C code that we write even the assembly code that we write, does not always correspond to exactly what happens in the hardware","width":704},{"text":"we try to make our hardware run as fast as possible. so, here's some things to abide to","width":448},{"text":"first of all, we can have a cache problem that what CPU thinks is in memory is being provided by the cache on the chip, on the CPU","width":576},{"text":"so if we've got two distant CPUs, they may not update the memory and notify each other that the value has changed","width":512},{"text":"so all this stuff about testing a turn variable and looking your flag, I might actually be looking at stale values that have not yet propogated from one CPU cache to another CPU cache","width":704},{"text":"a second problem is that actually our CPU can execute instructions out of order","width":320},{"text":"now before you panic and say \"oh! whats gonna happen to my code?\" don't panic too much. actually all the stuff we're going to do with pthread_mutex_lock ensures that the all the instructions up to that point are fully executed and completed","width":1280},{"text":"so, I'm not going to talk anymore about how this can bite you. other than don't panic because guess what, we've got the exchange instruction that we can use at the lowest level to make sure that we really do have a complete round trip to main memory as opposed to dealing with stale values in the cache","width":1600},{"text":"okay, right, any other questions about these?","width":832},{"text":"when we have an exam, when we have a quiz about this stuff, I will be writing these kinds of problems and asking you to figure out if its a valid solution or not. or if it is a valid solution, whether its dekkers solution or peterson's","width":1088},{"text":"any other questions?","width":64},{"text":"good! we have round two!","width":192},{"text":"here we go, condition variables!","width":192},{"text":"alright, we're gonna write some code that actually uses a condition variable","width":640},{"text":"okay so, along the way I'll write some pseudocode I'll turn into real code and I'll talk about some gotchas","width":512},{"text":"so for example, one common gotcha is that we forget to actually initialize this stuff","width":320},{"text":"if you forget to initialize it, then yes you still got some memory reserved but it may not be connected to any actual real system resource that does some of the work for you","width":640},{"text":"so calling your mutex lock unlock may just silently fail","width":448},{"text":"because you never bothered to initialize it correctly","width":64},{"text":"so that's just a common gotcha","width":128},{"text":"so, if your friend leaves their workstation or their laptop open for a moment, just quietly walk over and delete their initialization code. they'll never know and they'll be stuck for hours","width":768},{"text":"alright, so how do I have these things, how do I create these things in my code?","width":384},{"text":"guess what? the pthread library gives you one, here it is. I'm gonna have this little variable called cv","width":320},{"text":"and you might notice in this code I've got a mutex lock as well","width":256},{"text":"it turns out that whenever you need a condition variable, you are going to need a mutex lock as well","width":512},{"text":"it's like the little side kick that comes along to the party","width":320},{"text":"you can't uninvite them. I'm sorry they just won't come together as a pair","width":192},{"text":"you're gonna see a mutex lock and a condition variable together","width":256},{"text":"why? because a mutex lock makes our lives much simpler","width":384},{"text":"the mutex lock allows us to reason that one thread at a time is doing things inside a critical section","width":512}]