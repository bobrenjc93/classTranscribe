[{"text":"if you are working with a single threaded process and use sigprocmask","width":384},{"text":"guess what, if you're compiling with pthreads, then use pthread_sigmask","width":512},{"text":"this allows you to have different masks for different threads","width":256},{"text":"so now we can talk about whether a signal will be delivered","width":896},{"text":"for a multithreaded process","width":384},{"text":"and we saw that it will be delivered","width":384},{"text":"to one thread and it can be any thread that is not blocking the signal","width":1472},{"text":"so what does this mean in practice? in practice this means typically in our initialization code before we called pthread_create","width":1536},{"text":"let's just try and block everything, let's just serve a big mask and say hey we don't want to know about signals right now","width":384},{"text":"and then later in one particular thread, we'll say we'll deliver signals to this particular thread","width":384},{"text":"and we'll lower our guard, we'll lower the mask for that particular thread","width":320},{"text":"so what's it mean when a thread actually gets a signal","width":192},{"text":"it means that thread is going to be stopped from executing the code that it's currently working on","width":384},{"text":"and they are going to steal it","width":64},{"text":"we're going to use its stack","width":128},{"text":"to execute the code that we write inside the signal handler","width":320},{"text":"so anything it was in the middle of doing, let's say it was in the middle of malloc, let's say it was in the middle of updating a data structure","width":640},{"text":"that is put on hold","width":64},{"text":"whilst we do whatever is inside our signal handler","width":256},{"text":"this is why things can be signal unsafe","width":256},{"text":"suppose your halfway through updating your data structure or suppose malloc is updating its data structure","width":384},{"text":"and then you try to go in and do something to that datastructure","width":256},{"text":"whoops now you're reading and writing from the wrong bytes","width":192},{"text":"we can't use mutex locks for this to prevent this because we are actually stealing the thread in order to run our signal handler code","width":832},{"text":"so I'll talk about a way around this in a moment where we can take a lot more careful control about when and how we handle particular signals","width":768},{"text":"okay so how do I learn more about this?","width":384},{"text":"on linux, not on your mac, but on linux, in section 7, there's a whole long article all about signals","width":704},{"text":"so we use -s7 to say go to section 7 and we can read all about that","width":256},{"text":"so let's talk about appending signals","width":768},{"text":"remember appending signals is our signals [something] throw","width":192},{"text":"and pending signals work in the opposite way to our signal disposition","width":768},{"text":"that when we call fork the new child has nothing","width":320},{"text":"on the other hand if you call exec some sort of exec call","width":576},{"text":"pending signals are preserved","width":320},{"text":"so that means you could do something like that following","width":448},{"text":"let's fork and then in the child...","width":128},{"text":"we know there's nothing appending yet because we've just forked right?","width":512},{"text":"so let's deliberately raise something here","width":192},{"text":"okay so I'm going to raise SIGINT","width":704},{"text":"now if I hadn't done a signal mask at this point that could be delivered straight away","width":384},{"text":"whoops I've just managed to control C myself","width":192},{"text":"but instead in this little example, we're going to suppose...","width":384},{"text":"we've already set our mask","width":384},{"text":"suppose our mask already includes SIGINT, in other words, I'm not...","width":704},{"text":"going to accept your SIGINTs right now, talk to the hand right? I'm blocking this","width":320},{"text":"but the next thing we do is we exec something","width":128},{"text":"wahahaha what happens now?","width":640},{"text":"pending signals preserved","width":320},{"text":"the mask gets reset","width":128},{"text":"because that's what happens when you...","width":256},{"text":"oh, wait wait","width":192},{"text":"I'm certain that if in my exec code, if that now changes the mask, it can get my control C, I could actually interrupt a process before it has even started up by generating a pending signal","width":1216},{"text":"so my other process will get the signal later when the mask is changed","width":576},{"text":"and we won't say generated, we'll say delivered!","width":640},{"text":"so reasoning about signals and working with them is tricky because we have to think about the timing of when things happen and we have to be careful about what our masks are","width":2112},{"text":"right so I've talked about pending signals","width":576},{"text":"if I want to send a signal, if I'm inside a multithreaded program I want to send a particular thread I can use pthread_kill","width":832},{"text":"if I want to just send a signal to my whole process I can send raise, if I want to send it to another process, I can use kill","width":576},{"text":"so signals are at the process level","width":576},{"text":"however, in a multithreaded process which thread actually catches them and performs a signal handler that you've installed","width":704},{"text":"is dependent on the signal mask of all your processes","width":320}]